
 <!DOCTYPE HTML>
<html >
<head>
  <meta charset="UTF-8">
  
    <title>TensorFlow线性模型教程 | 智子</title>
    <meta name="viewport" content="width=device-width, initial-scale=1,user-scalable=no">
    
    <meta name="author" content="zhizi">
    

    
    <meta name="description" content="TensorFlow线性模型教程在本教程中，我们将使用TensorFlow中的tf.estimator API来解决这个问题 二元分类问题：给定一个人的普查数据，如年龄，教育程度，婚姻状况和职业（特征），我们将尝试预测 无论这个人一年挣多5万美元（目标） 标签）。我们将训练逻辑回归模型，并给予个人的我们的模型的信息将输出一个介于0和1之间的数字，这可以是 解释为个人年收入超过的概率 5万美元 建立">
<meta name="keywords" content="机器学习">
<meta property="og:type" content="article">
<meta property="og:title" content="TensorFlow线性模型教程">
<meta property="og:url" content="https://www.tracholar.top/2018/01/01/wide/index.html">
<meta property="og:site_name" content="智子">
<meta property="og:description" content="TensorFlow线性模型教程在本教程中，我们将使用TensorFlow中的tf.estimator API来解决这个问题 二元分类问题：给定一个人的普查数据，如年龄，教育程度，婚姻状况和职业（特征），我们将尝试预测 无论这个人一年挣多5万美元（目标） 标签）。我们将训练逻辑回归模型，并给予个人的我们的模型的信息将输出一个介于0和1之间的数字，这可以是 解释为个人年收入超过的概率 5万美元 建立">
<meta property="og:updated_time" content="2018-01-16T12:42:41.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="TensorFlow线性模型教程">
<meta name="twitter:description" content="TensorFlow线性模型教程在本教程中，我们将使用TensorFlow中的tf.estimator API来解决这个问题 二元分类问题：给定一个人的普查数据，如年龄，教育程度，婚姻状况和职业（特征），我们将尝试预测 无论这个人一年挣多5万美元（目标） 标签）。我们将训练逻辑回归模型，并给予个人的我们的模型的信息将输出一个介于0和1之间的数字，这可以是 解释为个人年收入超过的概率 5万美元 建立">

    
    <link rel="alternative" href="/atom.xml" title="智子" type="application/atom+xml">
    
    
    <link rel="icon" href="/img/favicon.ico">
    
    
    <link rel="apple-touch-icon" href="/img/jacman.jpg">
    <link rel="apple-touch-icon-precomposed" href="/img/jacman.jpg">
    
    <link rel="stylesheet" href="/css/style.css">

    <!-- ad start -->
    <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<script>
  (adsbygoogle = window.adsbygoogle || []).push({
    google_ad_client: "ca-pub-6300557868920774",
    enable_page_level_ads: true
  });
</script>

    <!-- ad end -->

    <!--  stat -->
    <script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?4036f580b1119e720db871571faa68cc";
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(hm, s);
})();
</script>

    <!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-78529611-1"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-78529611-1');
</script>

    <!-- end stat -->
</head>

  <body>
    <header>
      
<div>
		
			<div id="textlogo">
				<h1 class="site-name"><a href="/" title="智子">智子</a></h1>
				<h2 class="blog-motto">智子之家</h2>
			</div>
			<div class="navbar"><a class="navbutton navmobile" href="#" title="菜单">
			</a></div>
			<nav class="animated">
				<ul>
					<ul>
					 
						<li><a href="/">Home</a></li>
					
						<li><a href="/archives">Archives</a></li>
					
						<li><a href="/about">About</a></li>
					
					<li>
 					
					<form class="search" action="//google.com/search" method="get" accept-charset="utf-8">
						<label>Search</label>
						<input type="search" id="search" name="q" autocomplete="off" maxlength="20" placeholder="搜索" />
						<input type="hidden" name="q" value="site:www.tracholar.top">
					</form>
					
					</li>
				</ul>
			</nav>			
</div>
    </header>
    <div id="container">
      <div id="main" class="post" itemscope itemprop="blogPost">
  
	<article itemprop="articleBody">
		<header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2018/01/01/wide/" title="TensorFlow线性模型教程" itemprop="url">TensorFlow线性模型教程</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="zhizi" target="_blank" itemprop="author">zhizi</a>
		
  <p class="article-time">
    <time datetime="2018-01-01T02:00:00.000Z" itemprop="datePublished"> 发表于 2018-01-01</time>
    
  </p>
</header>
	<div class="article-content">
		
		<div id="toc" class="toc-article">
			<strong class="toc-title">文章目录</strong>
		
			<ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#undefined"><span class="toc-number">1.</span> <span class="toc-text">TensorFlow线性模型教程</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#undefined"><span class="toc-number">1.1.</span> <span class="toc-text">建立</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#undefined"><span class="toc-number">1.2.</span> <span class="toc-text">读取人口普查数据</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#undefined"><span class="toc-number">1.3.</span> <span class="toc-text">将数据转换为张量</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#undefined"><span class="toc-number">1.4.</span> <span class="toc-text">模型的选择和工程特性</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#undefined"><span class="toc-number">1.4.1.</span> <span class="toc-text">基本分类特征列</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#undefined"><span class="toc-number">1.4.2.</span> <span class="toc-text">基本连续功能列</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#undefined"><span class="toc-number">1.4.3.</span> <span class="toc-text">通过分解实现连续性特征的分类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#undefined"><span class="toc-number">1.4.4.</span> <span class="toc-text">用CrossedColumn交叉多列</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#undefined"><span class="toc-number">1.5.</span> <span class="toc-text">定义Logistic回归模型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#undefined"><span class="toc-number">1.6.</span> <span class="toc-text">培训和评估我们的模型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#undefined"><span class="toc-number">1.7.</span> <span class="toc-text">加入正则化来防止过度拟合</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#undefined"><span class="toc-number">1.8.</span> <span class="toc-text">逻辑回归如何工作</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#undefined"><span class="toc-number">1.9.</span> <span class="toc-text">深入学习</span></a></li></ol></li></ol>
		
		</div>
		

        <ins class="adsbygoogle"
     style="display:block; text-align:center; overflow:hidden;"
     data-ad-layout="in-article"
     data-ad-format="fluid"
     data-ad-client="ca-pub-6300557868920774"
     data-ad-slot="6882414849"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>


		<h1><span id="tensorflow线性模型教程">TensorFlow线性模型教程</span></h1><p>在本教程中，我们将使用TensorFlow中的tf.estimator API来解决这个问题 二元分类问题：给定一个人的普查数据，如年龄，<br>教育程度，婚姻状况和职业（特征），我们将尝试预测 无论这个人一年挣多5万美元（目标） 标签）。我们将训练逻辑回归模型，并给予个人的<br>我们的模型的信息将输出一个介于0和1之间的数字，这可以是 解释为个人年收入超过的概率 5万美元</p>
<h2><span id="建立">建立</span></h2><p>要尝试本教程的代码：</p>
<p>如果你还没有安装TensorFlow， 下载教程代码。 执行我们提供给您的数据下载脚本： $ python data_download.py<br>使用以下命令执行教程代码以训练线性 模型在本教程中描述： $ python wide_deep.py –model_type = wide</p>
<p>继续阅读以了解此代码如何构建其线性模型。</p>
<h2><span id="读取人口普查数据">读取人口普查数据</span></h2><p>我们将使用的数据集是 人口普查收入数据集。 我们提供了 data_download.py 下载代码并执行一些额外的清理。</p>
<p>由于任务是一个二元分类问题，我们将构造一个标签 列名为“标签”，如果收入超过5万，则为1 除此以外。有关参考，请参阅<code>input_fn</code><br>wide_deep.py。</p>
<p>接下来，我们来看看数据框，看看我们可以使用哪些列 预测目标标签。这些列可以分为两类 - 分类 和连续的列：</p>
<p>如果一个列的值只能是其中的一个，则该列被称为分类     有限集合中的类别。例如，一个人的关系状态     （妻子，丈夫，未婚等）或教育水平（高中，<br>大学等）是分类专栏。 如果某列的值可以是任何数值，则称该列为连续的     一个连续的范围。例如，一个人的资本收益（例如$ 14,084）<br>是一个连续的列。</p>
<p>以下是人口普查收入数据集中可用列的列表：</p>
<table>
<thead>
<tr>
<th>Column Name</th>
<th>Type</th>
<th>Description  </th>
</tr>
</thead>
<tbody>
<tr>
<td>age</td>
<td>Continuous</td>
<td>The age of the individual  </td>
</tr>
<tr>
<td>workclass</td>
<td>Categorical</td>
<td>The type of employer the individual has (government,</td>
</tr>
</tbody>
</table>
<p>military, private, etc.).<br>fnlwgt | Continuous | The number of people the census takers believe that<br>observation represents (sample weight). Final weight will not be used.<br>education | Categorical | The highest level of education achieved for that<br>individual.<br>education_num | Continuous | The highest level of education in numerical form.<br>marital_status | Categorical | Marital status of the individual.<br>occupation | Categorical | The occupation of the individual.<br>relationship | Categorical | Wife, Own-child, Husband, Not-in-family, Other-<br>relative, Unmarried.<br>race | Categorical | White, Asian-Pac-Islander, Amer-Indian-Eskimo, Other,<br>Black.<br>gender | Categorical | Female, Male.<br>capital_gain | Continuous | Capital gains recorded.<br>capital_loss | Continuous | Capital Losses recorded.<br>hours_per_week | Continuous | Hours worked per week.<br>native_country | Categorical | Country of origin of the individual.<br>income | Categorical | “&gt;50K” or “&lt;=50K”, meaning whether the person makes<br>more than $50,000 annually.  </p>
<h2><span id="将数据转换为张量">将数据转换为张量</span></h2><p>在建立一个tf.estimator模型时，输入数据是通过一个 输入生成器功能。这个构建函数直到它才会被调用<br>后来传递给tf.estimator.Estimator方法，如<code>train</code>和<code>evaluate</code>。 这个功能的目的是构建输入数据，这是<br>以<code>tf.Tensor</code>或<code>tf.SparseTensor</code>的形式表示。 更详细地说，输入生成器函数将成对返回以下内容：</p>
<p><code>features</code>：从特征列名到<code>Tensors</code>的字典或     <code>SparseTensors</code>。 <code>labels</code>：含有标签柱的<code>Tensor</code>。</p>
<p><code>features</code>的键将用于构建下一个列 部分。因为我们想用<code>train</code>和<code>evaluate</code>方法来调用<br>不同的数据，我们定义一个方法返回一个输入函数的基础上 给出的数据。请注意，返回的输入函数将被调用 构建TensorFlow图，而不是在运行图时。这是什么<br>返回是输入数据表示的基本单位 TensorFlow计算，<code>Tensor</code>（或<code>SparseTensor</code>）。</p>
<p>列车中的每个连续列或测试数据将被转换成一个 <code>Tensor</code>，它通常是一种很好的格式来表示密集的数据。对于<br>分类数据，我们必须将数据表示为<code>SparseTensor</code>。这个数据 格式适合表示稀疏数据。我们的<code>input_fn</code>使用<code>tf.data</code><br>API，可以很容易地将转换应用于我们的数据集：</p>
<pre><code>def input_fn(data_file, num_epochs, shuffle, batch_size):
  &quot;&quot;&quot;Generate an input function for the Estimator.&quot;&quot;&quot;
  assert tf.gfile.Exists(data_file), (
      &apos;%s not found. Please make sure you have either run data_download.py or &apos;
      &apos;set both arguments --train_data and --test_data.&apos; % data_file)

  def parse_csv(value):
    print(&apos;Parsing&apos;, data_file)
    columns = tf.decode_csv(value, record_defaults=_CSV_COLUMN_DEFAULTS)
    features = dict(zip(_CSV_COLUMNS, columns))
    labels = features.pop(&apos;income_bracket&apos;)
    return features, tf.equal(labels, &apos;&gt;50K&apos;)

  # Extract lines from input files using the Dataset API.
  dataset = tf.data.TextLineDataset(data_file)

  if shuffle:
    dataset = dataset.shuffle(buffer_size=_SHUFFLE_BUFFER)

  dataset = dataset.map(parse_csv, num_parallel_calls=5)

  # We call repeat after shuffling, rather than before, to prevent separate
  # epochs from blending together.
  dataset = dataset.repeat(num_epochs)
  dataset = dataset.batch(batch_size)

  iterator = dataset.make_one_shot_iterator()
  features, labels = iterator.get_next()
  return features, labels
</code></pre><h2><span id="模型的选择和工程特性">模型的选择和工程特性</span></h2><p>选择和制作正确的特征列是学习的关键 有效的模式。一个特征列可以是其中的一个原始列 原始数据框（我们称之为基本特征列）或任何新的<br>基于在一个或多个基础上定义的一些转换创建的列 列（我们称之为派生特征列）。基本上“功能 列“是任何可以使用的原始或衍生变量的抽象概念 预测目标标签。</p>
<h3><span id="基本分类特征列">基本分类特征列</span></h3><p>要为分类特征定义特征列，我们可以创建一个 <code>CategoricalColumn</code>使用tf.feature_column API。如果你知道所有的集合<br>一个列的可能的特征值，只有其中的几个，你可以 使用<code>categorical_column_with_vocabulary_list</code>。列表中的每个键都会得到<br>分配从0开始的自动增量ID。例如，对于 <code>relationship</code>栏可以将特征字符串“丈夫”分配给一个整数 ID为0，“不在家”为1等，做法是：</p>
<pre><code>relationship = tf.feature_column.categorical_column_with_vocabulary_list(
    &apos;relationship&apos;, [
        &apos;Husband&apos;, &apos;Not-in-family&apos;, &apos;Wife&apos;, &apos;Own-child&apos;, &apos;Unmarried&apos;,
        &apos;Other-relative&apos;])
</code></pre><p>如果我们事先不知道可能的价值观呢？不是问题。我们 可以用<code>categorical_column_with_hash_bucket</code>代替：</p>
<pre><code>occupation = tf.feature_column.categorical_column_with_hash_bucket(
    &apos;occupation&apos;, hash_bucket_size=1000)
</code></pre><p><code>occupation</code>功能列中的每个可能的值将会发生什么 当我们在训练中遇到它们时将被散列为整数ID。看一个例子 插图如下：</p>
<table>
<thead>
<tr>
<th>ID</th>
<th>Feature  </th>
</tr>
</thead>
<tbody>
<tr>
<td>…</td>
<td></td>
</tr>
<tr>
<td>9</td>
<td><code>&quot;Machine-op-inspct&quot;</code>  </td>
</tr>
<tr>
<td>…</td>
<td></td>
</tr>
<tr>
<td>103</td>
<td><code>&quot;Farming-fishing&quot;</code>  </td>
</tr>
<tr>
<td>…</td>
<td></td>
</tr>
<tr>
<td>375</td>
<td><code>&quot;Protective-serv&quot;</code>  </td>
</tr>
<tr>
<td>…</td>
<td></td>
</tr>
</tbody>
</table>
<p>无论我们选择哪一种方式来定义<code>SparseColumn</code>，每个功能字符串 将通过查找一个固定的映射或散列来映射到一个整数ID。<br>请注意，散列冲突是可能的，但可能不会显着影响 模型质量。 <code>LinearModel</code>课程负责人 管理映射并创建<code>tf.Variable</code>来存储模型参数<br>（也称为模型权重）为每个功能ID。模型参数将是 通过模型培训过程了解到，我们稍后会经历。</p>
<p>我们将做类似的技巧来定义其他的分类特征：</p>
<pre><code>education = tf.feature_column.categorical_column_with_vocabulary_list(
    &apos;education&apos;, [
        &apos;Bachelors&apos;, &apos;HS-grad&apos;, &apos;11th&apos;, &apos;Masters&apos;, &apos;9th&apos;, &apos;Some-college&apos;,
        &apos;Assoc-acdm&apos;, &apos;Assoc-voc&apos;, &apos;7th-8th&apos;, &apos;Doctorate&apos;, &apos;Prof-school&apos;,
        &apos;5th-6th&apos;, &apos;10th&apos;, &apos;1st-4th&apos;, &apos;Preschool&apos;, &apos;12th&apos;])

marital_status = tf.feature_column.categorical_column_with_vocabulary_list(
    &apos;marital_status&apos;, [
        &apos;Married-civ-spouse&apos;, &apos;Divorced&apos;, &apos;Married-spouse-absent&apos;,
        &apos;Never-married&apos;, &apos;Separated&apos;, &apos;Married-AF-spouse&apos;, &apos;Widowed&apos;])

relationship = tf.feature_column.categorical_column_with_vocabulary_list(
    &apos;relationship&apos;, [
        &apos;Husband&apos;, &apos;Not-in-family&apos;, &apos;Wife&apos;, &apos;Own-child&apos;, &apos;Unmarried&apos;,
        &apos;Other-relative&apos;])

workclass = tf.feature_column.categorical_column_with_vocabulary_list(
    &apos;workclass&apos;, [
        &apos;Self-emp-not-inc&apos;, &apos;Private&apos;, &apos;State-gov&apos;, &apos;Federal-gov&apos;,
        &apos;Local-gov&apos;, &apos;?&apos;, &apos;Self-emp-inc&apos;, &apos;Without-pay&apos;, &apos;Never-worked&apos;])

# To show an example of hashing:
occupation = tf.feature_column.categorical_column_with_hash_bucket(
    &apos;occupation&apos;, hash_bucket_size=1000)
</code></pre><h3><span id="基本连续功能列">基本连续功能列</span></h3><p>同样，我们可以为每个连续特征列定义一个<code>NumericColumn</code> 我们想在模型中使用：</p>
<pre><code>age = tf.feature_column.numeric_column(&apos;age&apos;)
education_num = tf.feature_column.numeric_column(&apos;education_num&apos;)
capital_gain = tf.feature_column.numeric_column(&apos;capital_gain&apos;)
capital_loss = tf.feature_column.numeric_column(&apos;capital_loss&apos;)
hours_per_week = tf.feature_column.numeric_column(&apos;hours_per_week&apos;)
</code></pre><h3><span id="通过分解实现连续性特征的分类">通过分解实现连续性特征的分类</span></h3><p>有时连续特征和标签之间的关系不是 线性的。作为一个假设的例子，一个人的收入可能随着年龄的增长而增长 事业的早期阶段，那么增长速度可能会放慢，最后<br>退休后收入减少。在这种情况下，使用原始的<code>age</code>作为 一个实值特征列可能不是一个好的选择，因为该模型可以 只学习三种情况之一：</p>
<p>收入总是随着年龄增长而增长（正相关）， 收入总是随着年龄的增长而减少（负相关），或者 不论年龄多少，收入都保持不变（不相关）</p>
<p>如果我们想要学习收入与各个年龄之间的细微关联， 分组分组，可以利用分期付款。巴克化是一个过程 将连续特征的整个范围划分为一组连续的特征<br>箱/桶，然后将原始数字特征转换成桶 ID（作为分类特征），取决于该值落入哪个桶。<br>因此，我们可以通过<code>bucketized_column</code>定义<code>age</code>，如下所示：</p>
<pre><code>age_buckets = tf.feature_column.bucketized_column(
    age, boundaries=[18, 25, 30, 35, 40, 45, 50, 55, 60, 65])
</code></pre><p>其中<code>boundaries</code>是一个桶边界列表。在这种情况下，有 10个界限，导致11个年龄段桶（从17岁以下，18-24岁，<br>25-29，…，65以上）。</p>
<h3><span id="用crossedcolumn交叉多列">用CrossedColumn交叉多列</span></h3><p>单独使用每个基本特征列可能不足以解释数据。 例如，教育与标签之间的相关性（收入&gt; 50,000美元）<br>美元）可能会因不同的职业而有所不同。因此，如果我们只学习<br><code>education=&quot;Bachelors&quot;</code>和<code>education=&quot;Masters&quot;</code>的单一型号重量，我们 将无法捕获每一个教育职业组合（例如，<br>区分<code>education=&quot;Bachelors&quot; AND occupation=&quot;Exec-managerial&quot;</code><br>和<code>education=&quot;Bachelors&quot; AND occupation=&quot;Craft-repair&quot;</code>）。要学习<br>不同的功能组合之间的差异，我们可以添加交叉功能 模型列。</p>
<pre><code>education_x_occupation = tf.feature_column.crossed_column(
    [&apos;education&apos;, &apos;occupation&apos;], hash_bucket_size=1000)
</code></pre><p>我们也可以创建一个超过两列的<code>CrossedColumn</code>。每 组成列可以是分类的基础特征列<br>（<code>SparseColumn</code>），一个bucketized实值特征列（<code>BucketizedColumn</code>），<br>甚至另一台<code>CrossColumn</code>。这是一个例子：</p>
<pre><code>age_buckets_x_education_x_occupation = tf.feature_column.crossed_column(
    [age_buckets, &apos;education&apos;, &apos;occupation&apos;], hash_bucket_size=1000)
</code></pre><h2><span id="定义logistic回归模型">定义Logistic回归模型</span></h2><p>处理完输入数据并定义所有的特征列后，我们现在就完成了 准备把它们放在一起，建立一个Logistic回归模型。在里面<br>在上一节中，我们已经看到几种类型的基础和派生特征列， 包含：</p>
<p><code>CategoricalColumn</code> <code>NumericColumn</code> <code>BucketizedColumn</code> <code>CrossedColumn</code></p>
<p>所有这些都是抽象的<code>FeatureColumn</code>类的子类，可以是 添加到模型的<code>feature_columns</code>领域：</p>
<pre><code>base_columns = [
    education, marital_status, relationship, workclass, occupation,
    age_buckets,
]
crossed_columns = [
    tf.feature_column.crossed_column(
        [&apos;education&apos;, &apos;occupation&apos;], hash_bucket_size=1000),
    tf.feature_column.crossed_column(
        [age_buckets, &apos;education&apos;, &apos;occupation&apos;], hash_bucket_size=1000),
]

model_dir = tempfile.mkdtemp()
model = tf.estimator.LinearClassifier(
    model_dir=model_dir, feature_columns=base_columns + crossed_columns)
</code></pre><p>该模型还自动学习控制预测的偏差项 人们可以在不观察任何特征的情况下（参见“如何物流” 回归工程“以获得更多解释），学习的模型文件将被存储<br>在<code>model_dir</code>中。</p>
<h2><span id="培训和评估我们的模型">培训和评估我们的模型</span></h2><p>将所有的功能添加到模型后，现在让我们看看如何实际 训练模型。训练一个模型只是一个单一的命令使用 tf.estimator API：</p>
<pre><code>model.train(input_fn=lambda: input_fn(train_data, num_epochs, True, batch_size))
</code></pre><p>在模型被训练之后，我们可以评估我们的模型在预测方面有多好 坚持数据的标签：</p>
<pre><code>results = model.evaluate(input_fn=lambda: input_fn(
    test_data, 1, False, batch_size))
for key in sorted(results):
  print(&apos;%s: %s&apos; % (key, results[key]))
</code></pre><p>最终输出的第一行应该是这样的 <code>accuracy: 0.83557522</code>，表示准确率为83.6％。随意尝试更多 功能和转换，看看你能做得更好！</p>
<p>如果你想看到一个工作的端到端的例子，你可以下载我们的 示例代码 并将<code>model_type</code>标志设置为<code>wide</code>。</p>
<h2><span id="加入正则化来防止过度拟合">加入正则化来防止过度拟合</span></h2><p>正规化是一种避免过度拟合的技术。过度配合发生 当你的模型在训练的数据上表现良好，但在测试数据上更糟糕 这个模型以前没有见过，比如现场交通。过度配合一般<br>当模型过于复杂，如参数太多时会发生 相对于观察到的训练数据的数量。正规化允许你 控制你的模型的复杂性，使模型更一般化 看不见的数据。</p>
<p>在线性模型库中，可以将L1和L2正则化添加到模型中 如：</p>
<pre><code>model = tf.estimator.LinearClassifier(
    model_dir=model_dir, feature_columns=base_columns + crossed_columns,
    optimizer=tf.train.FtrlOptimizer(
        learning_rate=0.1,
        l1_regularization_strength=1.0,
        l2_regularization_strength=1.0))
</code></pre><p>L1和L2正则化之间的一个重要区别是L1 正则化倾向于使模型权重保持为零，创造更稀疏 模型，而L2正则化也试图使模型权重更接近<br>零但不一定是零。所以，如果你增加L1的实力 正规化，因为许多模型，你将有一个更小的模型大小 权重将为零。当特征空间非常大时，这通常是可取的<br>大但稀疏，当有资源限制，阻止你 为一个太大的模型提供服务。</p>
<p>在实践中，你应该尝试L1，L2正则化的各种组合 优势，并找到最好的控制过度和给予的最佳参数 你一个理想的模型大小。</p>
<h2><span id="逻辑回归如何工作">逻辑回归如何工作</span></h2><p>最后，让我们花一点时间来谈谈什么是Logistic回归模型 实际上看起来像你不熟悉它。我们会表示 标签为\（Y \），观察特征集为特征向量 \（\<br>mathbf {x} = [x_1，x_2，…，x_d] \）。我们定义\（Y = 1 \）如果一个人 赚取了5万美元以及\（Y = 0<br>\）。在Logistic回归中， 给定特征的标签为正（\（Y = 1 \））的概率 \（\ mathbf {x} \）给出如下：</p>
<p>$$ P(Y=1|\mathbf{x}) = \frac{1}{1+\exp(-(\mathbf{w}^T\mathbf{x}+b))}$$</p>
<p>其中\（\ mathbf {w} = [w_1，w_2，…，w_d] \）是 features \（\ mathbf {x} =<br>[x_1，x_2，…，x_d] \）。 \（b \）是一个常数 通常被称为模型的偏见。等式由两部分组成 线性模型和逻辑函数：</p>
<p>线性模型：首先，我们可以看到\（\ mathbf {w} ^ T \ mathbf {x} + b = b +     w_1x_1 + … +<br>w_dx_d \）是输出为线性的线性模型     输入要素的函数\（\ mathbf {x} \）。偏见\（b \）是<br>人们可以预测，而不会观察任何特征。模型重量     \（w_i \）反映特征\（x_i \）如何与正相关     标签。如果\（x_i<br>\）与正向标签正相关，那么     重量\（w_i \）增加，概率\（P（Y = 1 | \ mathbf {x}）\）将<br>接近1.另一方面，如果\（x_i \）是负相关的     与正面的标签，那么体重\（w_i \）减少和     概率\（P（Y = 1 | \ mathbf<br>{x}）\）将接近于0。 逻辑函数：其次，我们可以看到有一个逻辑函数     （也称为S形函数）\（S（t）= 1 /（1+ \ exp（-t））\）是<br>应用于线性模型。逻辑功能是用来转换的     从任何实数的线性模型输出（\ mathbf {w} ^ T \ mathbf {x} + b \）<br>数字放到\（[0，1] \）的范围内，可以解释为a     可能性。</p>
<p>模型训练是一个优化问题：目标是找到一组模型 权重（即模型参数）最小化定义的损失函数 训练数据，如逻辑回归模型的逻辑损失。亏损<br>函数测量地面实况标签和模型之间的差异 预测。如果预测非常接近地面实况标签，那就是损失 价值会很低;如果预测离标签很远，那么就是亏损 价值会很高。</p>
<h2><span id="深入学习">深入学习</span></h2><p>如果你有兴趣了解更多，请查看我们的 广泛和深度学习教程，我们将告诉你如何 联合线性模型和深度神经网络的优势 使用tf.estimator API来训练它们。</p>


        <p style="margin-top:2em; text-align:left; font-weight:bold; font-style: italic;">未经作者同意，本文严禁转载，违者必究！</p>
	</div>
		<footer class="article-footer clearfix">
<div class="article-catetags">


  <div class="article-tags">
  
  <span></span> <a href="/tags/机器学习/">机器学习</a>
  </div>

</div>



	<div class="article-share" id="share">
	
	  <div data-url="https://www.tracholar.top/2018/01/01/wide/" data-title="TensorFlow线性模型教程 | 智子" data-tsina="" class="share clearfix">
	  </div>
	
	</div>


</footer>


	</article>
	
<nav class="article-nav clearfix">
 
 <div class="prev" >
 <a href="/2018/01/01/linear/" title="具有张量流的大规模线性模型">
  <strong>上一篇：</strong><br/>
  <span>
  具有张量流的大规模线性模型</span>
</a>
</div>


<div class="next">
<a href="/2018/01/01/graph_viz/"  title="TensorBoard：图形可视化">
 <strong>下一篇：</strong><br/> 
 <span>TensorBoard：图形可视化
</span>
</a>
</div>

</nav>

	



</div>

      <div class="openaside"><a class="navbutton" href="#" title="显示侧边栏"></a></div>

  <div id="toc" class="toc-aside">
  <strong class="toc-title">文章目录</strong>
 
 <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#undefined"><span class="toc-number">1.</span> <span class="toc-text">TensorFlow线性模型教程</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#undefined"><span class="toc-number">1.1.</span> <span class="toc-text">建立</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#undefined"><span class="toc-number">1.2.</span> <span class="toc-text">读取人口普查数据</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#undefined"><span class="toc-number">1.3.</span> <span class="toc-text">将数据转换为张量</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#undefined"><span class="toc-number">1.4.</span> <span class="toc-text">模型的选择和工程特性</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#undefined"><span class="toc-number">1.4.1.</span> <span class="toc-text">基本分类特征列</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#undefined"><span class="toc-number">1.4.2.</span> <span class="toc-text">基本连续功能列</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#undefined"><span class="toc-number">1.4.3.</span> <span class="toc-text">通过分解实现连续性特征的分类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#undefined"><span class="toc-number">1.4.4.</span> <span class="toc-text">用CrossedColumn交叉多列</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#undefined"><span class="toc-number">1.5.</span> <span class="toc-text">定义Logistic回归模型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#undefined"><span class="toc-number">1.6.</span> <span class="toc-text">培训和评估我们的模型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#undefined"><span class="toc-number">1.7.</span> <span class="toc-text">加入正则化来防止过度拟合</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#undefined"><span class="toc-number">1.8.</span> <span class="toc-text">逻辑回归如何工作</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#undefined"><span class="toc-number">1.9.</span> <span class="toc-text">深入学习</span></a></li></ol></li></ol>
 
  </div>

<div id="asidepart">
<div class="closeaside"><a class="closebutton" href="#" title="隐藏侧边栏"></a></div>
<aside class="clearfix">
<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<!-- side-bar-ad -->
<ins class="adsbygoogle"
     style="display:block; overflow:hidden;"
     data-ad-client="ca-pub-6300557868920774"
     data-ad-slot="2232545787"
     data-ad-format="auto"></ins>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>


  


  
<div class="tagslist">
	<p class="asidetitle">标签</p>
		<ul class="clearfix">
		
			
				<li><a href="/tags/javascript/" title="javascript">javascript<sup>207</sup></a></li>
			
		
			
				<li><a href="/tags/java/" title="java">java<sup>205</sup></a></li>
			
		
			
				<li><a href="/tags/html/" title="html">html<sup>203</sup></a></li>
			
		
			
				<li><a href="/tags/python/" title="python">python<sup>199</sup></a></li>
			
		
			
				<li><a href="/tags/bash/" title="bash">bash<sup>198</sup></a></li>
			
		
			
				<li><a href="/tags/php/" title="php">php<sup>197</sup></a></li>
			
		
			
				<li><a href="/tags/css/" title="css">css<sup>88</sup></a></li>
			
		
			
				<li><a href="/tags/shell/" title="shell">shell<sup>78</sup></a></li>
			
		
			
				<li><a href="/tags/jquery/" title="jquery">jquery<sup>61</sup></a></li>
			
		
			
				<li><a href="/tags/linux/" title="linux">linux<sup>57</sup></a></li>
			
		
			
				<li><a href="/tags/机器学习/" title="机器学习">机器学习<sup>41</sup></a></li>
			
		
			
				<li><a href="/tags/unix/" title="unix">unix<sup>30</sup></a></li>
			
		
			
				<li><a href="/tags/mysql/" title="mysql">mysql<sup>17</sup></a></li>
			
		
			
				<li><a href="/tags/html5/" title="html5">html5<sup>16</sup></a></li>
			
		
			
				<li><a href="/tags/xml/" title="xml">xml<sup>13</sup></a></li>
			
		
			
				<li><a href="/tags/http/" title="http">http<sup>10</sup></a></li>
			
		
			
				<li><a href="/tags/区块链/" title="区块链">区块链<sup>1</sup></a></li>
			
		
		</ul>
</div>


  <div class="linkslist">
  <p class="asidetitle">友情链接</p>
    <ul>
        
          <li>
            
            	<a href="https://tracholar.github.io" target="_blank" title="个人博客">个人博客</a>
            
          </li>
        
    </ul>
</div>

  <div class="rsspart">
	<a href="/atom.xml" target="_blank" title="rss">RSS 订阅</a>
</div>

</aside>
</div>

    </div>
    <footer><div id="footer" >
	
	
	<section class="info">
		<p> To be or not to be, that is a question. <br/>
			This is my blog,believe it or not.</p>
	</section>
	 
	<div class="social-font" class="clearfix">
		
		
		
		
		
		
		
		
		
		
	</div>
			
		

		<p class="copyright">
		版权所有 © 2018 本站文章未经同意，禁止转载！作者：
		
		<a href="/about" target="_blank" title="zhizi">zhizi</a>
		


		</p>
</div>
</footer>
    <script src="/js/jquery-2.0.3.min.js"></script>
<script src="/js/jquery.imagesloaded.min.js"></script>
<script src="/js/gallery.js"></script>
<script src="/js/jquery.qrcode-0.12.0.min.js"></script>

<script type="text/javascript">
$(document).ready(function(){ 
  $('.navbar').click(function(){
    $('header nav').toggleClass('shownav');
  });
  var myWidth = 0;
  function getSize(){
    if( typeof( window.innerWidth ) == 'number' ) {
      myWidth = window.innerWidth;
    } else if( document.documentElement && document.documentElement.clientWidth) {
      myWidth = document.documentElement.clientWidth;
    };
  };
  var m = $('#main'),
      a = $('#asidepart'),
      c = $('.closeaside'),
      o = $('.openaside');
  c.click(function(){
    a.addClass('fadeOut').css('display', 'none');
    o.css('display', 'block').addClass('fadeIn');
    m.addClass('moveMain');
  });
  o.click(function(){
    o.css('display', 'none').removeClass('beforeFadeIn');
    a.css('display', 'block').removeClass('fadeOut').addClass('fadeIn');      
    m.removeClass('moveMain');
  });
  $(window).scroll(function(){
    o.css("top",Math.max(80,260-$(this).scrollTop()));
  });
  
  $(window).resize(function(){
    getSize(); 
    if (myWidth >= 1024) {
      $('header nav').removeClass('shownav');
    }else{
      m.removeClass('moveMain');
      a.css('display', 'block').removeClass('fadeOut');
      o.css('display', 'none');
      
      $('#toc.toc-aside').css('display', 'none');
        
    }
  });
});
</script>

<script type="text/javascript">
$(document).ready(function(){ 
  var ai = $('.article-content>iframe'),
      ae = $('.article-content>embed'),
      t  = $('#toc'),
      ta = $('#toc.toc-aside'),
      o  = $('.openaside'),
      c  = $('.closeaside');
  if(ai.length>0){
    ai.wrap('<div class="video-container" />');
  };
  if(ae.length>0){
   ae.wrap('<div class="video-container" />');
  };
  c.click(function(){
    ta.css('display', 'block').addClass('fadeIn');
  });
  o.click(function(){
    ta.css('display', 'none');
  });
  $(window).scroll(function(){
    ta.css("top",Math.max(140,320-$(this).scrollTop()));
  });
});
</script>


<script type="text/javascript">
$(document).ready(function(){ 
  var $this = $('.share'),
      url = $this.attr('data-url'),
      encodedUrl = encodeURIComponent(url),
      title = $this.attr('data-title'),
      tsina = $this.attr('data-tsina'),
      description = $this.attr('description');
  var html = [
  '<div class="hoverqrcode clearfix"></div>',
  '<a class="overlay" id="qrcode"></a>',
  '<a href="https://www.facebook.com/sharer.php?u=' + encodedUrl + '" class="article-share-facebook" target="_blank" title="Facebook"></a>',
  '<a href="https://twitter.com/intent/tweet?url=' + encodedUrl + '" class="article-share-twitter" target="_blank" title="Twitter"></a>',
  '<a href="#qrcode" class="article-share-qrcode" title="微信"></a>',
  '<a href="http://widget.renren.com/dialog/share?resourceUrl=' + encodedUrl + '&srcUrl=' + encodedUrl + '&title=' + title +'" class="article-share-renren" target="_blank" title="人人"></a>',
  '<a href="http://service.weibo.com/share/share.php?title='+title+'&url='+encodedUrl +'&ralateUid='+ tsina +'&searchPic=true&style=number' +'" class="article-share-weibo" target="_blank" title="微博"></a>',
  '<span title="Share to"></span>'
  ].join('');
  $this.append(html);

  $('.hoverqrcode').hide();

  var myWidth = 0;
  function updatehoverqrcode(){
    if( typeof( window.innerWidth ) == 'number' ) {
      myWidth = window.innerWidth;
    } else if( document.documentElement && document.documentElement.clientWidth) {
      myWidth = document.documentElement.clientWidth;
    };
    var qrsize = myWidth > 1024 ? 200:100;
    var options = {render: 'image', size: qrsize, fill: '#2ca6cb', text: url, radius: 0.5, quiet: 1};
    var p = $('.article-share-qrcode').position();
    $('.hoverqrcode').empty().css('width', qrsize).css('height', qrsize)
                          .css('left', p.left-qrsize/2+20).css('top', p.top-qrsize-10)
                          .qrcode(options);
  };
  $(window).resize(function(){
    $('.hoverqrcode').hide();
  });
  $('.article-share-qrcode').click(function(){
    updatehoverqrcode();
    $('.hoverqrcode').toggle();
  });
  $('.article-share-qrcode').hover(function(){}, function(){
      $('.hoverqrcode').hide();
  });
});   
</script>











<link rel="stylesheet" href="/fancybox/jquery.fancybox.css" media="screen" type="text/css">
<script src="/fancybox/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
$(document).ready(function(){ 
  $('.article-content').each(function(i){
    $(this).find('img').each(function(){
      if ($(this).parent().hasClass('fancybox')) return;
      var alt = this.alt;
      if (alt) $(this).after('<span class="caption">' + alt + '</span>');
      $(this).wrap('<a href="' + this.src + '" title="' + alt + '" class="fancybox"></a>');
    });
    $(this).find('.fancybox').each(function(){
      $(this).attr('rel', 'article' + i);
    });
  });
  if($.fancybox){
    $('.fancybox').fancybox();
  }
}); 
</script>



<!-- Analytics Begin -->





<!-- Analytics End -->

<!-- Totop Begin -->

	<div id="totop">
	<a title="返回顶部"><img src="/img/scrollup.png"/></a>
	</div>
	<script src="/js/totop.js"></script>

<!-- Totop End -->

<!-- MathJax Begin -->
<!-- mathjax config similar to math.stackexchange -->

<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [ ['$','$'], ["\\(","\\)"] ],
      processEscapes: true
    }
  });
</script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
      tex2jax: {
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
      }
    });
</script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for(i=0; i < all.length; i += 1) {
            all[i].SourceElement().parentNode.className += ' has-jax';
        }
    });
</script>

<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>


<!-- MathJax End -->

<!-- Tiny_search Begin -->

<!-- Tiny_search End -->

  </body>
</html>
