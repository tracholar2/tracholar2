
 <!DOCTYPE HTML>
<html >
<head>
  <meta charset="UTF-8">
  
    <title>python metaclass | 智子</title>
    <meta name="viewport" content="width=device-width, initial-scale=1,user-scalable=no">
    
    <meta name="author" content="zhizi">
    

    
    <meta name="description" content="简介元类是一个类的类。就像一个类定义一个类的实例的行为一样，元类定义了一个类的行为。一个类是一个元类的一个实例。  在Python中，你可以为元类使用任意的可调参数，但更有用的方法实际上是将它自己变成一个实际的类。type是Python中常用的元类。type它本身就是一个类，而且是它自己的类型。你将无法在Python中重新创建像type一样的东西，但是Python会作弊。要在Python中创建自己">
<meta property="og:type" content="article">
<meta property="og:title" content="python metaclass">
<meta property="og:url" content="https://www.tracholar2.top/2018/01/12/python-metaclass/index.html">
<meta property="og:site_name" content="智子">
<meta property="og:description" content="简介元类是一个类的类。就像一个类定义一个类的实例的行为一样，元类定义了一个类的行为。一个类是一个元类的一个实例。  在Python中，你可以为元类使用任意的可调参数，但更有用的方法实际上是将它自己变成一个实际的类。type是Python中常用的元类。type它本身就是一个类，而且是它自己的类型。你将无法在Python中重新创建像type一样的东西，但是Python会作弊。要在Python中创建自己">
<meta property="og:image" content="https://i.stack.imgur.com/QQ0OK.png">
<meta property="og:updated_time" content="2018-01-12T14:59:34.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="python metaclass">
<meta name="twitter:description" content="简介元类是一个类的类。就像一个类定义一个类的实例的行为一样，元类定义了一个类的行为。一个类是一个元类的一个实例。  在Python中，你可以为元类使用任意的可调参数，但更有用的方法实际上是将它自己变成一个实际的类。type是Python中常用的元类。type它本身就是一个类，而且是它自己的类型。你将无法在Python中重新创建像type一样的东西，但是Python会作弊。要在Python中创建自己">
<meta name="twitter:image" content="https://i.stack.imgur.com/QQ0OK.png">

    
    <link rel="alternative" href="/atom.xml" title="智子" type="application/atom+xml">
    
    
    <link rel="icon" href="/img/favicon.ico">
    
    
    <link rel="apple-touch-icon" href="/img/jacman.jpg">
    <link rel="apple-touch-icon-precomposed" href="/img/jacman.jpg">
    
    <link rel="stylesheet" href="/css/style.css">
</head>

  <body>
    <header>
      
<div>
		
			<div id="textlogo">
				<h1 class="site-name"><a href="/" title="智子">智子</a></h1>
				<h2 class="blog-motto">智子之家</h2>
			</div>
			<div class="navbar"><a class="navbutton navmobile" href="#" title="Menu">
			</a></div>
			<nav class="animated">
				<ul>
					<ul>
					 
						<li><a href="/">Home</a></li>
					
						<li><a href="/archives">Archives</a></li>
					
						<li><a href="/about">About</a></li>
					
					<li>
 					
					<form class="search" action="//google.com/search" method="get" accept-charset="utf-8">
						<label>Search</label>
						<input type="search" id="search" name="q" autocomplete="off" maxlength="20" placeholder="Search" />
						<input type="hidden" name="q" value="site:www.tracholar2.top">
					</form>
					
					</li>
				</ul>
			</nav>			
</div>
    </header>
    <div id="container">
      <div id="main" class="post" itemscope itemprop="blogPost">
  
	<article itemprop="articleBody"> 
		<header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2018/01/12/python-metaclass/" title="python metaclass" itemprop="url">python metaclass</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="zhizi" target="_blank" itemprop="author">zhizi</a>
		
  <p class="article-time">
    <time datetime="2018-01-12T13:49:19.000Z" itemprop="datePublished"> Published 2018-01-12</time>
    
  </p>
</header>
	<div class="article-content">
		
		<div id="toc" class="toc-article">
			<strong class="toc-title">Contents</strong>
		
			<ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#undefined"><span class="toc-number">1.</span> <span class="toc-text">简介</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#undefined"><span class="toc-number">2.</span> <span class="toc-text">类作为对象</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#undefined"><span class="toc-number">3.</span> <span class="toc-text">动态创建类</span></a></li></ol>
		
		</div>
		
		<h2><span id="简介">简介</span></h2><p>元类是一个类的类。就像一个类定义一个类的实例的行为一样，元类定义了一个类的行为。一个类是一个元类的一个实例。</p>
<p><img src="https://i.stack.imgur.com/QQ0OK.png" alt="元类图"></p>
<p>在Python中，你可以为元类使用任意的可调参数，但更有用的方法实际上是将它自己变成一个实际的类。type是Python中常用的元类。type它本身就是一个类，而且是它自己的类型。你将无法在Python中重新创建像type一样的东西，但是Python会作弊。要在Python中创建自己的元类，你只要type的子类。</p>
<p>元类最常用作类工厂。就像通过调用类创建类的实例一样，Python通过调用元类来创建一个新类（当它执行’class’语句时）。结合常规<strong>init</strong>和<strong>new</strong>方法，元类因此允许你在创建一个类时做“额外的事情”，比如用一些注册表来注册新类，或者甚至用其他东西来完全替换类。</p>
<p>当class语句被执行时，Python首先class以正常的代码块的形式执行语句的主体。由此产生的命名空间（一个字典）保存待分类的属性。元类是通过查看将被类（元类继承的）的基类，要被类<strong>metaclass</strong>（如果有的话）或<strong>metaclass</strong>全局变量的属性来确定的。元类然后调用类的名称，基类和属性来实例化它。</p>
<p>然而，元类实际上定义了一个类的类型，而不仅仅是一个工厂，所以你可以做更多的事情。例如，您可以在元类上定义常规方法。这些元类方法就像类方法，因为它们可以在没有实例的情况下在类上调用，但是它们也不像类方法，因为它们不能在类的实例上调用。type.<strong>subclasses</strong>()是type元类的一个方法的一个例子。您还可以定义正常的“魔力”的方法，如<strong>add</strong>，<strong>iter</strong>和<strong>getattr</strong>，执行或更改类的行为。</p>
<p>以下是一些小部分的汇总示例：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">make_hook</span><span class="params">(f)</span>:</span></span><br><span class="line">    <span class="string">"""Decorator to turn 'foo' method into '__foo__'"""</span></span><br><span class="line">    f.is_hook = <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> f</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyType</span><span class="params">(type)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__new__</span><span class="params">(cls, name, bases, attrs)</span>:</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> name.startswith(<span class="string">'None'</span>):</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">None</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># Go over attributes and see if they should be renamed.</span></span><br><span class="line">        newattrs = &#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> attrname, attrvalue <span class="keyword">in</span> attrs.iteritems():</span><br><span class="line">            <span class="keyword">if</span> getattr(attrvalue, <span class="string">'is_hook'</span>, <span class="number">0</span>):</span><br><span class="line">                newattrs[<span class="string">'__%s__'</span> % attrname] = attrvalue</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                newattrs[attrname] = attrvalue</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> super(MyType, cls).__new__(cls, name, bases, newattrs)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name, bases, attrs)</span>:</span></span><br><span class="line">        super(MyType, self).__init__(name, bases, attrs)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># classregistry.register(self, self.interfaces)</span></span><br><span class="line">        <span class="keyword">print</span> <span class="string">"Would register class %s now."</span> % self</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__add__</span><span class="params">(self, other)</span>:</span></span><br><span class="line">        <span class="class"><span class="keyword">class</span> <span class="title">AutoClass</span><span class="params">(self, other)</span>:</span></span><br><span class="line">            <span class="keyword">pass</span></span><br><span class="line">        <span class="keyword">return</span> AutoClass</span><br><span class="line">        <span class="comment"># Alternatively, to autogenerate the classname as well as the class:</span></span><br><span class="line">        <span class="comment"># return type(self.__name__ + other.__name__, (self, other), &#123;&#125;)</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">unregister</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="comment"># classregistry.unregister(self)</span></span><br><span class="line">        <span class="keyword">print</span> <span class="string">"Would unregister class %s now."</span> % self</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyObject</span>:</span></span><br><span class="line">    __metaclass__ = MyType</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NoneSample</span><span class="params">(MyObject)</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Will print "NoneType None"</span></span><br><span class="line"><span class="keyword">print</span> type(NoneSample), repr(NoneSample)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Example</span><span class="params">(MyObject)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, value)</span>:</span></span><br><span class="line">        self.value = value</span><br><span class="line"><span class="meta">    @make_hook</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">add</span><span class="params">(self, other)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.__class__(self.value + other.value)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Will unregister the class</span></span><br><span class="line">Example.unregister()</span><br><span class="line"></span><br><span class="line">inst = Example(<span class="number">10</span>)</span><br><span class="line"><span class="comment"># Will fail with an AttributeError</span></span><br><span class="line"><span class="comment">#inst.unregister()</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> inst + inst</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Sibling</span><span class="params">(MyObject)</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">ExampleSibling = Example + Sibling</span><br><span class="line"><span class="comment"># ExampleSibling is now a subclass of both Example and Sibling (with no</span></span><br><span class="line"><span class="comment"># content of its own) although it will believe it's called 'AutoClass'</span></span><br><span class="line"><span class="keyword">print</span> ExampleSibling</span><br><span class="line"><span class="keyword">print</span> ExampleSibling.__mro__</span><br></pre></td></tr></table></figure>
<h2><span id="类作为对象">类作为对象</span></h2><p>在理解元类之前，你需要掌握Python中的类。而且Python从Smalltalk语言中借用了一个非常奇怪的概念。</p>
<p>在大多数语言中，类只是描述如何生成对象的代码段。在Python中也是如此：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">ObjectCreator</span><span class="params">(object)</span>:</span></span><br><span class="line"><span class="meta">... </span>      <span class="keyword">pass</span></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>my_object = ObjectCreator()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(my_object)</span><br><span class="line">&lt;__main__.ObjectCreator object at <span class="number">0x8974f2c</span>&gt;</span><br></pre></td></tr></table></figure>
<p>但是类不仅仅是Python。类也是对象。</p>
<p>只要你使用关键字class，Python就执行它并创建一个OBJECT。指令</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">ObjectCreator</span><span class="params">(object)</span>:</span></span><br><span class="line"><span class="meta">... </span>      <span class="keyword">pass</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>在内存中创建名为“ObjectCreator”的对象。</p>
<p>这个对象（类）本身能够创建对象（实例），这就是为什么它是一个类。</p>
<p>但是，这仍然是一个客体，因此：</p>
<p>你可以把它分配给一个变量<br>你可以复制它<br>你可以添加属性<br>您可以将其作为函数参数传递<br>例如：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(ObjectCreator) <span class="comment"># you can print a class because it's an object</span></span><br><span class="line">&lt;<span class="class"><span class="keyword">class</span> '<span class="title">__main__</span>.<span class="title">ObjectCreator</span>'&gt;</span></span><br><span class="line"><span class="class">&gt;&gt;&gt; <span class="title">def</span> <span class="title">echo</span><span class="params">(o)</span>:</span></span><br><span class="line"><span class="meta">... </span>      print(o)</span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>echo(ObjectCreator) <span class="comment"># you can pass a class as a parameter</span></span><br><span class="line">&lt;<span class="class"><span class="keyword">class</span> '<span class="title">__main__</span>.<span class="title">ObjectCreator</span>'&gt;</span></span><br><span class="line"><span class="class">&gt;&gt;&gt; <span class="title">print</span><span class="params">(hasattr<span class="params">(ObjectCreator, <span class="string">'new_attribute'</span>)</span>)</span></span></span><br><span class="line"><span class="class"><span class="title">False</span></span></span><br><span class="line">&gt;&gt;&gt; ObjectCreator.new_attribute = 'foo' # you can add attributes to a class</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(hasattr(ObjectCreator, <span class="string">'new_attribute'</span>))</span><br><span class="line"><span class="keyword">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(ObjectCreator.new_attribute)</span><br><span class="line">foo</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>ObjectCreatorMirror = ObjectCreator <span class="comment"># you can assign a class to a variable</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(ObjectCreatorMirror.new_attribute)</span><br><span class="line">foo</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(ObjectCreatorMirror())</span><br><span class="line">&lt;__main__.ObjectCreator object at <span class="number">0x8997b4c</span>&gt;</span><br></pre></td></tr></table></figure>
<h2><span id="动态创建类">动态创建类</span></h2><p>由于类是对象，因此可以像任何对象一样快速创建它们。</p>
<p>首先，您可以使用class以下方法在函数中创建一个类：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">choose_class</span><span class="params">(name)</span>:</span></span><br><span class="line"><span class="meta">... </span>    <span class="keyword">if</span> name == <span class="string">'foo'</span>:</span><br><span class="line"><span class="meta">... </span>        <span class="class"><span class="keyword">class</span> <span class="title">Foo</span><span class="params">(object)</span>:</span></span><br><span class="line"><span class="meta">... </span>            <span class="keyword">pass</span></span><br><span class="line"><span class="meta">... </span>        <span class="keyword">return</span> Foo <span class="comment"># return the class, not an instance</span></span><br><span class="line"><span class="meta">... </span>    <span class="keyword">else</span>:</span><br><span class="line"><span class="meta">... </span>        <span class="class"><span class="keyword">class</span> <span class="title">Bar</span><span class="params">(object)</span>:</span></span><br><span class="line"><span class="meta">... </span>            <span class="keyword">pass</span></span><br><span class="line"><span class="meta">... </span>        <span class="keyword">return</span> Bar</span><br><span class="line"><span class="meta">... </span>    </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>MyClass = choose_class(<span class="string">'foo'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(MyClass) <span class="comment"># the function returns a class, not an instance</span></span><br><span class="line">&lt;<span class="class"><span class="keyword">class</span> '<span class="title">__main__</span>.<span class="title">Foo</span>'&gt;</span></span><br><span class="line"><span class="class">&gt;&gt;&gt; <span class="title">print</span><span class="params">(MyClass<span class="params">()</span>)</span> # <span class="title">you</span> <span class="title">can</span> <span class="title">create</span> <span class="title">an</span> <span class="title">object</span> <span class="title">from</span> <span class="title">this</span> <span class="title">class</span></span></span><br><span class="line"><span class="class">&lt;<span class="title">__main__</span>.<span class="title">Foo</span> <span class="title">object</span> <span class="title">at</span> 0<span class="title">x89c6d4c</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>但是它不是那么有活力，因为你还得自己写全班。</p>
<p>由于类是对象，它们必须由某种东西产生。</p>
<p>当你使用class关键字时，Python会自动创建这个对象。但是与Python中的大多数事情一样，它给了你一个手动的方法。</p>
<p>记得功能type？良好的旧功能，让你知道什么类型的对象是：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(type(<span class="number">1</span>))</span><br><span class="line">&lt;type <span class="string">'int'</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(type(<span class="string">"1"</span>))</span><br><span class="line">&lt;type <span class="string">'str'</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(type(ObjectCreator))</span><br><span class="line">&lt;type <span class="string">'type'</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(type(ObjectCreator()))</span><br><span class="line">&lt;<span class="class"><span class="keyword">class</span> '<span class="title">__main__</span>.<span class="title">ObjectCreator</span>'&gt;</span></span><br></pre></td></tr></table></figure>
<p>那么，type有一个完全不同的能力，它也可以在飞行中创建类。type可以把一个类的描述作为参数，并返回一个类。</p>
<p>（我知道，根据你传递给它的参数，相同的函数可能有两种完全不同的用法，这很愚蠢，这是由于Python中的向后兼容性问题）</p>
<p>type 这样工作：</p>
<p>type(name of the class,<br>     tuple of the parent class (for inheritance, can be empty),<br>     dictionary containing attributes names and values)<br>例如：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">MyShinyClass</span><span class="params">(object)</span>:</span></span><br><span class="line"><span class="meta">... </span>      <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>
<p>可以这样手动创建：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>MyShinyClass = type(<span class="string">'MyShinyClass'</span>, (), &#123;&#125;) <span class="comment"># returns a class object</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(MyShinyClass)</span><br><span class="line">&lt;<span class="class"><span class="keyword">class</span> '<span class="title">__main__</span>.<span class="title">MyShinyClass</span>'&gt;</span></span><br><span class="line"><span class="class">&gt;&gt;&gt; <span class="title">print</span><span class="params">(MyShinyClass<span class="params">()</span>)</span> # <span class="title">create</span> <span class="title">an</span> <span class="title">instance</span> <span class="title">with</span> <span class="title">the</span> <span class="title">class</span></span></span><br><span class="line"><span class="class">&lt;<span class="title">__main__</span>.<span class="title">MyShinyClass</span> <span class="title">object</span> <span class="title">at</span> 0<span class="title">x8997cec</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>你会注意到我们使用“MyShinyClass”作为类的名字，并作为变量来保存类的引用。他们可以是不同的，但没有理由使事情复杂化。</p>
<p>type接受一个字典来定义类的属性。所以：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">Foo</span><span class="params">(object)</span>:</span></span><br><span class="line"><span class="meta">... </span>      bar = <span class="keyword">True</span></span><br></pre></td></tr></table></figure>
<p>可以翻译成：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>Foo = type(<span class="string">'Foo'</span>, (), &#123;<span class="string">'bar'</span>:<span class="keyword">True</span>&#125;)</span><br></pre></td></tr></table></figure>
<p>并作为一个普通的类使用：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(Foo)</span><br><span class="line">&lt;<span class="class"><span class="keyword">class</span> '<span class="title">__main__</span>.<span class="title">Foo</span>'&gt;</span></span><br><span class="line"><span class="class">&gt;&gt;&gt; <span class="title">print</span><span class="params">(Foo.bar)</span></span></span><br><span class="line"><span class="class"><span class="title">True</span></span></span><br><span class="line">&gt;&gt;&gt; f = Foo()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(f)</span><br><span class="line">&lt;__main__.Foo object at <span class="number">0x8a9b84c</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(f.bar)</span><br><span class="line"><span class="keyword">True</span></span><br></pre></td></tr></table></figure>
<p>当然，你可以继承它，所以：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>  <span class="class"><span class="keyword">class</span> <span class="title">FooChild</span><span class="params">(Foo)</span>:</span></span><br><span class="line"><span class="meta">... </span>        <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>
<p>将会：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>FooChild = type(<span class="string">'FooChild'</span>, (Foo,), &#123;&#125;)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(FooChild)</span><br><span class="line">&lt;<span class="class"><span class="keyword">class</span> '<span class="title">__main__</span>.<span class="title">FooChild</span>'&gt;</span></span><br><span class="line"><span class="class">&gt;&gt;&gt; <span class="title">print</span><span class="params">(FooChild.bar)</span> # <span class="title">bar</span> <span class="title">is</span> <span class="title">inherited</span> <span class="title">from</span> <span class="title">Foo</span></span></span><br><span class="line"><span class="class"><span class="title">True</span></span></span><br></pre></td></tr></table></figure>
<p>最终你会想要添加方法到你的类。只需定义一个具有适当签名的函数，并将其分配为一个属性即可。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">echo_bar</span><span class="params">(self)</span>:</span></span><br><span class="line"><span class="meta">... </span>      print(self.bar)</span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>FooChild = type(<span class="string">'FooChild'</span>, (Foo,), &#123;<span class="string">'echo_bar'</span>: echo_bar&#125;)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>hasattr(Foo, <span class="string">'echo_bar'</span>)</span><br><span class="line"><span class="keyword">False</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>hasattr(FooChild, <span class="string">'echo_bar'</span>)</span><br><span class="line"><span class="keyword">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>my_foo = FooChild()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>my_foo.echo_bar()</span><br><span class="line"><span class="keyword">True</span></span><br></pre></td></tr></table></figure>
<p>在动态创建类之后，您可以添加更多的方法，就像向正常创建的类对象中添加方法一样。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">echo_bar_more</span><span class="params">(self)</span>:</span></span><br><span class="line"><span class="meta">... </span>      print(<span class="string">'yet another method'</span>)</span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>FooChild.echo_bar_more = echo_bar_more</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>hasattr(FooChild, <span class="string">'echo_bar_more'</span>)</span><br><span class="line"><span class="keyword">True</span></span><br></pre></td></tr></table></figure>
<p>您将看到我们要去的地方：在Python中，类是对象，您可以动态地创建一个类。</p>
<p>这就是Python在使用关键字class时所做的事情，而且它是通过使用元类来实现的。</p>
<p>什么是元类（最后）<br>元类是创建类的“东西”。</p>
<p>你定义类来创建对象，对吧？</p>
<p>但是我们知道Python类是对象。</p>
<p>那么，元类是创建这些对象。他们是类，你可以这样描绘他们：</p>
<p>MyClass = MetaClass()<br>MyObject = MyClass()<br>你已经看到，type让你做这样的事情：</p>
<p>MyClass = type(‘MyClass’, (), {})<br>这是因为这个函数type实际上是一个元类。type是Python用来在幕后创建所有类的元类。</p>
<p>现在你想知道为什么它是用小写字母写的，而不是Type？</p>
<p>那么，我想这是一个与str创建字符串对象int的类以及创建整型对象的类保持一致的问题。type只是创建类对象的类。</p>
<p>你通过检查<strong>class</strong>属性来看到。</p>
<p>一切，我的意思是一切，都是Python中的一个对象。包括整数，字符串，函数和类。所有这些都是对象。所有这些都是从一个类创建的：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>age = <span class="number">35</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>age.__class__</span><br><span class="line">&lt;type <span class="string">'int'</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>name = <span class="string">'bob'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>name.__class__</span><br><span class="line">&lt;type <span class="string">'str'</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">foo</span><span class="params">()</span>:</span> <span class="keyword">pass</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>foo.__class__</span><br><span class="line">&lt;type <span class="string">'function'</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">Bar</span><span class="params">(object)</span>:</span> <span class="keyword">pass</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b = Bar()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b.__class__</span><br><span class="line">&lt;<span class="class"><span class="keyword">class</span> '<span class="title">__main__</span>.<span class="title">Bar</span>'&gt;</span></span><br></pre></td></tr></table></figure>
<p>现在，这是<strong>class</strong>什么<strong>class</strong>？</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>age.__class__.__class__</span><br><span class="line">&lt;type <span class="string">'type'</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>name.__class__.__class__</span><br><span class="line">&lt;type <span class="string">'type'</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>foo.__class__.__class__</span><br><span class="line">&lt;type <span class="string">'type'</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b.__class__.__class__</span><br><span class="line">&lt;type <span class="string">'type'</span>&gt;</span><br></pre></td></tr></table></figure>
<p>所以，元类就是创建类对象的东西。</p>
<p>如果你愿意，你可以称之为“类工厂”。</p>
<p>type 是Python使用的内置元类，但是当然，您可以创建自己的元类。</p>
<p>该<strong>metaclass</strong>属性<br><strong>metaclass</strong>当你写一个类时，你可以添加一个属性：</p>
<p>class Foo(object):<br>  <strong>metaclass</strong> = something…<br>  […]<br>如果这样做，Python将使用元类来创建类Foo。</p>
<p>小心，这很棘手。</p>
<p>你class Foo(object)先写，但是类对象Foo不是在内存中创建的。</p>
<p>Python将<strong>metaclass</strong>在类定义中寻找。如果找到它，它将使用它来创建对象类Foo。如果没有，它将  type用来创建类。</p>
<p>多读几遍。</p>
<p>当你这样做时：</p>
<p>class Foo(Bar):<br>  pass<br>Python执行以下操作：</p>
<p>有一个<strong>metaclass</strong>属性Foo？</p>
<p>如果是的话，在内存中创建一个类对象（我说的是类对象，留在我这里），名称Foo使用是什么<strong>metaclass</strong>。</p>
<p>如果Python找不到<strong>metaclass</strong>，它将<strong>metaclass</strong>在MODULE级别寻找一个，并尝试做同样的事情（但只适用于不继承任何东西的类，基本上是旧式的类）。</p>
<p>如果找不到任何东西<strong>metaclass</strong>，它将使用Bar自己的元类（可能是默认值type）来创建类对象。</p>
<p>在这里要小心，该<strong>metaclass</strong>属性不会被继承，父类（Bar.<strong>class</strong>）的元类将是。如果Bar使用的<strong>metaclass</strong>是创建的属性Bar与type()（不是type.<strong>new</strong>()），子类不会继承该行为。</p>
<p>现在最大的问题是，你能放<strong>metaclass</strong>什么？</p>
<p>答案是：可以创建一个类的东西。</p>
<p>什么可以创建一个类？type，或任何子类或使用它。</p>
<p>自定义元类<br>元类的主要目的是在创建时自动更改类。</p>
<p>您通常对API进行此操作，您需要创建与当前上下文相匹配的类。</p>
<p>想象一个愚蠢的例子，你决定你的模块中的所有类都应该用大写字母来写属性。有几种方法可以做到这一点，但一种方法是<strong>metaclass</strong>在模块级别设置。</p>
<p>这样，这个模块的所有类都将使用这个元类来创建，我们只需要告诉元类将所有的属性都改为大写。</p>
<p>幸运的是，<code>__metaclass__</code>实际上可以是任何可调用的，它不需要是一个正式的类（我知道，名称中的’class’不需要成为一个类，但是这是有用的）。</p>
<p>所以我们将从一个简单的例子开始，使用一个函数。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># the metaclass will automatically get passed the same argument</span></span><br><span class="line"><span class="comment"># that you usually pass to `type`</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">upper_attr</span><span class="params">(future_class_name, future_class_parents, future_class_attr)</span>:</span></span><br><span class="line">  <span class="string">"""</span></span><br><span class="line"><span class="string">    Return a class object, with the list of its attribute turned</span></span><br><span class="line"><span class="string">    into uppercase.</span></span><br><span class="line"><span class="string">  """</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># pick up any attribute that doesn't start with '__' and uppercase it</span></span><br><span class="line">  uppercase_attr = &#123;&#125;</span><br><span class="line">  <span class="keyword">for</span> name, val <span class="keyword">in</span> future_class_attr.items():</span><br><span class="line">      <span class="keyword">if</span> <span class="keyword">not</span> name.startswith(<span class="string">'__'</span>):</span><br><span class="line">          uppercase_attr[name.upper()] = val</span><br><span class="line">      <span class="keyword">else</span>:</span><br><span class="line">          uppercase_attr[name] = val</span><br><span class="line"></span><br><span class="line">  <span class="comment"># let `type` do the class creation</span></span><br><span class="line">  <span class="keyword">return</span> type(future_class_name, future_class_parents, uppercase_attr)</span><br><span class="line"></span><br><span class="line">__metaclass__ = upper_attr <span class="comment"># this will affect all classes in the module</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span><span class="params">()</span>:</span> <span class="comment"># global __metaclass__ won't work with "object" though</span></span><br><span class="line">  <span class="comment"># but we can define __metaclass__ here instead to affect only this class</span></span><br><span class="line">  <span class="comment"># and this will work with "object" children</span></span><br><span class="line">  bar = <span class="string">'bip'</span></span><br><span class="line"></span><br><span class="line">print(hasattr(Foo, <span class="string">'bar'</span>))</span><br><span class="line"><span class="comment"># Out: False</span></span><br><span class="line">print(hasattr(Foo, <span class="string">'BAR'</span>))</span><br><span class="line"><span class="comment"># Out: True</span></span><br><span class="line"></span><br><span class="line">f = Foo()</span><br><span class="line">print(f.BAR)</span><br><span class="line"><span class="comment"># Out: 'bip'</span></span><br><span class="line">现在，让我们做同样的事情，但使用一个真正的类为一个元类：</span><br><span class="line"></span><br><span class="line"><span class="comment"># remember that `type` is actually a class like `str` and `int`</span></span><br><span class="line"><span class="comment"># so you can inherit from it</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UpperAttrMetaclass</span><span class="params">(type)</span>:</span></span><br><span class="line">    <span class="comment"># __new__ is the method called before __init__</span></span><br><span class="line">    <span class="comment"># it's the method that creates the object and returns it</span></span><br><span class="line">    <span class="comment"># while __init__ just initializes the object passed as parameter</span></span><br><span class="line">    <span class="comment"># you rarely use __new__, except when you want to control how the object</span></span><br><span class="line">    <span class="comment"># is created.</span></span><br><span class="line">    <span class="comment"># here the created object is the class, and we want to customize it</span></span><br><span class="line">    <span class="comment"># so we override __new__</span></span><br><span class="line">    <span class="comment"># you can do some stuff in __init__ too if you wish</span></span><br><span class="line">    <span class="comment"># some advanced use involves overriding __call__ as well, but we won't</span></span><br><span class="line">    <span class="comment"># see this</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__new__</span><span class="params">(upperattr_metaclass, future_class_name,</span></span></span><br><span class="line"><span class="function"><span class="params">                future_class_parents, future_class_attr)</span>:</span></span><br><span class="line"></span><br><span class="line">        uppercase_attr = &#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> name, val <span class="keyword">in</span> future_class_attr.items():</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> name.startswith(<span class="string">'__'</span>):</span><br><span class="line">                uppercase_attr[name.upper()] = val</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                uppercase_attr[name] = val</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> type(future_class_name, future_class_parents, uppercase_attr)</span><br></pre></td></tr></table></figure>
<p>但是这不是真的OOP。我们type直接调用，我们不会覆盖或调用父母<strong>new</strong>。我们开始做吧：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UpperAttrMetaclass</span><span class="params">(type)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__new__</span><span class="params">(upperattr_metaclass, future_class_name,</span></span></span><br><span class="line"><span class="function"><span class="params">                future_class_parents, future_class_attr)</span>:</span></span><br><span class="line"></span><br><span class="line">        uppercase_attr = &#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> name, val <span class="keyword">in</span> future_class_attr.items():</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> name.startswith(<span class="string">'__'</span>):</span><br><span class="line">                uppercase_attr[name.upper()] = val</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                uppercase_attr[name] = val</span><br><span class="line"></span><br><span class="line">        <span class="comment"># reuse the type.__new__ method</span></span><br><span class="line">        <span class="comment"># this is basic OOP, nothing magic in there</span></span><br><span class="line">        <span class="keyword">return</span> type.__new__(upperattr_metaclass, future_class_name,</span><br><span class="line">                            future_class_parents, uppercase_attr)</span><br></pre></td></tr></table></figure>
<p>你可能已经注意到了额外的争论upperattr_metaclass。没有什么特别之处：<code>__new__</code>总是接收它定义的类作为第一个参数。就像你有self普通方法接收实例作为第一个参数，或类方法的定义类一样。</p>
<p>当然，为了清楚起见，我在这里使用的名字是很长的，但是self所有的论点都有传统的名字。所以一个真正的生产元类将如下所示：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UpperAttrMetaclass</span><span class="params">(type)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__new__</span><span class="params">(cls, clsname, bases, dct)</span>:</span></span><br><span class="line"></span><br><span class="line">        uppercase_attr = &#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> name, val <span class="keyword">in</span> dct.items():</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> name.startswith(<span class="string">'__'</span>):</span><br><span class="line">                uppercase_attr[name.upper()] = val</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                uppercase_attr[name] = val</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> type.__new__(cls, clsname, bases, uppercase_attr)</span><br></pre></td></tr></table></figure>
<p>我们可以通过使用它来更简洁super，这将减轻继承（因为是的，你可以有元继承，继承自类继承的元类）：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UpperAttrMetaclass</span><span class="params">(type)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__new__</span><span class="params">(cls, clsname, bases, dct)</span>:</span></span><br><span class="line"></span><br><span class="line">        uppercase_attr = &#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> name, val <span class="keyword">in</span> dct.items():</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> name.startswith(<span class="string">'__'</span>):</span><br><span class="line">                uppercase_attr[name.upper()] = val</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                uppercase_attr[name] = val</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> super(UpperAttrMetaclass, cls).__new__(cls, clsname, bases, uppercase_attr)</span><br></pre></td></tr></table></figure>
<p>而已。关于元类没有什么更多。</p>
<p>使用元类代码的复杂性背后的原因不是因为元类，这是因为你通常使用元类来依靠内省来做扭曲的东西，操纵继承，变量<strong>dict</strong>等等。</p>
<p>事实上，元类对于做黑魔法特别有用，因此也是复杂的东西。但是它们本身就很简单：</p>
<p>拦截一个类的创建<br>修改类<br>返回修改的类<br>为什么你会使用元类而不是函数？<br>既然<strong>metaclass</strong>可以接受任何可调用，为什么你会使用一个类，因为它显然更复杂？</p>
<p>这样做有几个原因：</p>
<p>意图很清楚。当你阅读时UpperAttrMetaclass(type)，你会知道接下来会发生什么<br>你可以使用OOP。元类可以从元类继承，重写父类的方法。元类甚至可以使用元类。<br>如果你指定了一个元类，而不是一个元类函数，那么类的子类将是它的元类的实例。<br>你可以更好地构建你的代码。你从来没有像上面的例子那样使用元类。这通常是复杂的。有能力创建几个方法并将它们分组在一个类中，这对于使代码更易于阅读非常有用。<br>你可以钩子<code>__new__</code>，<code>__init__</code>和<code>__call__</code>。这将允许你做不同的东西。即使通常你可以做到这一点<strong>new</strong>，有些人更舒适的使用<strong>init</strong>。<br>这些被称为元类，该死的！这意味着什么！<br>你为什么要使用元类？<br>现在是个大问题。为什么你会使用一些模糊的错误倾向功能？</p>
<p>那么，通常你不会：</p>
<p>元类是更深的魔法，99％的用户不应该担心。如果你想知道你是否需要他们，你不需要（那些真正需要他们的人肯定知道他们需要他们，不需要解释为什么）。</p>
<p>Python大师蒂姆·彼得斯</p>
<p>元类的主要用例是创建一个API。一个典型的例子是Django的ORM。</p>
<p>它允许你定义这样的东西：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span><span class="params">(models.Model)</span>:</span></span><br><span class="line">  name = models.CharField(max_length=<span class="number">30</span>)</span><br><span class="line">  age = models.IntegerField()</span><br></pre></td></tr></table></figure>
<p>但是，如果你这样做：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">guy = Person(name=<span class="string">'bob'</span>, age=<span class="string">'35'</span>)</span><br><span class="line">print(guy.age)</span><br></pre></td></tr></table></figure>
<p>它不会返回一个IntegerField对象。它会返回一个int，甚至可以直接从数据库中获取。</p>
<p>这是可能的，因为models.Model定义<strong>metaclass</strong>和它使用了一些魔法，将Person您刚刚定义的简单语句变成一个复杂的钩子到数据库字段。</p>
<p>Django通过暴露一个简单的API并使用元类来创建一些复杂的外观，从这个API重新创建代码，在幕后做真正的工作。</p>
<p>最后一个字<br>首先，您知道类是可以创建实例的对象。</p>
<p>实际上，类本身就是实例。元类</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">Foo</span><span class="params">(object)</span>:</span> <span class="keyword">pass</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>id(Foo)</span><br><span class="line"><span class="number">142630324</span></span><br></pre></td></tr></table></figure>
<p>一切都是Python中的对象，它们都是类的实例或元类的实例。</p>
<p>除了type。</p>
<p>type实际上是它自己的元类。这不是在纯Python中可以重现的东西，而是通过在实现级别上作弊。</p>
<p>其次，元类是复杂的。你可能不想用它们来进行非常简单的课堂改动。你可以通过使用两种不同的技术来改变类：</p>
<p>猴子补丁<br>类装饰器<br>99％的时间你需要改变类，你最好使用这些。</p>
<p>但98％的时间，你根本不需要改变类。</p>
  
	</div>
		<footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/python/">python</a>
</div>


</div>



	<div class="article-share" id="share">
	
	  <div data-url="https://www.tracholar2.top/2018/01/12/python-metaclass/" data-title="python metaclass | 智子" data-tsina="" class="share clearfix">
	  </div>
	
	</div>


</footer>

   	       
	</article>
	
<nav class="article-nav clearfix">
 
 <div class="prev" >
 <a href="/2018/01/12/spark-tutorial/" title="spark 官方教程">
  <strong>上一篇：</strong><br/>
  <span>
  spark 官方教程</span>
</a>
</div>


<div class="next">
<a href="/2018/01/12/python-yield/"  title="python yield 关键字">
 <strong>下一篇：</strong><br/> 
 <span>python yield 关键字
</span>
</a>
</div>

</nav>

	



</div>  
      <div class="openaside"><a class="navbutton" href="#" title="Show Sidebar"></a></div>

  <div id="toc" class="toc-aside">
  <strong class="toc-title">Contents</strong>
 
 <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#undefined"><span class="toc-number">1.</span> <span class="toc-text">简介</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#undefined"><span class="toc-number">2.</span> <span class="toc-text">类作为对象</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#undefined"><span class="toc-number">3.</span> <span class="toc-text">动态创建类</span></a></li></ol>
 
  </div>

<div id="asidepart">
<div class="closeaside"><a class="closebutton" href="#" title="Hide Sidebar"></a></div>
<aside class="clearfix">

  


  
<div class="categorieslist">
	<p class="asidetitle">Categories</p>
		<ul>
		
		  
			<li><a href="/categories/python/" title="python">python<sup>2</sup></a></li>
		  
		
		  
			<li><a href="/categories/spark/" title="spark">spark<sup>2</sup></a></li>
		  
		
		</ul>
</div>


  
<div class="tagslist">
	<p class="asidetitle">Tags</p>
		<ul class="clearfix">
		
			
				<li><a href="/tags/python/" title="python">python<sup>1</sup></a></li>
			
		
		</ul>
</div>


  <div class="linkslist">
  <p class="asidetitle">Links</p>
    <ul>
        
          <li>
            
            	<a href="https://tracholar.github.io" target="_blank" title="个人博客">个人博客</a>
            
          </li>
        
    </ul>
</div>

  <div class="rsspart">
	<a href="/atom.xml" target="_blank" title="rss">RSS</a>
</div>

</aside>
</div>
    </div>
    <footer><div id="footer" >
	
	
	<section class="info">
		<p> To be or not to be, that is a question. <br/>
			This is my blog,believe it or not.</p>
	</section>
	 
	<div class="social-font" class="clearfix">
		
		
		
		
		
		
		
		
		
		
	</div>
			
		

		<p class="copyright">
		Powered by <a href="http://hexo.io" target="_blank" title="hexo">hexo</a> and Theme by <a href="https://github.com/wuchong/jacman" target="_blank" title="Jacman">Jacman</a> © 2018 
		
		<a href="/about" target="_blank" title="zhizi">zhizi</a>
		
		
		</p>
</div>
</footer>
    <script src="/js/jquery-2.0.3.min.js"></script>
<script src="/js/jquery.imagesloaded.min.js"></script>
<script src="/js/gallery.js"></script>
<script src="/js/jquery.qrcode-0.12.0.min.js"></script>

<script type="text/javascript">
$(document).ready(function(){ 
  $('.navbar').click(function(){
    $('header nav').toggleClass('shownav');
  });
  var myWidth = 0;
  function getSize(){
    if( typeof( window.innerWidth ) == 'number' ) {
      myWidth = window.innerWidth;
    } else if( document.documentElement && document.documentElement.clientWidth) {
      myWidth = document.documentElement.clientWidth;
    };
  };
  var m = $('#main'),
      a = $('#asidepart'),
      c = $('.closeaside'),
      o = $('.openaside');
  c.click(function(){
    a.addClass('fadeOut').css('display', 'none');
    o.css('display', 'block').addClass('fadeIn');
    m.addClass('moveMain');
  });
  o.click(function(){
    o.css('display', 'none').removeClass('beforeFadeIn');
    a.css('display', 'block').removeClass('fadeOut').addClass('fadeIn');      
    m.removeClass('moveMain');
  });
  $(window).scroll(function(){
    o.css("top",Math.max(80,260-$(this).scrollTop()));
  });
  
  $(window).resize(function(){
    getSize(); 
    if (myWidth >= 1024) {
      $('header nav').removeClass('shownav');
    }else{
      m.removeClass('moveMain');
      a.css('display', 'block').removeClass('fadeOut');
      o.css('display', 'none');
      
      $('#toc.toc-aside').css('display', 'none');
        
    }
  });
});
</script>

<script type="text/javascript">
$(document).ready(function(){ 
  var ai = $('.article-content>iframe'),
      ae = $('.article-content>embed'),
      t  = $('#toc'),
      ta = $('#toc.toc-aside'),
      o  = $('.openaside'),
      c  = $('.closeaside');
  if(ai.length>0){
    ai.wrap('<div class="video-container" />');
  };
  if(ae.length>0){
   ae.wrap('<div class="video-container" />');
  };
  c.click(function(){
    ta.css('display', 'block').addClass('fadeIn');
  });
  o.click(function(){
    ta.css('display', 'none');
  });
  $(window).scroll(function(){
    ta.css("top",Math.max(140,320-$(this).scrollTop()));
  });
});
</script>


<script type="text/javascript">
$(document).ready(function(){ 
  var $this = $('.share'),
      url = $this.attr('data-url'),
      encodedUrl = encodeURIComponent(url),
      title = $this.attr('data-title'),
      tsina = $this.attr('data-tsina'),
      description = $this.attr('description');
  var html = [
  '<div class="hoverqrcode clearfix"></div>',
  '<a class="overlay" id="qrcode"></a>',
  '<a href="https://www.facebook.com/sharer.php?u=' + encodedUrl + '" class="article-share-facebook" target="_blank" title="Facebook"></a>',
  '<a href="https://twitter.com/intent/tweet?url=' + encodedUrl + '" class="article-share-twitter" target="_blank" title="Twitter"></a>',
  '<a href="#qrcode" class="article-share-qrcode" title="微信"></a>',
  '<a href="http://widget.renren.com/dialog/share?resourceUrl=' + encodedUrl + '&srcUrl=' + encodedUrl + '&title=' + title +'" class="article-share-renren" target="_blank" title="人人"></a>',
  '<a href="http://service.weibo.com/share/share.php?title='+title+'&url='+encodedUrl +'&ralateUid='+ tsina +'&searchPic=true&style=number' +'" class="article-share-weibo" target="_blank" title="微博"></a>',
  '<span title="Share to"></span>'
  ].join('');
  $this.append(html);

  $('.hoverqrcode').hide();

  var myWidth = 0;
  function updatehoverqrcode(){
    if( typeof( window.innerWidth ) == 'number' ) {
      myWidth = window.innerWidth;
    } else if( document.documentElement && document.documentElement.clientWidth) {
      myWidth = document.documentElement.clientWidth;
    };
    var qrsize = myWidth > 1024 ? 200:100;
    var options = {render: 'image', size: qrsize, fill: '#2ca6cb', text: url, radius: 0.5, quiet: 1};
    var p = $('.article-share-qrcode').position();
    $('.hoverqrcode').empty().css('width', qrsize).css('height', qrsize)
                          .css('left', p.left-qrsize/2+20).css('top', p.top-qrsize-10)
                          .qrcode(options);
  };
  $(window).resize(function(){
    $('.hoverqrcode').hide();
  });
  $('.article-share-qrcode').click(function(){
    updatehoverqrcode();
    $('.hoverqrcode').toggle();
  });
  $('.article-share-qrcode').hover(function(){}, function(){
      $('.hoverqrcode').hide();
  });
});   
</script>











<link rel="stylesheet" href="/fancybox/jquery.fancybox.css" media="screen" type="text/css">
<script src="/fancybox/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
$(document).ready(function(){ 
  $('.article-content').each(function(i){
    $(this).find('img').each(function(){
      if ($(this).parent().hasClass('fancybox')) return;
      var alt = this.alt;
      if (alt) $(this).after('<span class="caption">' + alt + '</span>');
      $(this).wrap('<a href="' + this.src + '" title="' + alt + '" class="fancybox"></a>');
    });
    $(this).find('.fancybox').each(function(){
      $(this).attr('rel', 'article' + i);
    });
  });
  if($.fancybox){
    $('.fancybox').fancybox();
  }
}); 
</script>



<!-- Analytics Begin -->





<!-- Analytics End -->

<!-- Totop Begin -->

	<div id="totop">
	<a title="Back to Top"><img src="/img/scrollup.png"/></a>
	</div>
	<script src="/js/totop.js"></script>

<!-- Totop End -->

<!-- MathJax Begin -->
<!-- mathjax config similar to math.stackexchange -->


<!-- MathJax End -->

<!-- Tiny_search Begin -->

<!-- Tiny_search End -->

  </body>
</html>
