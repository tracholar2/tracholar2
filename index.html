
 <!DOCTYPE HTML>
<html >
<head>
  <meta charset="UTF-8">
  
    <title>智子</title>
    <meta name="viewport" content="width=device-width, initial-scale=1,user-scalable=no">
    
    <meta name="author" content="zhizi">
    

    
    <meta property="og:type" content="website">
<meta property="og:title" content="智子">
<meta property="og:url" content="https://www.tracholar2.top/index.html">
<meta property="og:site_name" content="智子">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="智子">

    
    <link rel="alternative" href="/atom.xml" title="智子" type="application/atom+xml">
    
    
    <link rel="icon" href="/img/favicon.ico">
    
    
    <link rel="apple-touch-icon" href="/img/jacman.jpg">
    <link rel="apple-touch-icon-precomposed" href="/img/jacman.jpg">
    
    <link rel="stylesheet" href="/css/style.css">
</head>

  <body>
    <header>
      
<div>
		
			<div id="textlogo">
				<h1 class="site-name"><a href="/" title="智子">智子</a></h1>
				<h2 class="blog-motto">智子之家</h2>
			</div>
			<div class="navbar"><a class="navbutton navmobile" href="#" title="Menu">
			</a></div>
			<nav class="animated">
				<ul>
					<ul>
					 
						<li><a href="/">Home</a></li>
					
						<li><a href="/archives">Archives</a></li>
					
						<li><a href="/about">About</a></li>
					
					<li>
 					
					<form class="search" action="//google.com/search" method="get" accept-charset="utf-8">
						<label>Search</label>
						<input type="search" id="search" name="q" autocomplete="off" maxlength="20" placeholder="Search" />
						<input type="hidden" name="q" value="site:www.tracholar2.top">
					</form>
					
					</li>
				</ul>
			</nav>			
</div>
    </header>
    <div id="container">
      <div id="main">

   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2018/01/12/RDD-guide/" title="RDD 编程指南" itemprop="url">RDD 编程指南</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="zhizi" target="_blank" itemprop="author">zhizi</a>
		
  <p class="article-time">
    <time datetime="2018-01-12T14:23:30.000Z" itemprop="datePublished"> Published 2018-01-12</time>
    
  </p>
</header>
    <div class="article-content">
        
        <h2><span id="概观">概观</span></h2><p>在高层次上，每个Spark应用程序都包含一个驱动程序，该程序运行用户的main功能，并在集群上执行各种并行操作。Spark提供的主要抽象是一个弹性分布式数据集（RDD），它是在集群节点间进行分区的元素集合，可以并行操作。RDD是通过从Hadoop文件系统（或任何其他Hadoop支持的文件系统）中的文件或驱动程序中现有的Scala集合开始创建的，并对其进行转换。用户还可以要求火花持续存储器中的RDD，允许其有效地跨越并行操作被重复使用。最后，RDD自动从节点故障中恢复。</p>
<p>Spark中的第二个抽象是可用于并行操作的共享变量。默认情况下，Spark在不同节点上并行执行一组任务时，会将该函数中使用的每个变量的副本传送给每个任务。有时候，变量需要在任务之间，或任务与驱动程序之间共享。Spark支持两种类型的共享变量：广播变量，可用于在所有节点上缓存内存中的值，以及累加器，这些变量只是“添加”到的变量，如计数器和总和。</p>
<p>本指南显示了Spark支持的各种语言中的每个功能。如果您启动Spark的交互式shell（无论bin/spark-shell是Scala shell还是 bin/pysparkPython的），最容易跟随。</p>
<h2><span id="链接到spark">链接到Spark</span></h2><p>Spark 2.2.1是构建和分发的，默认使用Scala 2.11。（Spark也可以与Scala的其他版本一起工作。）要在Scala中编写应用程序，您需要使用兼容的Scala版本（例如2.11.X）。</p>
<p>要编写Spark应用程序，您需要在Spark上添加Maven依赖项。Spark可以通过Maven Central获得：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">groupId = org.apache.spark</span><br><span class="line">artifactId = spark-core_2.11</span><br><span class="line">version = 2.2.1</span><br></pre></td></tr></table></figure>
<p>另外，如果您希望访问HDFS集群，则需要hadoop-client为您的HDFS版本添加依赖项 。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">groupId = org.apache.hadoop</span><br><span class="line">artifactId = hadoop-client</span><br><span class="line">version = &lt;your-hdfs-version&gt;</span><br></pre></td></tr></table></figure>
<p>最后，您需要将一些Spark类导入到您的程序中。添加以下行：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.apache.spark.<span class="type">SparkContext</span></span><br><span class="line"><span class="keyword">import</span> org.apache.spark.<span class="type">SparkConf</span></span><br></pre></td></tr></table></figure>
<p>（在Spark 1.3.0之前，您需要明确<code>import org.apache.spark.SparkContext._</code>地启用基本的隐式转换。）</p>
<h2><span id="初始化spark">初始化Spark</span></h2><p>Spark程序必须做的第一件事就是创建一个SparkContext对象，它告诉Spark如何访问一个集群。要创建一个SparkContext你首先需要建立一个包含你的应用程序信息的SparkConf对象。</p>
<p>每个JVM只能有一个SparkContext处于活动状态。stop()在创建一个新的SparkContext之前，您必须使用活动的SparkContext。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> conf = <span class="keyword">new</span> <span class="type">SparkConf</span>().setAppName(appName).setMaster(master)</span><br><span class="line"><span class="keyword">new</span> <span class="type">SparkContext</span>(conf)</span><br></pre></td></tr></table></figure>
<p>该appName参数是您的应用程序在集群UI上显示的名称。 master是Spark，Mesos或YARN群集URL，或者是以本地模式运行的特殊“本地”字符串。实际上，在群集上运行时，您不希望master在程序中进行硬编码，而是启动应用程序spark-submit并在其中接收应用程序。但是，对于本地测试和单元测试，您可以通过“本地”来运行进程中的Spark。</p>
<p>在Spark shell中，已经为您创建了一个特殊的解释器感知的SparkContext，它被称为变量sc。制作自己的SparkContext将不起作用。您可以使用–master参数来设置上下文所连接的主机，并且可以通过将逗号分隔列表传递给参数来将JAR添加到类路径中–jars。您还可以通过向参数提供逗号分隔的Maven坐标列表来将依赖关系（例如Spark包）添加到shell会话中–packages。可能存在依赖关系的任何附加存储库（例如Sonatype）都可以传递给–repositories参数。例如，要bin/spark-shell在四个内核上运行，请使用：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ./bin/spark-shell --master local[4]</span><br></pre></td></tr></table></figure>
<p>或者，也要添加code.jar到其类路径中，请使用：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ./bin/spark-shell --master local[4] --jars code.jar</span><br></pre></td></tr></table></figure>
<p>要使用Maven坐标包含依赖项：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ./bin/spark-shell --master local[<span class="number">4</span>] --packages <span class="string">"org.example:example:0.1"</span></span><br></pre></td></tr></table></figure>
<p>有关选项的完整列表，请运行spark-shell –help。在幕后， spark-shell调用更一般的spark-submit脚本。</p>
<h2><span id="弹性分布式数据集rdd">弹性分布式数据集（RDD）</span></h2><p>Spark围绕弹性分布式数据集（RDD）的概念展开，RDD是可以并行操作的容错元素集合。有两种方法可以创建RDD：并行化 驱动程序中的现有集合，或在外部存储系统（如共享文件系统，HDFS，HBase或提供Hadoop InputFormat的任何数据源）中引用数据集。</p>
<h3><span id="并行集合">并行集合</span></h3><p>并行化集合是通过调用驱动程序（Scala ）中现有集合上SparkContext的parallelize方法来创建的Seq。集合的元素被复制以形成可以并行操作的分布式数据集。例如，下面是如何创建一个保存数字1到5的并行化集合：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> data = <span class="type">Array</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>)</span><br><span class="line"><span class="keyword">val</span> distData = sc.parallelize(data)</span><br></pre></td></tr></table></figure>
<p>一旦创建，分布式数据集（distData）可以并行操作。例如，我们可能调用distData.reduce((a, b) =&gt; a + b)将数组的元素相加。我们稍后介绍分布式数据集上的操作。</p>
<p>并行收集的一个重要参数是要将数据集剪切成的分区数量。Spark将为群集的每个分区运行一个任务。通常情况下，您需要为群集中的每个CPU分配2-4个分区。通常情况下，Spark会尝试根据您的群集自动设置分区数量。但是，也可以通过将其作为第二个参数传递给parallelize（eg sc.parallelize(data, 10)）来进行手动设置。注意：代码中的一些地方使用术语切片（分区的同义词）来维持向后兼容性。</p>
<h3><span id="外部数据集">外部数据集</span></h3><p>Spark可以从Hadoop支持的任何存储源（包括本地文件系统，HDFS，Cassandra，HBase，Amazon S3等）创建分布式数据集.Spark支持文本文件，SequenceFile和任何其他Hadoop InputFormat。</p>
<p>文本文件RDDS可以使用创建SparkContext的textFile方法。此方法需要一个URI的文件（本地路径的机器上，或一个hdfs://，s3n://等URI），并读取其作为行的集合。这是一个示例调用：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; <span class="keyword">val</span> distFile = sc.textFile(<span class="string">"data.txt"</span>)</span><br><span class="line">distFile: org.apache.spark.rdd.<span class="type">RDD</span>[<span class="type">String</span>] = data.txt <span class="type">MapPartitionsRDD</span>[<span class="number">10</span>] at textFile at &lt;console&gt;:<span class="number">26</span></span><br></pre></td></tr></table></figure>
<p>一旦创建，distFile可以通过数据集操作进行操作。例如，我们可以使用map和reduce操作加起来所有行的大小如下：<code>distFile.map(s =&gt; s.length).reduce((a, b) =&gt; a + b)</code>。</p>
<p>使用Spark读取文件的一些注意事项：</p>
<p>如果在本地文件系统上使用路径，则该文件也必须可以在工作节点上的相同路径上访问。将文件复制到所有工作人员或使用网络安装的共享文件系统。</p>
<p>Spark的所有基于文件的输入方法，包括textFile支持在目录，压缩文件和通配符上运行。例如，你可以使用<code>textFile(&quot;/my/directory&quot;)，textFile(&quot;/my/directory/*.txt&quot;)和textFile(&quot;/my/directory/*.gz&quot;)</code>。</p>
<p>该textFile方法还采用可选的第二个参数来控制文件的分区数量。默认情况下，Spark为文件的每个块创建一个分区（HDFS中的块默认为128MB），但是您也可以通过传递更大的值来请求更多的分区。请注意，您不能有比块更少的分区。</p>
<p>除了文本文件外，Spark的Scala API还支持其他几种数据格式：</p>
<ul>
<li><p>SparkContext.wholeTextFiles让你阅读一个包含多个小文本文件的目录，并将它们作为（文件名，内容）对返回。这与textFile每个文件每行返回一条记录相反。分区由数据局部性决定，在某些情况下可能导致分区太少。对于这些情况，wholeTextFiles提供一个可选的第二个参数来控制分区的最小数量。</p>
</li>
<li><p>对于SequenceFiles，使用SparkContext的sequenceFile[K, V]方法，其中K和V是文件中的键和值的类型。这些应该是Hadoop的Writable接口的子类，如IntWritable和Text。另外，Spark允许您为几个常见Writable指定本机类型; 例如，sequenceFile[Int, String]将自动读取IntWritables和文本。</p>
</li>
<li><p>对于其他Hadoop InputFormats，您可以使用该SparkContext.hadoopRDD方法，该方法采用任意的JobConf输入格式类，关键类和值类。将它们设置为您使用输入源进行Hadoop作业的方式相同。您也可以使用SparkContext.newAPIHadoopRDD基于“新”MapReduce API（org.apache.hadoop.mapreduce）的InputFormats 。</p>
</li>
<li><p>RDD.saveAsObjectFile并SparkContext.objectFile支持以包含序列化Java对象的简单格式保存RDD。虽然这不像Avro这样的专业格式，但它提供了一种简单的方法来保存任何RDD。</p>
</li>
</ul>
<h3><span id="rdd操作">RDD操作</span></h3><p>RDDS支持两种类型的操作：转变，从现有的创建一个新的数据集和行动，其上运行的数据集的计算后的值返回驱动程序。例如，map是一个通过函数传递每个数据集元素的变换，并返回表示结果的新RDD。另一方面，reduce是一个动作，使用某个函数来聚合RDD的所有元素，并将最终结果返回给驱动程序（尽管也有一个并行reduceByKey返回分布式数据集）。</p>
<p>Spark中的所有转换都是懒惰的，因为它们不会马上计算结果。相反，他们只记得应用于某些基础数据集（例如文件）的转换。只有在动作需要将结果返回给驱动程序时才会计算转换。这种设计使Spark能够更高效地运行。例如，我们可以认识到，通过创建的数据集map将被用于a中，reduce并且只返回reduce给驱动程序的结果，而不是更大的映射数据集。</p>
<p>默认情况下，每次对其执行操作时，每个已转换的RDD都可能重新计算。但是，您也可以使用（或）方法将RDD 保留在内存中，在这种情况下，Spark将保留群集中的元素，以便在下次查询时快速访问。还支持在磁盘上持久化RDD，或在多个节点上复制RDD。persistcache</p>
<h4><span id="基本">基本</span></h4><p>为了说明RDD基础知识，请考虑下面的简单程序：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> lines = sc.textFile(<span class="string">"data.txt"</span>)</span><br><span class="line"><span class="keyword">val</span> lineLengths = lines.map(s =&gt; s.length)</span><br><span class="line"><span class="keyword">val</span> totalLength = lineLengths.reduce((a, b) =&gt; a + b)</span><br></pre></td></tr></table></figure>
<p>第一行定义了来自外部文件的基本RDD。这个数据集不会被加载到内存中或者作用于其他地方：lines仅仅是一个指向文件的指针。第二行定义lineLengths为map转换的结果。再次，lineLengths 是不是马上计算，由于懒惰。最后，我们跑reduce，这是一个行动。在这一点上，Spark将计算分解为在不同机器上运行的任务，每台机器既运行其地图部分又运行局部缩减，只返回驱动程序的答案。</p>
<p>如果我们还想以后再使用lineLengths，可以添加：</p>
<p>lineLengths.persist()<br>之前reduce，这将导致lineLengths在第一次计算后保存在内存中。</p>
<h4><span id="将函数传递给spark">将函数传递给Spark</span></h4><p>Spark的API在很大程度上依赖于将驱动程序中的函数传递到集群上运行。有两种建议的方法来做到这一点：</p>
<p>匿名函数的语法，可用于短小的代码。<br>全局单例对象中的静态方法 例如，您可以定义object MyFunctions并传递MyFunctions.func1，如下所示：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">MyFunctions</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">func1</span></span>(s: <span class="type">String</span>): <span class="type">String</span> = &#123; ... &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">myRdd.map(<span class="type">MyFunctions</span>.func1)</span><br></pre></td></tr></table></figure>
<p>请注意，虽然也可以在类实例中传递对方法的引用（与单例对象相反），但这需要将包含该类的对象与方法一起发送。例如，考虑：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">func1</span></span>(s: <span class="type">String</span>): <span class="type">String</span> = &#123; ... &#125;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">doStuff</span></span>(rdd: <span class="type">RDD</span>[<span class="type">String</span>]): <span class="type">RDD</span>[<span class="type">String</span>] = &#123; rdd.map(func1) &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这里，如果我们创建一个新的MyClass实例并对其进行调用doStuff，那么其中的map内部引用了该实例的 func1方法，因此需要将整个对象发送到集群。这与写作相似。MyClassrdd.map(x =&gt; this.func1(x))</p>
<p>以类似的方式，访问外部对象的字段将引用整个对象：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> </span>&#123;</span><br><span class="line">  <span class="keyword">val</span> field = <span class="string">"Hello"</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">doStuff</span></span>(rdd: <span class="type">RDD</span>[<span class="type">String</span>]): <span class="type">RDD</span>[<span class="type">String</span>] = &#123; rdd.map(x =&gt; field + x) &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>相当于写作rdd.map(x =&gt; this.field + x)，其中引用所有的this。为了避免这个问题，最简单的方法是复制field到本地变量而不是从外部访问：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">doStuff</span></span>(rdd: <span class="type">RDD</span>[<span class="type">String</span>]): <span class="type">RDD</span>[<span class="type">String</span>] = &#123;</span><br><span class="line">  <span class="keyword">val</span> field_ = <span class="keyword">this</span>.field</span><br><span class="line">  rdd.map(x =&gt; field_ + x)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2><span id="了解闭包">了解闭包</span></h2><p>Spark的难点之一是在集群中执行代码时理解变量和方法的范围和生命周期。修改范围之外的变量的RDD操作可能是混淆的常见来源。在下面的例子中，我们将看看foreach()用于递增计数器的代码，但是其他操作也会出现类似的问题。</p>
<h3><span id="例">例</span></h3><p>考虑下面的天真的RDD元素总和，根据执行是否发生在同一个JVM中，这可能会有不同的表现。一个常见的例子是在local模式（–master = local[n]）中运行Spark 而不是将Spark应用程序部署到集群（例如，通过spark-submit to YARN）：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> counter = <span class="number">0</span></span><br><span class="line"><span class="keyword">var</span> rdd = sc.parallelize(data)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Wrong: Don't do this!!</span></span><br><span class="line">rdd.foreach(x =&gt; counter += x)</span><br><span class="line"></span><br><span class="line">println(<span class="string">"Counter value: "</span> + counter)</span><br></pre></td></tr></table></figure>
<h3><span id="本地或集群模式">本地或集群模式</span></h3><p>上面的代码的行为是未定义的，并可能无法正常工作。为了执行作业，Spark将RDD操作的处理分解为任务，每个任务由执行者执行。在执行之前，Spark计算任务的关闭。闭包是执行者在RDD上执行其计算的那些变量和方法（在这种情况下foreach()）。这个封闭序列化并发送给每个执行者。</p>
<p>发送给每个执行程序的闭包内的变量现在是副本，因此，当函数内引用计数器时foreach，它不再是驱动程序节点上的计数器。驱动程序节点的内存中还有一个计数器，但执行程序不再可见！执行者只能看到序列化闭包的副本。因此，计数器的最终值仍然是零，因为计数器上的所有操作都引用了序列化闭包内的值。</p>
<p>在本地模式下，在某些情况下，该foreach函数将在与驱动程序相同的JVM中实际执行，并将引用相同的原始计数器，并可能实际更新它。</p>
<p>为了确保在这些场景中明确定义的行为，应该使用一个Accumulator。Spark中的累加器专门用于提供一种在集群中的工作节点之间执行拆分时安全地更新变量的机制。本指南的“累加器”部分更详细地讨论了这些内容。</p>
<p>一般来说，闭包 - 像循环或本地定义的方法这样的构造不应该被用来改变一些全局状态。Spark并没有定义或保证对从封闭外引用的对象的突变行为。这样做的一些代码可能在本地模式下工作，但这是偶然的，这样的代码不会按预期在分布式模式下运行。如果需要全局聚合，请使用累加器。</p>
<h3><span id="打印rdd的元素">打印RDD的元素</span></h3><p>另一个常见的习惯是试图用rdd.foreach(println)or 打印RDD的元素rdd.map(println)。在一台机器上，这将产生预期的输出并打印所有RDD的元素。然而，在cluster模式下，stdout执行者所调用的输出现在是写给执行者的，stdout而不是驱动器上的，所以stdout驱动程序不会显示这些！要打印驱动程序中的所有元素，可以使用该collect()方法首先将RDD带到驱动程序节点：rdd.collect().foreach(println)。这可能会导致驱动程序内存不足，因为collect()将整个RDD提取到一台机器; 如果您只需要打印RDD的一些元素，则更安全的方法是使用take()：rdd.take(100).foreach(println)。</p>
<h2><span id="使用键值对">使用键值对</span></h2><p>虽然大多数Spark操作在包含任何类型对象的RDD上工作，但是一些特殊操作仅在键 - 值对的RDD上可用。最常见的是分布式的“随机”操作，如按键分组或聚合元素。</p>
<p>在Scala中，这些操作可以在包含Tuple2对象的RDD上自动使用 （语言中的内置元组，通过简单的书写创建(a, b)）。PairRDDFunctions类中提供了键值对操作， 该类会自动包装元组的RDD。</p>
<p>例如，以下代码使用reduceByKey键值对上的操作来计算文本中每行文本的出现次数：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> lines = sc.textFile(<span class="string">"data.txt"</span>)</span><br><span class="line"><span class="keyword">val</span> pairs = lines.map(s =&gt; (s, <span class="number">1</span>))</span><br><span class="line"><span class="keyword">val</span> counts = pairs.reduceByKey((a, b) =&gt; a + b)</span><br></pre></td></tr></table></figure>
<p>counts.sortByKey()例如，我们也可以按字母顺序对这些对进行排序，最后 counts.collect()把它们作为一个对象数组返回给驱动程序。</p>
<p>注意：在使用自定义对象作为键值对操作中的键时，必须确保自定义equals()方法附带匹配hashCode()方法。有关完整的详细信息，请参阅Object.hashCode（）文档中概述的合同。</p>
<h2><span id="transform">Transform</span></h2><p>下表列出了Spark支持的一些常见转换。有关详细信息，请参阅RDD API文档（Scala， Java， Python， R）和RDD函数doc（Scala， Java）。</p>
<ul>
<li>map（func）    通过函数func传递源的每个元素来形成一个新的分布式数据集。</li>
<li>filter（func）    通过选择func返回true 的源的元素返回一个新的数据集。</li>
<li>flatMap（func）    类似于map，但是每个输入项可以映射到0个或更多个输出项（所以func应该返回一个Seq而不是单个项）。</li>
<li>mapPartitions（func）    与map类似，但是在RDD的每个分区（块）上分别运行，所以当在T型RDD上运行时，func必须是Iterator <t> =&gt; Iterator <u>类型。</u></t></li>
<li>mapPartitionsWithIndex（func）    类似于mapPartitions，而且还提供FUNC与表示所述分区的索引的整数值，所以FUNC必须是类型（中间体，迭代器<t>）=&gt;的迭代器上类型T的RDD运行时<u></u></t></li>
<li>sample（与更换，分数，种子）    使用给定的随机数发生器种子对数据的一小部分进行采样，有或没有替换。</li>
<li>union（otherDataset）    返回包含源数据集中的元素和参数的联合的新数据集。</li>
<li>intersection（otherDataset）    返回一个新的RDD，其中包含源数据集中的元素和参数的交集。</li>
<li>distinct（[ numTasks ]））    返回包含源数据集的不同元素的新数据集。</li>
<li>groupByKey（[ numTasks ]）    当调用（K，V）对的数据集时，返回（K，Iterable <v>）对的数据集。<br>注意：如果您正在对每个密钥执行汇总（例如总计或平均），则使用reduceByKey或aggregateByKey将产生更好的性能。<br>注：默认情况下，输出中的并行级别取决于父RDD的分区数量。您可以传递可选numTasks参数来设置不同数量的任务。</v></li>
<li>reduceByKey（func，[ numTasks ]）    当调用（K，V）对的数据集时，返回（K，V）对的数据集，其中每个键的值使用给定的reduce函数func进行聚合，函数func必须是（V，V）=&gt; V.像in一样groupByKey，reduce任务的数量可以通过可选的第二个参数来配置。</li>
<li>aggregateByKey（zeroValue）（seqOp，combOp，[ numTasks ]）    当调用（K，V）对的数据集时，返回（K，U）对的数据集，其中使用给定的组合函数和中性的“零”值来汇总每个键的值。允许与输入值类型不同的聚合值类型，同时避免不必要的分配。像in一样groupByKey，reduce任务的数量可以通过可选的第二个参数来配置。</li>
<li>sortByKey（[ ascending ]，[ numTasks ]）    当调用K实现Ordered的（K，V）对的数据集时，按照布尔ascending参数中的指定，按照升序或降序返回按键排序的（K，V）对的数据集。</li>
<li>join（otherDataset，[ numTasks ]）    当（K，V）和（K，W）类型的数据集被调用时，返回（K，（V，W））对的每个键的所有元素对的数据集。外连接通过支持leftOuterJoin，rightOuterJoin和fullOuterJoin。</li>
<li>cogroup（otherDataset，[ numTasks ]）    当（K，V）和（K，W）类型的数据集被调用时，返回（K，（Iterable <v>，Iterable <w>））元组的数据集。这个操作也被称为groupWith。</w></v></li>
<li>cartesian（otherDataset）    当调用类型T和U的数据集时，返回（T，U）对（所有元素对）的数据集。</li>
<li>pipe（命令，[envVars]）    通过shell命令管理RDD的每个分区，例如Perl或bash脚本。RDD元素被写入进程的stdin，输出到stdout的行被作为字符串的RDD返回。</li>
<li>coalesce（numPartitions）    减少RDD中的分区数量为numPartitions。用于在过滤大型数据集后更高效地运行操作。</li>
<li>repartition（numPartitions）    随机调整RDD中的数据以创建更多或更少的分区并在其间进行平衡。这总是通过网络混洗所有数据。</li>
<li>repartitionAndSortWithinPartitions（partitioner）    根据给定的分区器对RDD进行重新分区，并在每个结果分区中按键分类记录。这比repartition在每个分区中调用然后排序更高效，因为它可以将排序推送到洗牌机器中。</li>
</ul>
<h2><span id="actions">Actions</span></h2><p>下表列出了Spark支持的一些常用操作。请参阅RDD API文档（Scala， Java， Python， R）</p>
<p>并配对RDD函数doc（Scala， Java）以获取详细信息。</p>
<p>行动    含义<br>减少（func）    使用函数func（它接受两个参数并返回一个）来聚合数据集的元素。该函数应该是可交换和关联的，以便它可以被正确地并行计算。<br>collect（）    在驱动程序中将数据集的所有元素作为数组返回。在过滤器或其他操作返回足够小的数据子集之后，这通常很有用。<br>count（）    返回数据集中元素的数量。<br>第一（）    返回数据集的第一个元素（类似于take（1））。<br>拿（n）    用数据集的前n个元素返回一个数组。<br>takeSample（withReplacement，num，[ seed ]）    返回一个阵列的随机样本NUM数据集的元素，具有或不具有取代，任选地预先指定的随机数发生器的种子。<br>takeOrdered（n，[订购]）    使用自然顺序或自定义比较器返回RDD 的前n个元素。<br>saveAsTextFile（路径）    将数据集的元素作为文本文件（或文本文件集）写入本地文件系统，HDFS或任何其他Hadoop支持的文件系统的给定目录中。Spark将在每个元素上调用toString将其转换为文件中的一行文本。<br>saveAsSequenceFile（路径）<br>（Java和Scala）    将数据集的元素作为Hadoop SequenceFile写入本地文件系统，HDFS或任何其他Hadoop支持的文件系统的给定路径中。这在实现Hadoop的Writable接口的键值对的RDD上是可用的。在Scala中，它也可用于可隐式转换为Writable的类型（Spark包含Int，Double，String等基本类型的转换）。<br>saveAsObjectFile（路径）<br>（Java和Scala）    使用Java序列化以简单的格式写入数据集的元素，然后可以使用Java序列化加载 SparkContext.objectFile()。<br>countByKey（）    仅适用于类型（K，V）的RDD。返回（K，Int）对的hashmap和每个键的计数。<br>foreach（func）    在数据集的每个元素上运行函数func。这通常用于副作用，如更新累加器或与外部存储系统交互。<br>注意：修改除“累加器”以外的变量foreach()可能会导致未定义的行为。请参阅了解更多细节。<br>Spark RDD API还公开了一些动作的异步版本，比如foreachAsyncfor foreach，它立即返回FutureAction给调用者，而不是完成动作时的阻塞。这可以用来管理或等待操作的异步执行。</p>
<h2><span id="shuffle-操作">shuffle 操作</span></h2><p>Spark中的某些操作会触发一个称为shuffle的事件。洗牌是Spark重新分配数据的机制，以便在不同分区之间进行分组。这通常涉及在执行者和机器之间复制数据，使得洗牌成为复杂而昂贵的操作。</p>
<h3><span id="背景">背景</span></h3><p>为了理解在洗牌过程中会发生什么，我们可以考虑reduceByKey操作的例子 。该reduceByKey操作将生成一个新的RDD，其中单个键的所有值都组合为一个元组 - 键和对与该键相关的所有值执行reduce函数的结果。面临的挑战是，并不是所有的单个密钥的值都必须位于同一个分区，甚至是同一个机器上，但是它们必须位于同一地点才能计算出结果。</p>
<p>在Spark中，数据通常不是跨分区分布，而是在特定操作的必要位置。在计算过程中，单个任务将在单个分区上运行 - 因此，要组织所有数据reduceByKey以执行单个reduce任务，Spark需要执行全部操作。它必须从所有分区中读取所有键的值，然后将各个分区上的值汇总在一起，以计算每个键的最终结果 - 这就是所谓的混洗。</p>
<p>虽然新洗牌数据的每个分区中的元素集合是确定性的，分区本身的排序也是确定性的，但这些元素的排序并不是这样。如果一个人在随机播放之后需要可预测的有序数据，那么可以使用：</p>
<p>mapPartitions 使用例如对每个分区进行排序， .sorted<br>repartitionAndSortWithinPartitions 在对分区进行有效分类的同时进行分区<br>sortBy 做一个全球有序的RDD<br>这可能会导致一个洗牌的操作包括重新分区一样操作 repartition和coalesce，ByKey”操作，比如（除计数）groupByKey，并reduceByKey和 参加操作，如cogroup和join。</p>
<h3><span id="性能影响">性能影响</span></h3><p>所述随机播放是昂贵的操作，因为它涉及的磁盘I / O，数据序列，和网络I / O。为了组织数据，Spark生成一组任务 - 映射任务来组织数据，以及一组reduce任务来聚合它。这个术语来自MapReduce，并不直接涉及到Spark map和reduce操作。</p>
<p>在内部，来自个别地图任务的结果被保存在内存中，直到它们不适合为止。然后，这些将根据目标分区进行排序并写入单个文件。在减少方面，任务读取相关的排序块。</p>
<p>某些随机操作会消耗大量的堆内存，因为它们使用内存中的数据结构来在传输之前或之后组织记录。具体而言， reduceByKey并aggregateByKey创建在地图上侧这样的结构，和’ByKey操作产生这些上减少侧。当数据不适合存储在内存中时，Spark会将这些表泄露到磁盘，导致额外的磁盘I / O开销和增加的垃圾回收。</p>
<p>Shuffle也会在磁盘上生成大量的中间文件。从Spark 1.3开始，这些文件将被保留，直到相应的RDD不再使用并被垃圾回收。这样做是为了在重新计算谱系时不需要重新创建洗牌文件。如果应用程序保留对这些RDD的引用，或者GC不经常引入，垃圾收集可能会在很长一段时间后才会发生。这意味着长时间运行的Spark作业可能会消耗大量的磁盘空间。临时存储目录spark.local.dir在配置Spark上下文时由配置参数指定 。</p>
<p>随机行为可以通过调整各种配置参数来调整。请参阅“ Spark配置指南 ”中的“Shuffle Behavior”部分。</p>
<h3><span id="rdd持久性">RDD持久性</span></h3><p>Spark中最重要的功能之一就是在内存中持续（或缓存）一个数据集。当持久化RDD时，每个节点存储它在内存中计算的所有分区，并在该数据集的其他操作（或从中派生的数据集）中重用它们。这使未来的行动更快（通常超过10倍）。缓存是迭代算法和快速交互式使用的关键工具。</p>
<p>你可以用一个persist()或者多个cache()方法来标记一个RDD 。第一次在动作中计算时，它将被保存在节点的内存中。Spark的缓存是容错的 - 如果RDD的任何分区丢失，它将自动使用最初创建它的转换重新计算。</p>
<p>另外，每个持久RDD可以使用不同的存储级别进行存储，例如，允许您将数据集保存在磁盘上，将其保存在内存中，但是作为序列化的Java对象（以节省空间）将其复制到节点上。这些级别通过传递一个 StorageLevel对象（Scala， Java， Python）来设置persist()。该cache()方法是使用默认存储级别的简写，它是StorageLevel.MEMORY_ONLY（将反序列化对象存储在内存中）。全套存储级别是：</p>
<p>存储级别    含义<br>MEMORY_ONLY    将RDD作为反序列化的Java对象存储在JVM中。如果RDD不适合内存，某些分区将不会被缓存，并且每次需要时都会重新进行计算。这是默认级别。<br>MEMORY_AND_DISK    将RDD作为反序列化的Java对象存储在JVM中。如果RDD不适合内存，请存储不适合磁盘的分区，并在需要时从中读取。<br>MEMORY_ONLY_SER<br>（Java和Scala）    将RDD存储为序列化的 Java对象（每个分区一个字节的数组）。这通常比反序列化的对象更节省空间，特别是在使用 快速序列化器的情况下，但需要消耗更多的CPU资源。<br>MEMORY_AND_DISK_SER<br>（Java和Scala）    与MEMORY_ONLY_SER类似，但是将不适合内存的分区溢出到磁盘，而不是每次需要时重新计算它们。<br>DISK_ONLY    将RDD分区仅存储在磁盘上。<br>MEMORY_ONLY_2，MEMORY_AND_DISK_2等    与上面的级别相同，但复制两个群集节点上的每个分区。<br>OFF_HEAP（实验）    与MEMORY_ONLY_SER类似，但将数据存储在 堆内存中。这需要启用堆堆内存。<br>注意： 在Python中，存储对象将始终与Pickle库序列化，所以选择序列化级别无关紧要。Python中的可用存储级别包括MEMORY_ONLY，MEMORY_ONLY_2， MEMORY_AND_DISK，MEMORY_AND_DISK_2，DISK_ONLY，和DISK_ONLY_2。</p>
<p>reduceByKey即使没有用户调用，Spark也会自动保留一些中间数据（例如）persist。这样做是为了避免在洗牌过程中节点失败时重新输入整个输入。我们仍然建议用户调用persist所产生的RDD，如果他们打算重用它。</p>
<h3><span id="选择哪个存储级别">选择哪个存储级别？</span></h3><p>Spark的存储级别旨在提供内存使用和CPU效率之间的不同折衷。我们建议通过以下过程来选择一个：</p>
<p>如果你的RDD适合默认的存储级别（MEMORY_ONLY），那就留下来吧。这是CPU效率最高的选项，允许RDD上的操作尽可能快地运行。</p>
<p>如果没有，尝试使用MEMORY_ONLY_SER和选择一个快速的序列化库，使对象更加节省空间，但仍然相当快地访问。（Java和Scala）</p>
<p>除非计算您的数据集的函数很昂贵，否则他们会过滤大量数据，否则不要泄露到磁盘。否则，重新计算分区可能与从磁盘读取分区一样快。</p>
<p>如果要快速恢复故障，请使用复制的存储级别（例如，如果使用Spark来为Web应用程序提供请求）。所有的存储级别通过重新计算丢失的数据来提供完整的容错能力，但是复制的容量可以让您继续在RDD上运行任务，而无需等待重新计算丢失的分区。</p>
<h3><span id="删除数据">删除数据</span></h3><p>Spark会自动监视每个节点上的高速缓存使用情况，并以最近最少使用（LRU）方式删除旧的数据分区。如果您想要手动删除RDD，而不是等待其从缓存中删除，请使用该RDD.unpersist()方法。</p>
<h2><span id="共享变量">共享变量</span></h2><p>通常，当传递给Spark操作（如mapor reduce）的函数在远程集群节点上执行时，它将在函数中使用的所有变量的单独副本上工作。这些变量被复制到每台机器上，远程机器上的变量没有更新传播到驱动程序。支持通用的，可读写的共享变量将是低效的。但是，Spark 为两种常见使用模式提供了两种有限类型的共享变量：广播变量和累加器。</p>
<h3><span id="广播变量">广播变量</span></h3><p>广播变量允许程序员在每台机器上保存一个只读变量，而不是用任务发送一个只读变量的副本。例如，可以使用它们以有效的方式为每个节点提供大型输入数据集的副本。Spark还尝试使用高效的广播算法来分发广播变量，以降低通信成本。</p>
<p>Spark动作是通过一系列阶段执行的，由分散的“随机”操作分开。Spark会自动播放每个阶段中任务所需的通用数据。以这种方式广播的数据以序列化形式缓存，并在运行每个任务之前反序列化。这意味着只有跨多个阶段的任务需要相同的数据或以反序列化的形式缓存数据时，显式创建广播变量才是有用的。</p>
<p>广播变量是v通过调用从一个变量创建的SparkContext.broadcast(v)。广播变量是一个包装器v，它的值可以通过调用value 方法来访问。下面的代码显示了这一点：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; <span class="keyword">val</span> broadcastVar = sc.broadcast(<span class="type">Array</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>))</span><br><span class="line">broadcastVar: org.apache.spark.broadcast.<span class="type">Broadcast</span>[<span class="type">Array</span>[<span class="type">Int</span>]] = <span class="type">Broadcast</span>(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">scala&gt; broadcastVar.value</span><br><span class="line">res0: <span class="type">Array</span>[<span class="type">Int</span>] = <span class="type">Array</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br></pre></td></tr></table></figure>
<p>在创建广播变量之后，应该使用它来代替v群集上运行的任何函数中的值，以便v不会多次将其发送到节点。另外，v为了确保所有节点获得广播变量的相同值（例如，如果变量稍后被运送到新节点），该对象 在广播之后不应被修改。</p>
<h3><span id="累加器">累加器</span></h3><p>累加器是只能通过关联和交换操作“添加”的变量，因此可以并行有效地支持。它们可以用来实现计数器（如在MapReduce中）或者和。Spark本身支持数字类型的累加器，程序员可以添加对新类型的支持。</p>
<p>作为用户，您可以创建名称或未命名的累加器。如下图所示，一个命名的累加器（在这种情况下counter）将显示在Web用户界面中修改该累加器的阶段。Spark显示由“任务”表中的任务修改的每个累加器的值。</p>
<p><img src="https://spark.apache.org/docs/latest/img/spark-webui-accumulators.png" alt="Spark UI中的累加器"></p>
<p>跟踪用户界面中的累加器对于理解运行阶段的进度非常有用（注意：Python尚不支持）。</p>
<p>数值累加器可以通过调用SparkContext.longAccumulator()或SparkContext.doubleAccumulator() 累加Long或Double类型的值来创建。在集群上运行的任务可以使用该add方法添加到集群中。但是，他们无法读懂它的价值。只有驱动程序可以使用其value方法读取累加器的值。</p>
<p>下面的代码显示了一个累加器被用来加总一个数组的元素：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; <span class="keyword">val</span> accum = sc.longAccumulator(<span class="string">"My Accumulator"</span>)</span><br><span class="line">accum: org.apache.spark.util.<span class="type">LongAccumulator</span> = <span class="type">LongAccumulator</span>(id: <span class="number">0</span>, name: <span class="type">Some</span>(<span class="type">My</span> <span class="type">Accumulator</span>), value: <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">scala&gt; sc.parallelize(<span class="type">Array</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>)).foreach(x =&gt; accum.add(x))</span><br><span class="line">...</span><br><span class="line"><span class="number">10</span>/<span class="number">09</span>/<span class="number">29</span> <span class="number">18</span>:<span class="number">41</span>:<span class="number">08</span> <span class="type">INFO</span> <span class="type">SparkContext</span>: <span class="type">Tasks</span> finished in <span class="number">0.317106</span> s</span><br><span class="line"></span><br><span class="line">scala&gt; accum.value</span><br><span class="line">res2: <span class="type">Long</span> = <span class="number">10</span></span><br></pre></td></tr></table></figure>
<p>虽然这段代码使用了对Long类型的累加器的内置支持，程序员也可以通过继承AccumulatorV2来创建它们自己的类型。AccumulatorV2抽象类有几个方法必须覆盖：reset将累加器重置为零，add向累加器中添加另一个值，merge将另一个相同类型的累加器合并到该累加器中 。其他必须被覆盖的方法包含在API文档中。例如，假设我们有一个MyVector表示数学向量的类，我们可以这样写：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">VectorAccumulatorV2</span> <span class="keyword">extends</span> <span class="title">AccumulatorV2</span>[<span class="type">MyVector</span>, <span class="type">MyVector</span>] </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">val</span> myVector: <span class="type">MyVector</span> = <span class="type">MyVector</span>.createZeroVector</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">reset</span></span>(): <span class="type">Unit</span> = &#123;</span><br><span class="line">    myVector.reset()</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">add</span></span>(v: <span class="type">MyVector</span>): <span class="type">Unit</span> = &#123;</span><br><span class="line">    myVector.add(v)</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Then, create an Accumulator of this type:</span></span><br><span class="line"><span class="keyword">val</span> myVectorAcc = <span class="keyword">new</span> <span class="type">VectorAccumulatorV2</span></span><br><span class="line"><span class="comment">// Then, register it into spark context:</span></span><br><span class="line">sc.register(myVectorAcc, <span class="string">"MyVectorAcc1"</span>)</span><br></pre></td></tr></table></figure>
<p>请注意，当程序员定义自己的AccumulatorV2类型时，结果类型可能与添加元素的类型不同。</p>
<p>对于仅在动作内执行的累加器更新，Spark保证每个任务对累加器的更新只应用一次，即重新启动的任务不会更新值。在转换中，用户应该意识到，如果任务或作业阶段被重新执行，每个任务的更新可能会被应用多次。</p>
<p>累加器不会改变Spark的懒惰评估模型。如果它们在RDD上的操作中被更新，则其值仅在RDD作为动作的一部分计算之后才被更新。因此，累加器更新不能保证在像lazy这样的惰性转换中执行map()。下面的代码片段演示了这个属性：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> accum = sc.longAccumulator</span><br><span class="line">data.map &#123; x =&gt; accum.add(x); x &#125;</span><br><span class="line"><span class="comment">// Here, accum is still 0 because no actions have caused the map operation to be computed.</span></span><br></pre></td></tr></table></figure>
<h2><span id="部署到群集">部署到群集</span></h2><p>在提交申请指南介绍了如何提交申请到集群。简而言之，一旦将应用程序打包为JAR（Java / Scala）或一组.py或多个.zip文件（Python），bin/spark-submit脚本就可以将其提交给任何受支持的集群管理器。</p>
<h2><span id="从java-scala启动spark作业">从Java / Scala启动Spark作业</span></h2><p>该org.apache.spark.launcher 包提供类推出的Spark作为工作使用一个简单的Java API的子进程。</p>
<h2><span id="单元测试">单元测试</span></h2><p>Spark对任何流行的单元测试框架的单元测试都很友好。只需SparkContext在您的测试中创建一个主URL设置为local，运行您的操作，然后打电话SparkContext.stop()把它撕下来。确保停止finally块或测试框架tearDown方法中的上下文，因为Spark不支持在同一个程序中同时运行的两个上下文。</p>
<h2><span id="接下来">接下来</span></h2><p>您可以在Spark网站上看到一些Spark程序示例。另外，Spark在examples目录（Scala， Java， Python， R）中包含了几个示例。您可以通过将类名传递给Spark bin/run-example脚本来运行Java和Scala示例; 例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./bin/run-example SparkPi</span><br></pre></td></tr></table></figure>
<p>对于Python示例，请spark-submit改为使用：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./bin/spark-submit examples/src/main/python/pi.py</span><br></pre></td></tr></table></figure></p>
<p>对于R示例，请spark-submit改用：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./bin/spark-submit examples/src/main/r/dataframe.R</span><br></pre></td></tr></table></figure></p>
<p>有关优化程序的帮助，配置和 调优指南提供有关最佳实践的信息。它们对于确保您的数据以高效格式存储在内存中尤为重要。有关部署的帮助，群集模式概述描述了分布式操作中涉及的组件以及支持的群集管理器。</p>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/spark/">spark</a>
</div>


</div>




<div class="comments-count">
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2018/01/12/spark-tutorial/" title="spark 官方教程" itemprop="url">spark 官方教程</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="zhizi" target="_blank" itemprop="author">zhizi</a>
		
  <p class="article-time">
    <time datetime="2018-01-12T14:08:50.000Z" itemprop="datePublished"> Published 2018-01-12</time>
    
  </p>
</header>
    <div class="article-content">
        
        <p>本教程提供了使用Spark的快速入门。我们将首先通过Spark的交互式shell（Python或Scala）介绍API，然后展示如何用Java，Scala和Python编写应用程序。</p>
<p>要遵循本指南，请先从Spark网站下载Spark的打包版本 。由于我们不会使用HDFS，因此您可以下载任何版本的Hadoop的软件包。</p>
<p>请注意，在Spark 2.0之前，Spark的主要编程接口是弹性分布式数据集（RDD）。在Spark 2.0之后，RDD被数据集取代，数据集类似于RDD类型强大的类型，但在引擎盖下有更丰富的优化。RDD接口仍然受支持，您可以在RDD编程指南中获得更完整的参考资料。但是，我们强烈建议您切换到使用数据集，这比RDD具有更好的性能。请参阅SQL编程指南以获取有关数据集的更多信息。</p>
<h2><span id="使用spark-shell进行交互式分析">使用Spark Shell进行交互式分析</span></h2><h3><span id="基本">基本</span></h3><p>Spark的shell提供了一个学习API的简单方法，也是一个交互式分析数据的强大工具。它可以在Scala（在Java VM上运行，因此是使用现有Java库的好方法）或Python中提供。通过在Spark目录中运行以下代码来启动它：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./bin/spark-shell</span><br></pre></td></tr></table></figure>
<p>Spark的主要抽象是一个名为Dataset的分布式集合。数据集可以通过Hadoop InputFormats（例如HDFS文件）或通过转换其他数据集来创建。让我们从Spark源目录中的README文件的文本中创建一个新的数据集：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; <span class="keyword">val</span> textFile = spark.read.textFile(<span class="string">"README.md"</span>)</span><br><span class="line">textFile: org.apache.spark.sql.<span class="type">Dataset</span>[<span class="type">String</span>] = [value: string]</span><br></pre></td></tr></table></figure>
<p>您可以直接从数据集中获取值，通过调用某些操作，或者转换数据集来获取新的值。有关更多详细信息，请阅读API文档。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; textFile.count() <span class="comment">// Number of items in this Dataset</span></span><br><span class="line">res0: <span class="type">Long</span> = <span class="number">126</span> <span class="comment">// May be different from yours as README.md will change over time, similar to other outputs</span></span><br><span class="line"></span><br><span class="line">scala&gt; textFile.first() <span class="comment">// First item in this Dataset</span></span><br><span class="line">res1: <span class="type">String</span> = # <span class="type">Apache</span> <span class="type">Spark</span></span><br></pre></td></tr></table></figure>
<p>现在让我们转换这个数据集到一个新的。我们调用filter返回一个新的数据集与文件中的项目的一个子集。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; <span class="keyword">val</span> linesWithSpark = textFile.filter(line =&gt; line.contains(<span class="string">"Spark"</span>))</span><br><span class="line">linesWithSpark: org.apache.spark.sql.<span class="type">Dataset</span>[<span class="type">String</span>] = [value: string]</span><br></pre></td></tr></table></figure>
<p>我们可以把变革和行动联系在一起：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; textFile.filter(line =&gt; line.contains(<span class="string">"Spark"</span>)).count() <span class="comment">// How many lines contain "Spark"?</span></span><br><span class="line">res3: <span class="type">Long</span> = <span class="number">15</span></span><br></pre></td></tr></table></figure>
<h3><span id="更多关于数据集操作">更多关于数据集操作</span></h3><p>数据集操作和转换可用于更复杂的计算。比方说，我们想找到最多的单词：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; textFile.map(line =&gt; line.split(<span class="string">" "</span>).size).reduce((a, b) =&gt; <span class="keyword">if</span> (a &gt; b) a <span class="keyword">else</span> b)</span><br><span class="line">res4: <span class="type">Long</span> = <span class="number">15</span></span><br></pre></td></tr></table></figure>
<p>这首先将一行映射到一个整数值，创建一个新的数据集。reduce在该数据集上调用以查找最大的字数。参数map和reduce是Scala函数文字（闭包），并可以使用任何语言功能或Scala / Java库。例如，我们可以轻松地调用其他地方声明的函数。我们将使用Math.max()函数来使这个代码更容易理解：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; <span class="keyword">import</span> java.lang.<span class="type">Math</span></span><br><span class="line"><span class="keyword">import</span> java.lang.<span class="type">Math</span></span><br><span class="line"></span><br><span class="line">scala&gt; textFile.map(line =&gt; line.split(<span class="string">" "</span>).size).reduce((a, b) =&gt; <span class="type">Math</span>.max(a, b))</span><br><span class="line">res5: <span class="type">Int</span> = <span class="number">15</span></span><br></pre></td></tr></table></figure>
<p>一种常见的数据流模式是MapReduce，正如Hadoop所普及的。Spark可以轻松实现MapReduce流程：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; <span class="keyword">val</span> wordCounts = textFile.flatMap(line =&gt; line.split(<span class="string">" "</span>)).groupByKey(identity).count()</span><br><span class="line">wordCounts: org.apache.spark.sql.<span class="type">Dataset</span>[(<span class="type">String</span>, <span class="type">Long</span>)] = [value: string, count(<span class="number">1</span>): bigint]</span><br></pre></td></tr></table></figure>
<p>在这里，我们要求flatMap将一行数据集转换为一个数据集的单词，然后组合groupByKey并count计算文件中每个单词的数量作为（String，Long）对的数据集。为了收集我们shell中的字数，我们可以调用collect：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; wordCounts.collect()</span><br><span class="line">res6: <span class="type">Array</span>[(<span class="type">String</span>, <span class="type">Int</span>)] = <span class="type">Array</span>((means,<span class="number">1</span>), (under,<span class="number">2</span>), (<span class="keyword">this</span>,<span class="number">3</span>), (<span class="type">Because</span>,<span class="number">1</span>), (<span class="type">Python</span>,<span class="number">2</span>), (agree,<span class="number">1</span>), (cluster.,<span class="number">1</span>), ...)</span><br></pre></td></tr></table></figure>
<h3><span id="缓存">缓存</span></h3><p>Spark还支持将数据集提取到集群范围内的内存缓存中。当重复访问数据时，如查询小的“热”数据集或运行迭代算法（如PageRank）时，这非常有用。作为一个简单的例子，让我们标记我们的linesWithSpark数据集被缓存：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; linesWithSpark.cache()</span><br><span class="line">res7: linesWithSpark.<span class="keyword">type</span> = [value: string]</span><br><span class="line"></span><br><span class="line">scala&gt; linesWithSpark.count()</span><br><span class="line">res8: <span class="type">Long</span> = <span class="number">15</span></span><br><span class="line"></span><br><span class="line">scala&gt; linesWithSpark.count()</span><br><span class="line">res9: <span class="type">Long</span> = <span class="number">15</span></span><br></pre></td></tr></table></figure>
<p>使用Spark探索和缓存100行文本文件似乎很愚蠢。有趣的部分是这些相同的函数可以用在非常大的数据集上，即使它们被划分为数十或数百个节点。您也可以bin/spark-shell按照RDD编程指南中的描述，通过连接到集群来交互地完成此操作。</p>
<h2><span id="自包含的应用程序">自包含的应用程序</span></h2><p>假设我们希望使用Spark API编写一个自包含的应用程序。我们将通过一个简单的应用程序在Scala（与SBT），Java（与Maven）和Python（PIP）。</p>
<p>我们将在Scala中创建一个非常简单的Spark应用程序 - 这么简单，事实上，它被命名为SimpleApp.scala：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* SimpleApp.scala */</span></span><br><span class="line"><span class="keyword">import</span> org.apache.spark.sql.<span class="type">SparkSession</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">SimpleApp</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]) &#123;</span><br><span class="line">    <span class="keyword">val</span> logFile = <span class="string">"YOUR_SPARK_HOME/README.md"</span> <span class="comment">// Should be some file on your system</span></span><br><span class="line">    <span class="keyword">val</span> spark = <span class="type">SparkSession</span>.builder.appName(<span class="string">"Simple Application"</span>).getOrCreate()</span><br><span class="line">    <span class="keyword">val</span> logData = spark.read.textFile(logFile).cache()</span><br><span class="line">    <span class="keyword">val</span> numAs = logData.filter(line =&gt; line.contains(<span class="string">"a"</span>)).count()</span><br><span class="line">    <span class="keyword">val</span> numBs = logData.filter(line =&gt; line.contains(<span class="string">"b"</span>)).count()</span><br><span class="line">    println(<span class="string">s"Lines with a: <span class="subst">$numAs</span>, Lines with b: <span class="subst">$numBs</span>"</span>)</span><br><span class="line">    spark.stop()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>请注意，应用程序应该定义一个main()方法而不是扩展scala.App。子类scala.App可能无法正常工作。</p>
<p>这个程序只是计算Spark自述文件中包含’a’的行数和包含’b’的数字。请注意，您需要将YOUR_SPARK_HOME替换为安装Spark的位置。与之前使用Spark shell初始化自己的SparkSession的例子不同，我们初始化一个SparkSession作为程序的一部分。</p>
<p>我们调用SparkSession.builder构造[[SparkSession]]，然后设置应用程序名称，最后调用getOrCreate获取[[SparkSession]]实例。</p>
<p>我们的应用程序依赖于Spark API，所以我们还将包含一个sbt配置文件 build.sbt，它解释了Spark是一个依赖项。该文件还添加了Spark所依赖的存储库：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">name := &quot;Simple Project&quot;</span><br><span class="line"></span><br><span class="line">version := &quot;1.0&quot;</span><br><span class="line"></span><br><span class="line">scalaVersion := &quot;2.11.8&quot;</span><br><span class="line"></span><br><span class="line">libraryDependencies += &quot;org.apache.spark&quot; %% &quot;spark-sql&quot; % &quot;2.2.1&quot;</span><br></pre></td></tr></table></figure>
<p>对于SBT正常工作，我们需要布局SimpleApp.scala并build.sbt 根据典型的目录结构。一旦到位，我们可以创建一个包含应用程序代码的JAR包，然后使用spark-submit脚本来运行我们的程序。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"># Your directory layout should look like this</span><br><span class="line">$ find .</span><br><span class="line">.</span><br><span class="line">./build.sbt</span><br><span class="line">./src</span><br><span class="line">./src/main</span><br><span class="line">./src/main/scala</span><br><span class="line">./src/main/scala/SimpleApp.scala</span><br><span class="line"></span><br><span class="line"># Package a jar containing your application</span><br><span class="line">$ sbt package</span><br><span class="line">...</span><br><span class="line">[info] Packaging &#123;..&#125;/&#123;..&#125;/target/scala-2.11/simple-project_2.11-1.0.jar</span><br><span class="line"></span><br><span class="line"># Use spark-submit to run your application</span><br><span class="line">$ YOUR_SPARK_HOME/bin/spark-submit \</span><br><span class="line">  --class &quot;SimpleApp&quot; \</span><br><span class="line">  --master local[4] \</span><br><span class="line">  target/scala-2.11/simple-project_2.11-1.0.jar</span><br><span class="line">...</span><br><span class="line">Lines with a: 46, Lines with b: 23</span><br></pre></td></tr></table></figure>
<h2><span id="更多">更多</span></h2><p>祝贺您运行您的第一个Spark应用程序！</p>
<p>有关API的深入概述，请从RDD编程指南和SQL编程指南开始，或者参阅其他组件的“编程指南”菜单。<br>要在群集上运行应用程序，请转到部署概述。<br>最后，Spark在examples目录（Scala， Java， Python， R）中包含了几个样本。你可以运行它们如下：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># <span class="type">For</span> <span class="type">Scala</span> and <span class="type">Java</span>, use run-example:</span><br><span class="line">./bin/run-example <span class="type">SparkPi</span></span><br><span class="line"></span><br><span class="line"># <span class="type">For</span> <span class="type">Python</span> examples, use spark-submit directly:</span><br><span class="line">./bin/spark-submit examples/src/main/python/pi.py</span><br><span class="line"></span><br><span class="line"># <span class="type">For</span> <span class="type">R</span> examples, use spark-submit directly:</span><br><span class="line">./bin/spark-submit examples/src/main/r/dataframe.<span class="type">R</span></span><br></pre></td></tr></table></figure>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/spark/">spark</a>
</div>


</div>




<div class="comments-count">
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2018/01/12/python-metaclass/" title="python metaclass" itemprop="url">python metaclass</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="zhizi" target="_blank" itemprop="author">zhizi</a>
		
  <p class="article-time">
    <time datetime="2018-01-12T13:49:19.000Z" itemprop="datePublished"> Published 2018-01-12</time>
    
  </p>
</header>
    <div class="article-content">
        
        <h2><span id="简介">简介</span></h2><p>元类是一个类的类。就像一个类定义一个类的实例的行为一样，元类定义了一个类的行为。一个类是一个元类的一个实例。</p>
<p><img src="https://i.stack.imgur.com/QQ0OK.png" alt="元类图"></p>
<p>在Python中，你可以为元类使用任意的可调参数，但更有用的方法实际上是将它自己变成一个实际的类。type是Python中常用的元类。type它本身就是一个类，而且是它自己的类型。你将无法在Python中重新创建像type一样的东西，但是Python会作弊。要在Python中创建自己的元类，你只要type的子类。</p>
<p>元类最常用作类工厂。就像通过调用类创建类的实例一样，Python通过调用元类来创建一个新类（当它执行’class’语句时）。结合常规<strong>init</strong>和<strong>new</strong>方法，元类因此允许你在创建一个类时做“额外的事情”，比如用一些注册表来注册新类，或者甚至用其他东西来完全替换类。</p>
<p>当class语句被执行时，Python首先class以正常的代码块的形式执行语句的主体。由此产生的命名空间（一个字典）保存待分类的属性。元类是通过查看将被类（元类继承的）的基类，要被类<strong>metaclass</strong>（如果有的话）或<strong>metaclass</strong>全局变量的属性来确定的。元类然后调用类的名称，基类和属性来实例化它。</p>
<p>然而，元类实际上定义了一个类的类型，而不仅仅是一个工厂，所以你可以做更多的事情。例如，您可以在元类上定义常规方法。这些元类方法就像类方法，因为它们可以在没有实例的情况下在类上调用，但是它们也不像类方法，因为它们不能在类的实例上调用。type.<strong>subclasses</strong>()是type元类的一个方法的一个例子。您还可以定义正常的“魔力”的方法，如<strong>add</strong>，<strong>iter</strong>和<strong>getattr</strong>，执行或更改类的行为。</p>
<p>以下是一些小部分的汇总示例：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">make_hook</span><span class="params">(f)</span>:</span></span><br><span class="line">    <span class="string">"""Decorator to turn 'foo' method into '__foo__'"""</span></span><br><span class="line">    f.is_hook = <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> f</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyType</span><span class="params">(type)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__new__</span><span class="params">(cls, name, bases, attrs)</span>:</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> name.startswith(<span class="string">'None'</span>):</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">None</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># Go over attributes and see if they should be renamed.</span></span><br><span class="line">        newattrs = &#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> attrname, attrvalue <span class="keyword">in</span> attrs.iteritems():</span><br><span class="line">            <span class="keyword">if</span> getattr(attrvalue, <span class="string">'is_hook'</span>, <span class="number">0</span>):</span><br><span class="line">                newattrs[<span class="string">'__%s__'</span> % attrname] = attrvalue</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                newattrs[attrname] = attrvalue</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> super(MyType, cls).__new__(cls, name, bases, newattrs)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name, bases, attrs)</span>:</span></span><br><span class="line">        super(MyType, self).__init__(name, bases, attrs)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># classregistry.register(self, self.interfaces)</span></span><br><span class="line">        <span class="keyword">print</span> <span class="string">"Would register class %s now."</span> % self</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__add__</span><span class="params">(self, other)</span>:</span></span><br><span class="line">        <span class="class"><span class="keyword">class</span> <span class="title">AutoClass</span><span class="params">(self, other)</span>:</span></span><br><span class="line">            <span class="keyword">pass</span></span><br><span class="line">        <span class="keyword">return</span> AutoClass</span><br><span class="line">        <span class="comment"># Alternatively, to autogenerate the classname as well as the class:</span></span><br><span class="line">        <span class="comment"># return type(self.__name__ + other.__name__, (self, other), &#123;&#125;)</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">unregister</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="comment"># classregistry.unregister(self)</span></span><br><span class="line">        <span class="keyword">print</span> <span class="string">"Would unregister class %s now."</span> % self</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyObject</span>:</span></span><br><span class="line">    __metaclass__ = MyType</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NoneSample</span><span class="params">(MyObject)</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Will print "NoneType None"</span></span><br><span class="line"><span class="keyword">print</span> type(NoneSample), repr(NoneSample)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Example</span><span class="params">(MyObject)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, value)</span>:</span></span><br><span class="line">        self.value = value</span><br><span class="line"><span class="meta">    @make_hook</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">add</span><span class="params">(self, other)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.__class__(self.value + other.value)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Will unregister the class</span></span><br><span class="line">Example.unregister()</span><br><span class="line"></span><br><span class="line">inst = Example(<span class="number">10</span>)</span><br><span class="line"><span class="comment"># Will fail with an AttributeError</span></span><br><span class="line"><span class="comment">#inst.unregister()</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> inst + inst</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Sibling</span><span class="params">(MyObject)</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">ExampleSibling = Example + Sibling</span><br><span class="line"><span class="comment"># ExampleSibling is now a subclass of both Example and Sibling (with no</span></span><br><span class="line"><span class="comment"># content of its own) although it will believe it's called 'AutoClass'</span></span><br><span class="line"><span class="keyword">print</span> ExampleSibling</span><br><span class="line"><span class="keyword">print</span> ExampleSibling.__mro__</span><br></pre></td></tr></table></figure>
<h2><span id="类作为对象">类作为对象</span></h2><p>在理解元类之前，你需要掌握Python中的类。而且Python从Smalltalk语言中借用了一个非常奇怪的概念。</p>
<p>在大多数语言中，类只是描述如何生成对象的代码段。在Python中也是如此：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">ObjectCreator</span><span class="params">(object)</span>:</span></span><br><span class="line"><span class="meta">... </span>      <span class="keyword">pass</span></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>my_object = ObjectCreator()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(my_object)</span><br><span class="line">&lt;__main__.ObjectCreator object at <span class="number">0x8974f2c</span>&gt;</span><br></pre></td></tr></table></figure>
<p>但是类不仅仅是Python。类也是对象。</p>
<p>只要你使用关键字class，Python就执行它并创建一个OBJECT。指令</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">ObjectCreator</span><span class="params">(object)</span>:</span></span><br><span class="line"><span class="meta">... </span>      <span class="keyword">pass</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>在内存中创建名为“ObjectCreator”的对象。</p>
<p>这个对象（类）本身能够创建对象（实例），这就是为什么它是一个类。</p>
<p>但是，这仍然是一个客体，因此：</p>
<p>你可以把它分配给一个变量<br>你可以复制它<br>你可以添加属性<br>您可以将其作为函数参数传递<br>例如：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(ObjectCreator) <span class="comment"># you can print a class because it's an object</span></span><br><span class="line">&lt;<span class="class"><span class="keyword">class</span> '<span class="title">__main__</span>.<span class="title">ObjectCreator</span>'&gt;</span></span><br><span class="line"><span class="class">&gt;&gt;&gt; <span class="title">def</span> <span class="title">echo</span><span class="params">(o)</span>:</span></span><br><span class="line"><span class="meta">... </span>      print(o)</span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>echo(ObjectCreator) <span class="comment"># you can pass a class as a parameter</span></span><br><span class="line">&lt;<span class="class"><span class="keyword">class</span> '<span class="title">__main__</span>.<span class="title">ObjectCreator</span>'&gt;</span></span><br><span class="line"><span class="class">&gt;&gt;&gt; <span class="title">print</span><span class="params">(hasattr<span class="params">(ObjectCreator, <span class="string">'new_attribute'</span>)</span>)</span></span></span><br><span class="line"><span class="class"><span class="title">False</span></span></span><br><span class="line">&gt;&gt;&gt; ObjectCreator.new_attribute = 'foo' # you can add attributes to a class</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(hasattr(ObjectCreator, <span class="string">'new_attribute'</span>))</span><br><span class="line"><span class="keyword">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(ObjectCreator.new_attribute)</span><br><span class="line">foo</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>ObjectCreatorMirror = ObjectCreator <span class="comment"># you can assign a class to a variable</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(ObjectCreatorMirror.new_attribute)</span><br><span class="line">foo</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(ObjectCreatorMirror())</span><br><span class="line">&lt;__main__.ObjectCreator object at <span class="number">0x8997b4c</span>&gt;</span><br></pre></td></tr></table></figure>
<h2><span id="动态创建类">动态创建类</span></h2><p>由于类是对象，因此可以像任何对象一样快速创建它们。</p>
<p>首先，您可以使用class以下方法在函数中创建一个类：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">choose_class</span><span class="params">(name)</span>:</span></span><br><span class="line"><span class="meta">... </span>    <span class="keyword">if</span> name == <span class="string">'foo'</span>:</span><br><span class="line"><span class="meta">... </span>        <span class="class"><span class="keyword">class</span> <span class="title">Foo</span><span class="params">(object)</span>:</span></span><br><span class="line"><span class="meta">... </span>            <span class="keyword">pass</span></span><br><span class="line"><span class="meta">... </span>        <span class="keyword">return</span> Foo <span class="comment"># return the class, not an instance</span></span><br><span class="line"><span class="meta">... </span>    <span class="keyword">else</span>:</span><br><span class="line"><span class="meta">... </span>        <span class="class"><span class="keyword">class</span> <span class="title">Bar</span><span class="params">(object)</span>:</span></span><br><span class="line"><span class="meta">... </span>            <span class="keyword">pass</span></span><br><span class="line"><span class="meta">... </span>        <span class="keyword">return</span> Bar</span><br><span class="line"><span class="meta">... </span>    </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>MyClass = choose_class(<span class="string">'foo'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(MyClass) <span class="comment"># the function returns a class, not an instance</span></span><br><span class="line">&lt;<span class="class"><span class="keyword">class</span> '<span class="title">__main__</span>.<span class="title">Foo</span>'&gt;</span></span><br><span class="line"><span class="class">&gt;&gt;&gt; <span class="title">print</span><span class="params">(MyClass<span class="params">()</span>)</span> # <span class="title">you</span> <span class="title">can</span> <span class="title">create</span> <span class="title">an</span> <span class="title">object</span> <span class="title">from</span> <span class="title">this</span> <span class="title">class</span></span></span><br><span class="line"><span class="class">&lt;<span class="title">__main__</span>.<span class="title">Foo</span> <span class="title">object</span> <span class="title">at</span> 0<span class="title">x89c6d4c</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>但是它不是那么有活力，因为你还得自己写全班。</p>
<p>由于类是对象，它们必须由某种东西产生。</p>
<p>当你使用class关键字时，Python会自动创建这个对象。但是与Python中的大多数事情一样，它给了你一个手动的方法。</p>
<p>记得功能type？良好的旧功能，让你知道什么类型的对象是：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(type(<span class="number">1</span>))</span><br><span class="line">&lt;type <span class="string">'int'</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(type(<span class="string">"1"</span>))</span><br><span class="line">&lt;type <span class="string">'str'</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(type(ObjectCreator))</span><br><span class="line">&lt;type <span class="string">'type'</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(type(ObjectCreator()))</span><br><span class="line">&lt;<span class="class"><span class="keyword">class</span> '<span class="title">__main__</span>.<span class="title">ObjectCreator</span>'&gt;</span></span><br></pre></td></tr></table></figure>
<p>那么，type有一个完全不同的能力，它也可以在飞行中创建类。type可以把一个类的描述作为参数，并返回一个类。</p>
<p>（我知道，根据你传递给它的参数，相同的函数可能有两种完全不同的用法，这很愚蠢，这是由于Python中的向后兼容性问题）</p>
<p>type 这样工作：</p>
<p>type(name of the class,<br>     tuple of the parent class (for inheritance, can be empty),<br>     dictionary containing attributes names and values)<br>例如：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">MyShinyClass</span><span class="params">(object)</span>:</span></span><br><span class="line"><span class="meta">... </span>      <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>
<p>可以这样手动创建：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>MyShinyClass = type(<span class="string">'MyShinyClass'</span>, (), &#123;&#125;) <span class="comment"># returns a class object</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(MyShinyClass)</span><br><span class="line">&lt;<span class="class"><span class="keyword">class</span> '<span class="title">__main__</span>.<span class="title">MyShinyClass</span>'&gt;</span></span><br><span class="line"><span class="class">&gt;&gt;&gt; <span class="title">print</span><span class="params">(MyShinyClass<span class="params">()</span>)</span> # <span class="title">create</span> <span class="title">an</span> <span class="title">instance</span> <span class="title">with</span> <span class="title">the</span> <span class="title">class</span></span></span><br><span class="line"><span class="class">&lt;<span class="title">__main__</span>.<span class="title">MyShinyClass</span> <span class="title">object</span> <span class="title">at</span> 0<span class="title">x8997cec</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>你会注意到我们使用“MyShinyClass”作为类的名字，并作为变量来保存类的引用。他们可以是不同的，但没有理由使事情复杂化。</p>
<p>type接受一个字典来定义类的属性。所以：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">Foo</span><span class="params">(object)</span>:</span></span><br><span class="line"><span class="meta">... </span>      bar = <span class="keyword">True</span></span><br></pre></td></tr></table></figure>
<p>可以翻译成：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>Foo = type(<span class="string">'Foo'</span>, (), &#123;<span class="string">'bar'</span>:<span class="keyword">True</span>&#125;)</span><br></pre></td></tr></table></figure>
<p>并作为一个普通的类使用：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(Foo)</span><br><span class="line">&lt;<span class="class"><span class="keyword">class</span> '<span class="title">__main__</span>.<span class="title">Foo</span>'&gt;</span></span><br><span class="line"><span class="class">&gt;&gt;&gt; <span class="title">print</span><span class="params">(Foo.bar)</span></span></span><br><span class="line"><span class="class"><span class="title">True</span></span></span><br><span class="line">&gt;&gt;&gt; f = Foo()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(f)</span><br><span class="line">&lt;__main__.Foo object at <span class="number">0x8a9b84c</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(f.bar)</span><br><span class="line"><span class="keyword">True</span></span><br></pre></td></tr></table></figure>
<p>当然，你可以继承它，所以：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>  <span class="class"><span class="keyword">class</span> <span class="title">FooChild</span><span class="params">(Foo)</span>:</span></span><br><span class="line"><span class="meta">... </span>        <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>
<p>将会：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>FooChild = type(<span class="string">'FooChild'</span>, (Foo,), &#123;&#125;)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(FooChild)</span><br><span class="line">&lt;<span class="class"><span class="keyword">class</span> '<span class="title">__main__</span>.<span class="title">FooChild</span>'&gt;</span></span><br><span class="line"><span class="class">&gt;&gt;&gt; <span class="title">print</span><span class="params">(FooChild.bar)</span> # <span class="title">bar</span> <span class="title">is</span> <span class="title">inherited</span> <span class="title">from</span> <span class="title">Foo</span></span></span><br><span class="line"><span class="class"><span class="title">True</span></span></span><br></pre></td></tr></table></figure>
<p>最终你会想要添加方法到你的类。只需定义一个具有适当签名的函数，并将其分配为一个属性即可。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">echo_bar</span><span class="params">(self)</span>:</span></span><br><span class="line"><span class="meta">... </span>      print(self.bar)</span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>FooChild = type(<span class="string">'FooChild'</span>, (Foo,), &#123;<span class="string">'echo_bar'</span>: echo_bar&#125;)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>hasattr(Foo, <span class="string">'echo_bar'</span>)</span><br><span class="line"><span class="keyword">False</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>hasattr(FooChild, <span class="string">'echo_bar'</span>)</span><br><span class="line"><span class="keyword">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>my_foo = FooChild()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>my_foo.echo_bar()</span><br><span class="line"><span class="keyword">True</span></span><br></pre></td></tr></table></figure>
<p>在动态创建类之后，您可以添加更多的方法，就像向正常创建的类对象中添加方法一样。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">echo_bar_more</span><span class="params">(self)</span>:</span></span><br><span class="line"><span class="meta">... </span>      print(<span class="string">'yet another method'</span>)</span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>FooChild.echo_bar_more = echo_bar_more</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>hasattr(FooChild, <span class="string">'echo_bar_more'</span>)</span><br><span class="line"><span class="keyword">True</span></span><br></pre></td></tr></table></figure>
<p>您将看到我们要去的地方：在Python中，类是对象，您可以动态地创建一个类。</p>
<p>这就是Python在使用关键字class时所做的事情，而且它是通过使用元类来实现的。</p>
<p>什么是元类（最后）<br>元类是创建类的“东西”。</p>
<p>你定义类来创建对象，对吧？</p>
<p>但是我们知道Python类是对象。</p>
<p>那么，元类是创建这些对象。他们是类，你可以这样描绘他们：</p>
<p>MyClass = MetaClass()<br>MyObject = MyClass()<br>你已经看到，type让你做这样的事情：</p>
<p>MyClass = type(‘MyClass’, (), {})<br>这是因为这个函数type实际上是一个元类。type是Python用来在幕后创建所有类的元类。</p>
<p>现在你想知道为什么它是用小写字母写的，而不是Type？</p>
<p>那么，我想这是一个与str创建字符串对象int的类以及创建整型对象的类保持一致的问题。type只是创建类对象的类。</p>
<p>你通过检查<strong>class</strong>属性来看到。</p>
<p>一切，我的意思是一切，都是Python中的一个对象。包括整数，字符串，函数和类。所有这些都是对象。所有这些都是从一个类创建的：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>age = <span class="number">35</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>age.__class__</span><br><span class="line">&lt;type <span class="string">'int'</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>name = <span class="string">'bob'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>name.__class__</span><br><span class="line">&lt;type <span class="string">'str'</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">foo</span><span class="params">()</span>:</span> <span class="keyword">pass</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>foo.__class__</span><br><span class="line">&lt;type <span class="string">'function'</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">Bar</span><span class="params">(object)</span>:</span> <span class="keyword">pass</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b = Bar()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b.__class__</span><br><span class="line">&lt;<span class="class"><span class="keyword">class</span> '<span class="title">__main__</span>.<span class="title">Bar</span>'&gt;</span></span><br></pre></td></tr></table></figure>
<p>现在，这是<strong>class</strong>什么<strong>class</strong>？</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>age.__class__.__class__</span><br><span class="line">&lt;type <span class="string">'type'</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>name.__class__.__class__</span><br><span class="line">&lt;type <span class="string">'type'</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>foo.__class__.__class__</span><br><span class="line">&lt;type <span class="string">'type'</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b.__class__.__class__</span><br><span class="line">&lt;type <span class="string">'type'</span>&gt;</span><br></pre></td></tr></table></figure>
<p>所以，元类就是创建类对象的东西。</p>
<p>如果你愿意，你可以称之为“类工厂”。</p>
<p>type 是Python使用的内置元类，但是当然，您可以创建自己的元类。</p>
<p>该<strong>metaclass</strong>属性<br><strong>metaclass</strong>当你写一个类时，你可以添加一个属性：</p>
<p>class Foo(object):<br>  <strong>metaclass</strong> = something…<br>  […]<br>如果这样做，Python将使用元类来创建类Foo。</p>
<p>小心，这很棘手。</p>
<p>你class Foo(object)先写，但是类对象Foo不是在内存中创建的。</p>
<p>Python将<strong>metaclass</strong>在类定义中寻找。如果找到它，它将使用它来创建对象类Foo。如果没有，它将  type用来创建类。</p>
<p>多读几遍。</p>
<p>当你这样做时：</p>
<p>class Foo(Bar):<br>  pass<br>Python执行以下操作：</p>
<p>有一个<strong>metaclass</strong>属性Foo？</p>
<p>如果是的话，在内存中创建一个类对象（我说的是类对象，留在我这里），名称Foo使用是什么<strong>metaclass</strong>。</p>
<p>如果Python找不到<strong>metaclass</strong>，它将<strong>metaclass</strong>在MODULE级别寻找一个，并尝试做同样的事情（但只适用于不继承任何东西的类，基本上是旧式的类）。</p>
<p>如果找不到任何东西<strong>metaclass</strong>，它将使用Bar自己的元类（可能是默认值type）来创建类对象。</p>
<p>在这里要小心，该<strong>metaclass</strong>属性不会被继承，父类（Bar.<strong>class</strong>）的元类将是。如果Bar使用的<strong>metaclass</strong>是创建的属性Bar与type()（不是type.<strong>new</strong>()），子类不会继承该行为。</p>
<p>现在最大的问题是，你能放<strong>metaclass</strong>什么？</p>
<p>答案是：可以创建一个类的东西。</p>
<p>什么可以创建一个类？type，或任何子类或使用它。</p>
<p>自定义元类<br>元类的主要目的是在创建时自动更改类。</p>
<p>您通常对API进行此操作，您需要创建与当前上下文相匹配的类。</p>
<p>想象一个愚蠢的例子，你决定你的模块中的所有类都应该用大写字母来写属性。有几种方法可以做到这一点，但一种方法是<strong>metaclass</strong>在模块级别设置。</p>
<p>这样，这个模块的所有类都将使用这个元类来创建，我们只需要告诉元类将所有的属性都改为大写。</p>
<p>幸运的是，<code>__metaclass__</code>实际上可以是任何可调用的，它不需要是一个正式的类（我知道，名称中的’class’不需要成为一个类，但是这是有用的）。</p>
<p>所以我们将从一个简单的例子开始，使用一个函数。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># the metaclass will automatically get passed the same argument</span></span><br><span class="line"><span class="comment"># that you usually pass to `type`</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">upper_attr</span><span class="params">(future_class_name, future_class_parents, future_class_attr)</span>:</span></span><br><span class="line">  <span class="string">"""</span></span><br><span class="line"><span class="string">    Return a class object, with the list of its attribute turned</span></span><br><span class="line"><span class="string">    into uppercase.</span></span><br><span class="line"><span class="string">  """</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># pick up any attribute that doesn't start with '__' and uppercase it</span></span><br><span class="line">  uppercase_attr = &#123;&#125;</span><br><span class="line">  <span class="keyword">for</span> name, val <span class="keyword">in</span> future_class_attr.items():</span><br><span class="line">      <span class="keyword">if</span> <span class="keyword">not</span> name.startswith(<span class="string">'__'</span>):</span><br><span class="line">          uppercase_attr[name.upper()] = val</span><br><span class="line">      <span class="keyword">else</span>:</span><br><span class="line">          uppercase_attr[name] = val</span><br><span class="line"></span><br><span class="line">  <span class="comment"># let `type` do the class creation</span></span><br><span class="line">  <span class="keyword">return</span> type(future_class_name, future_class_parents, uppercase_attr)</span><br><span class="line"></span><br><span class="line">__metaclass__ = upper_attr <span class="comment"># this will affect all classes in the module</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span><span class="params">()</span>:</span> <span class="comment"># global __metaclass__ won't work with "object" though</span></span><br><span class="line">  <span class="comment"># but we can define __metaclass__ here instead to affect only this class</span></span><br><span class="line">  <span class="comment"># and this will work with "object" children</span></span><br><span class="line">  bar = <span class="string">'bip'</span></span><br><span class="line"></span><br><span class="line">print(hasattr(Foo, <span class="string">'bar'</span>))</span><br><span class="line"><span class="comment"># Out: False</span></span><br><span class="line">print(hasattr(Foo, <span class="string">'BAR'</span>))</span><br><span class="line"><span class="comment"># Out: True</span></span><br><span class="line"></span><br><span class="line">f = Foo()</span><br><span class="line">print(f.BAR)</span><br><span class="line"><span class="comment"># Out: 'bip'</span></span><br><span class="line">现在，让我们做同样的事情，但使用一个真正的类为一个元类：</span><br><span class="line"></span><br><span class="line"><span class="comment"># remember that `type` is actually a class like `str` and `int`</span></span><br><span class="line"><span class="comment"># so you can inherit from it</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UpperAttrMetaclass</span><span class="params">(type)</span>:</span></span><br><span class="line">    <span class="comment"># __new__ is the method called before __init__</span></span><br><span class="line">    <span class="comment"># it's the method that creates the object and returns it</span></span><br><span class="line">    <span class="comment"># while __init__ just initializes the object passed as parameter</span></span><br><span class="line">    <span class="comment"># you rarely use __new__, except when you want to control how the object</span></span><br><span class="line">    <span class="comment"># is created.</span></span><br><span class="line">    <span class="comment"># here the created object is the class, and we want to customize it</span></span><br><span class="line">    <span class="comment"># so we override __new__</span></span><br><span class="line">    <span class="comment"># you can do some stuff in __init__ too if you wish</span></span><br><span class="line">    <span class="comment"># some advanced use involves overriding __call__ as well, but we won't</span></span><br><span class="line">    <span class="comment"># see this</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__new__</span><span class="params">(upperattr_metaclass, future_class_name,</span></span></span><br><span class="line"><span class="function"><span class="params">                future_class_parents, future_class_attr)</span>:</span></span><br><span class="line"></span><br><span class="line">        uppercase_attr = &#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> name, val <span class="keyword">in</span> future_class_attr.items():</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> name.startswith(<span class="string">'__'</span>):</span><br><span class="line">                uppercase_attr[name.upper()] = val</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                uppercase_attr[name] = val</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> type(future_class_name, future_class_parents, uppercase_attr)</span><br></pre></td></tr></table></figure>
<p>但是这不是真的OOP。我们type直接调用，我们不会覆盖或调用父母<strong>new</strong>。我们开始做吧：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UpperAttrMetaclass</span><span class="params">(type)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__new__</span><span class="params">(upperattr_metaclass, future_class_name,</span></span></span><br><span class="line"><span class="function"><span class="params">                future_class_parents, future_class_attr)</span>:</span></span><br><span class="line"></span><br><span class="line">        uppercase_attr = &#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> name, val <span class="keyword">in</span> future_class_attr.items():</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> name.startswith(<span class="string">'__'</span>):</span><br><span class="line">                uppercase_attr[name.upper()] = val</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                uppercase_attr[name] = val</span><br><span class="line"></span><br><span class="line">        <span class="comment"># reuse the type.__new__ method</span></span><br><span class="line">        <span class="comment"># this is basic OOP, nothing magic in there</span></span><br><span class="line">        <span class="keyword">return</span> type.__new__(upperattr_metaclass, future_class_name,</span><br><span class="line">                            future_class_parents, uppercase_attr)</span><br></pre></td></tr></table></figure>
<p>你可能已经注意到了额外的争论upperattr_metaclass。没有什么特别之处：<code>__new__</code>总是接收它定义的类作为第一个参数。就像你有self普通方法接收实例作为第一个参数，或类方法的定义类一样。</p>
<p>当然，为了清楚起见，我在这里使用的名字是很长的，但是self所有的论点都有传统的名字。所以一个真正的生产元类将如下所示：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UpperAttrMetaclass</span><span class="params">(type)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__new__</span><span class="params">(cls, clsname, bases, dct)</span>:</span></span><br><span class="line"></span><br><span class="line">        uppercase_attr = &#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> name, val <span class="keyword">in</span> dct.items():</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> name.startswith(<span class="string">'__'</span>):</span><br><span class="line">                uppercase_attr[name.upper()] = val</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                uppercase_attr[name] = val</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> type.__new__(cls, clsname, bases, uppercase_attr)</span><br></pre></td></tr></table></figure>
<p>我们可以通过使用它来更简洁super，这将减轻继承（因为是的，你可以有元继承，继承自类继承的元类）：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UpperAttrMetaclass</span><span class="params">(type)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__new__</span><span class="params">(cls, clsname, bases, dct)</span>:</span></span><br><span class="line"></span><br><span class="line">        uppercase_attr = &#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> name, val <span class="keyword">in</span> dct.items():</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> name.startswith(<span class="string">'__'</span>):</span><br><span class="line">                uppercase_attr[name.upper()] = val</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                uppercase_attr[name] = val</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> super(UpperAttrMetaclass, cls).__new__(cls, clsname, bases, uppercase_attr)</span><br></pre></td></tr></table></figure>
<p>而已。关于元类没有什么更多。</p>
<p>使用元类代码的复杂性背后的原因不是因为元类，这是因为你通常使用元类来依靠内省来做扭曲的东西，操纵继承，变量<strong>dict</strong>等等。</p>
<p>事实上，元类对于做黑魔法特别有用，因此也是复杂的东西。但是它们本身就很简单：</p>
<p>拦截一个类的创建<br>修改类<br>返回修改的类<br>为什么你会使用元类而不是函数？<br>既然<strong>metaclass</strong>可以接受任何可调用，为什么你会使用一个类，因为它显然更复杂？</p>
<p>这样做有几个原因：</p>
<p>意图很清楚。当你阅读时UpperAttrMetaclass(type)，你会知道接下来会发生什么<br>你可以使用OOP。元类可以从元类继承，重写父类的方法。元类甚至可以使用元类。<br>如果你指定了一个元类，而不是一个元类函数，那么类的子类将是它的元类的实例。<br>你可以更好地构建你的代码。你从来没有像上面的例子那样使用元类。这通常是复杂的。有能力创建几个方法并将它们分组在一个类中，这对于使代码更易于阅读非常有用。<br>你可以钩子<code>__new__</code>，<code>__init__</code>和<code>__call__</code>。这将允许你做不同的东西。即使通常你可以做到这一点<strong>new</strong>，有些人更舒适的使用<strong>init</strong>。<br>这些被称为元类，该死的！这意味着什么！<br>你为什么要使用元类？<br>现在是个大问题。为什么你会使用一些模糊的错误倾向功能？</p>
<p>那么，通常你不会：</p>
<p>元类是更深的魔法，99％的用户不应该担心。如果你想知道你是否需要他们，你不需要（那些真正需要他们的人肯定知道他们需要他们，不需要解释为什么）。</p>
<p>Python大师蒂姆·彼得斯</p>
<p>元类的主要用例是创建一个API。一个典型的例子是Django的ORM。</p>
<p>它允许你定义这样的东西：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span><span class="params">(models.Model)</span>:</span></span><br><span class="line">  name = models.CharField(max_length=<span class="number">30</span>)</span><br><span class="line">  age = models.IntegerField()</span><br></pre></td></tr></table></figure>
<p>但是，如果你这样做：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">guy = Person(name=<span class="string">'bob'</span>, age=<span class="string">'35'</span>)</span><br><span class="line">print(guy.age)</span><br></pre></td></tr></table></figure>
<p>它不会返回一个IntegerField对象。它会返回一个int，甚至可以直接从数据库中获取。</p>
<p>这是可能的，因为models.Model定义<strong>metaclass</strong>和它使用了一些魔法，将Person您刚刚定义的简单语句变成一个复杂的钩子到数据库字段。</p>
<p>Django通过暴露一个简单的API并使用元类来创建一些复杂的外观，从这个API重新创建代码，在幕后做真正的工作。</p>
<p>最后一个字<br>首先，您知道类是可以创建实例的对象。</p>
<p>实际上，类本身就是实例。元类</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">Foo</span><span class="params">(object)</span>:</span> <span class="keyword">pass</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>id(Foo)</span><br><span class="line"><span class="number">142630324</span></span><br></pre></td></tr></table></figure>
<p>一切都是Python中的对象，它们都是类的实例或元类的实例。</p>
<p>除了type。</p>
<p>type实际上是它自己的元类。这不是在纯Python中可以重现的东西，而是通过在实现级别上作弊。</p>
<p>其次，元类是复杂的。你可能不想用它们来进行非常简单的课堂改动。你可以通过使用两种不同的技术来改变类：</p>
<p>猴子补丁<br>类装饰器<br>99％的时间你需要改变类，你最好使用这些。</p>
<p>但98％的时间，你根本不需要改变类。</p>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/python/">python</a>
</div>


</div>




<div class="comments-count">
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2018/01/12/python-yield/" title="python yield 关键字" itemprop="url">python yield 关键字</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="zhizi" target="_blank" itemprop="author">zhizi</a>
		
  <p class="article-time">
    <time datetime="2018-01-12T08:02:23.000Z" itemprop="datePublished"> Published 2018-01-12</time>
    
  </p>
</header>
    <div class="article-content">
        
        <p>要理解什么yield，你必须了解什么是 generator。</p>
<h2><span id="iterables">Iterables</span></h2><p>当你创建一个列表，你可以逐个读取它的项目。逐个读取它的项目称为迭代：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>mylist = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> i <span class="keyword">in</span> mylist:</span><br><span class="line"><span class="meta">... </span>   print(i)</span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">3</span></span><br></pre></td></tr></table></figure>
<p>mylist是一个迭代。当你使用列表推导，你创建一个列表，和一个可迭代的：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>mylist = [x*x <span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">3</span>)]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> i <span class="keyword">in</span> mylist:</span><br><span class="line"><span class="meta">... </span>   print(i)</span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">4</span></span><br></pre></td></tr></table></figure>
<p>你可以使用<code>for... in...</code>的所有东西都是可迭代的; lists，strings，file …</p>
<p>这些迭代器很方便，因为您可以随心所欲地读取它们，但是将所有值存储在内存中，而且当有很多值时，并不总是您想要的值。</p>
<h2><span id="generator">generator</span></h2><p>生成器(generator)是迭代器，一种迭代器，只能迭代一次。generator不会将所有的值存储在内存中，它们会立即生成值：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>mygenerator = (x*x <span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">3</span>))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> i <span class="keyword">in</span> mygenerator:</span><br><span class="line"><span class="meta">... </span>   print(i)</span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">4</span></span><br></pre></td></tr></table></figure>
<p>除了你用来<code>()</code>代替<code>[]</code>之外，它是一样的。但是，由于generator只能使用一次，所以不能再执行<code>for i in mygenerator</code>多次：计算0，然后忘记计算1，逐个计算4。</p>
<h2><span id="yield">yield</span></h2><p>yield是一个像return的关键字，函数将返回一个生成器。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">createGenerator</span><span class="params">()</span>:</span></span><br><span class="line"><span class="meta">... </span>   mylist = range(<span class="number">3</span>)</span><br><span class="line"><span class="meta">... </span>   <span class="keyword">for</span> i <span class="keyword">in</span> mylist:</span><br><span class="line"><span class="meta">... </span>       <span class="keyword">yield</span> i*i</span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>mygenerator = createGenerator() <span class="comment"># create a generator</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(mygenerator) <span class="comment"># mygenerator is an object!</span></span><br><span class="line">&lt;generator object createGenerator at <span class="number">0xb7555c34</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> i <span class="keyword">in</span> mygenerator:</span><br><span class="line"><span class="meta">... </span>    print(i)</span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">4</span></span><br></pre></td></tr></table></figure>
<p>这是一个无用的例子，但是当你知道你的函数将会返回一大堆你只需要读取一次的值的时候，它是很方便的。</p>
<p>要掌握yield，你必须明白当你调用函数时，你写在函数体中的代码不会运行。该函数只返回生成器对象，这有点棘手:-)</p>
<p>然后，您的代码将在每次使用for时运行生成器。</p>
<p>困难的部分：</p>
<p>第一次for调用由你的函数创建的generator对象时，它会从你的函数开始直到碰到它yield，然后返回第一个循环的值。然后，每个其他的调用将运行你已经写在函数中的循环一次，并返回下一个值，直到没有值返回。</p>
<p>一旦函数运行，生成器被认为是空的，但不再被yield触发。这可能是因为循环已经结束，或者因为你不再满足”if/else”了。</p>
<p>生成器的高级用法：</p>
<h2><span id="控制生成器">控制生成器</span></h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">Bank</span><span class="params">()</span>:</span> <span class="comment"># let's create a bank, building ATMs</span></span><br><span class="line"><span class="meta">... </span>   crisis = <span class="keyword">False</span></span><br><span class="line"><span class="meta">... </span>   <span class="function"><span class="keyword">def</span> <span class="title">create_atm</span><span class="params">(self)</span>:</span></span><br><span class="line"><span class="meta">... </span>       <span class="keyword">while</span> <span class="keyword">not</span> self.crisis:</span><br><span class="line"><span class="meta">... </span>           <span class="keyword">yield</span> <span class="string">"$100"</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>hsbc = Bank() <span class="comment"># when everything's ok the ATM gives you as much as you want</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>corner_street_atm = hsbc.create_atm()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(corner_street_atm.next())</span><br><span class="line">$<span class="number">100</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(corner_street_atm.next())</span><br><span class="line">$<span class="number">100</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print([corner_street_atm.next() <span class="keyword">for</span> cash <span class="keyword">in</span> range(<span class="number">5</span>)])</span><br><span class="line">[<span class="string">'$100'</span>, <span class="string">'$100'</span>, <span class="string">'$100'</span>, <span class="string">'$100'</span>, <span class="string">'$100'</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>hsbc.crisis = <span class="keyword">True</span> <span class="comment"># crisis is coming, no more money!</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(corner_street_atm.next())</span><br><span class="line">&lt;type <span class="string">'exceptions.StopIteration'</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>wall_street_atm = hsbc.create_atm() <span class="comment"># it's even true for new ATMs</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(wall_street_atm.next())</span><br><span class="line">&lt;type <span class="string">'exceptions.StopIteration'</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>hsbc.crisis = <span class="keyword">False</span> <span class="comment"># trouble is, even post-crisis the ATM remains empty</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(corner_street_atm.next())</span><br><span class="line">&lt;type <span class="string">'exceptions.StopIteration'</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>brand_new_atm = hsbc.create_atm() <span class="comment"># build a new one to get back in business</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> cash <span class="keyword">in</span> brand_new_atm:</span><br><span class="line"><span class="meta">... </span>   <span class="keyword">print</span> cash</span><br><span class="line">$<span class="number">100</span></span><br><span class="line">$<span class="number">100</span></span><br><span class="line">$<span class="number">100</span></span><br><span class="line">$<span class="number">100</span></span><br><span class="line">$<span class="number">100</span></span><br><span class="line">$<span class="number">100</span></span><br><span class="line">$<span class="number">100</span></span><br><span class="line">$<span class="number">100</span></span><br><span class="line">$<span class="number">100</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>注意：对于Python3使用<code>print(corner_street_atm.__next__())</code>或<code>print(next(corner_street_atm))</code></p>
<p>它可以用于控制对资源的访问等各种功能。</p>
<h2><span id="itertools">Itertools</span></h2><p>itertools模块包含特殊的函数来操作iterables。是否希望复制一个生成器？链接两个生成器？Map / Zip而不创建另一个列表？</p>
<p>然后，只需<code>import itertools</code>。</p>
<p>一个例子，让我们看看四匹马的可能的到达顺序：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>horses = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>races = itertools.permutations(horses)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(races)</span><br><span class="line">&lt;itertools.permutations object at <span class="number">0xb754f1dc</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(list(itertools.permutations(horses)))</span><br><span class="line">[(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>),</span><br><span class="line"> (<span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">3</span>),</span><br><span class="line"> (<span class="number">1</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">4</span>),</span><br><span class="line"> (<span class="number">1</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">2</span>),</span><br><span class="line"> (<span class="number">1</span>, <span class="number">4</span>, <span class="number">2</span>, <span class="number">3</span>),</span><br><span class="line"> (<span class="number">1</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>),</span><br><span class="line"> (<span class="number">2</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">4</span>),</span><br><span class="line"> (<span class="number">2</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">3</span>),</span><br><span class="line"> (<span class="number">2</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">4</span>),</span><br><span class="line"> (<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">1</span>),</span><br><span class="line"> (<span class="number">2</span>, <span class="number">4</span>, <span class="number">1</span>, <span class="number">3</span>),</span><br><span class="line"> (<span class="number">2</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">1</span>),</span><br><span class="line"> (<span class="number">3</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>),</span><br><span class="line"> (<span class="number">3</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">2</span>),</span><br><span class="line"> (<span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">4</span>),</span><br><span class="line"> (<span class="number">3</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">1</span>),</span><br><span class="line"> (<span class="number">3</span>, <span class="number">4</span>, <span class="number">1</span>, <span class="number">2</span>),</span><br><span class="line"> (<span class="number">3</span>, <span class="number">4</span>, <span class="number">2</span>, <span class="number">1</span>),</span><br><span class="line"> (<span class="number">4</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>),</span><br><span class="line"> (<span class="number">4</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">2</span>),</span><br><span class="line"> (<span class="number">4</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">3</span>),</span><br><span class="line"> (<span class="number">4</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">1</span>),</span><br><span class="line"> (<span class="number">4</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">2</span>),</span><br><span class="line"> (<span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>)]</span><br></pre></td></tr></table></figure>
<h2><span id="了解迭代的内在机制">了解迭代的内在机制</span></h2><p>迭代是一个隐式迭代（实现<code>__iter__()</code>方法）和迭代（实现<code>__next__()</code>方法）的过程。Iterables是可以从中获取迭代器的任何对象。迭代器是可以迭代迭代的对象。</p>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/python/">python</a>
</div>


  <div class="article-tags">
  
  <span></span> <a href="/tags/python/">python</a>
  </div>

</div>




<div class="comments-count">
	
</div>

</footer>


    </article>







</div>
      <div class="openaside"><a class="navbutton" href="#" title="Show Sidebar"></a></div>

<div id="asidepart">
<div class="closeaside"><a class="closebutton" href="#" title="Hide Sidebar"></a></div>
<aside class="clearfix">

  


  
<div class="categorieslist">
	<p class="asidetitle">Categories</p>
		<ul>
		
		  
			<li><a href="/categories/python/" title="python">python<sup>2</sup></a></li>
		  
		
		  
			<li><a href="/categories/spark/" title="spark">spark<sup>2</sup></a></li>
		  
		
		</ul>
</div>


  
<div class="tagslist">
	<p class="asidetitle">Tags</p>
		<ul class="clearfix">
		
			
				<li><a href="/tags/python/" title="python">python<sup>1</sup></a></li>
			
		
		</ul>
</div>


  <div class="linkslist">
  <p class="asidetitle">Links</p>
    <ul>
        
          <li>
            
            	<a href="https://tracholar.github.io" target="_blank" title="个人博客">个人博客</a>
            
          </li>
        
    </ul>
</div>

  <div class="rsspart">
	<a href="/atom.xml" target="_blank" title="rss">RSS</a>
</div>

</aside>
</div>
    </div>
    <footer><div id="footer" >
	
	
	<section class="info">
		<p> To be or not to be, that is a question. <br/>
			This is my blog,believe it or not.</p>
	</section>
	 
	<div class="social-font" class="clearfix">
		
		
		
		
		
		
		
		
		
		
	</div>
			
		

		<p class="copyright">
		Powered by <a href="http://hexo.io" target="_blank" title="hexo">hexo</a> and Theme by <a href="https://github.com/wuchong/jacman" target="_blank" title="Jacman">Jacman</a> © 2018 
		
		<a href="/about" target="_blank" title="zhizi">zhizi</a>
		
		
		</p>
</div>
</footer>
    <script src="/js/jquery-2.0.3.min.js"></script>
<script src="/js/jquery.imagesloaded.min.js"></script>
<script src="/js/gallery.js"></script>
<script src="/js/jquery.qrcode-0.12.0.min.js"></script>

<script type="text/javascript">
$(document).ready(function(){ 
  $('.navbar').click(function(){
    $('header nav').toggleClass('shownav');
  });
  var myWidth = 0;
  function getSize(){
    if( typeof( window.innerWidth ) == 'number' ) {
      myWidth = window.innerWidth;
    } else if( document.documentElement && document.documentElement.clientWidth) {
      myWidth = document.documentElement.clientWidth;
    };
  };
  var m = $('#main'),
      a = $('#asidepart'),
      c = $('.closeaside'),
      o = $('.openaside');
  c.click(function(){
    a.addClass('fadeOut').css('display', 'none');
    o.css('display', 'block').addClass('fadeIn');
    m.addClass('moveMain');
  });
  o.click(function(){
    o.css('display', 'none').removeClass('beforeFadeIn');
    a.css('display', 'block').removeClass('fadeOut').addClass('fadeIn');      
    m.removeClass('moveMain');
  });
  $(window).scroll(function(){
    o.css("top",Math.max(80,260-$(this).scrollTop()));
  });
  
  $(window).resize(function(){
    getSize(); 
    if (myWidth >= 1024) {
      $('header nav').removeClass('shownav');
    }else{
      m.removeClass('moveMain');
      a.css('display', 'block').removeClass('fadeOut');
      o.css('display', 'none');
        
    }
  });
});
</script>












<link rel="stylesheet" href="/fancybox/jquery.fancybox.css" media="screen" type="text/css">
<script src="/fancybox/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
$(document).ready(function(){ 
  $('.article-content').each(function(i){
    $(this).find('img').each(function(){
      if ($(this).parent().hasClass('fancybox')) return;
      var alt = this.alt;
      if (alt) $(this).after('<span class="caption">' + alt + '</span>');
      $(this).wrap('<a href="' + this.src + '" title="' + alt + '" class="fancybox"></a>');
    });
    $(this).find('.fancybox').each(function(){
      $(this).attr('rel', 'article' + i);
    });
  });
  if($.fancybox){
    $('.fancybox').fancybox();
  }
}); 
</script>



<!-- Analytics Begin -->





<!-- Analytics End -->

<!-- Totop Begin -->

	<div id="totop">
	<a title="Back to Top"><img src="/img/scrollup.png"/></a>
	</div>
	<script src="/js/totop.js"></script>

<!-- Totop End -->

<!-- MathJax Begin -->
<!-- mathjax config similar to math.stackexchange -->


<!-- MathJax End -->

<!-- Tiny_search Begin -->

<!-- Tiny_search End -->

  </body>
 </html>
