
 <!DOCTYPE HTML>
<html >
<head>
  <meta charset="UTF-8">
  
    <title>智子</title>
    <meta name="viewport" content="width=device-width, initial-scale=1,user-scalable=no">
    
    <meta name="author" content="zhizi">
    

    
    <meta property="og:type" content="website">
<meta property="og:title" content="智子">
<meta property="og:url" content="https://www.tracholar.top/index.html">
<meta property="og:site_name" content="智子">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="智子">

    
    <link rel="alternative" href="/atom.xml" title="智子" type="application/atom+xml">
    
    
    <link rel="icon" href="/img/favicon.ico">
    
    
    <link rel="apple-touch-icon" href="/img/jacman.jpg">
    <link rel="apple-touch-icon-precomposed" href="/img/jacman.jpg">
    
    <link rel="stylesheet" href="/css/style.css">

    <!-- ad start -->
    <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<script>
  (adsbygoogle = window.adsbygoogle || []).push({
    google_ad_client: "ca-pub-6300557868920774",
    enable_page_level_ads: true
  });
</script>

    <script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?4036f580b1119e720db871571faa68cc";
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(hm, s);
})();
</script>

    <!-- ad end -->
</head>

  <body>
    <header>
      
<div>
		
			<div id="textlogo">
				<h1 class="site-name"><a href="/" title="智子">智子</a></h1>
				<h2 class="blog-motto">智子之家</h2>
			</div>
			<div class="navbar"><a class="navbutton navmobile" href="#" title="Menu">
			</a></div>
			<nav class="animated">
				<ul>
					<ul>
					 
						<li><a href="/">Home</a></li>
					
						<li><a href="/archives">Archives</a></li>
					
						<li><a href="/about">About</a></li>
					
					<li>
 					
					<form class="search" action="//google.com/search" method="get" accept-charset="utf-8">
						<label>Search</label>
						<input type="search" id="search" name="q" autocomplete="off" maxlength="20" placeholder="Search" />
						<input type="hidden" name="q" value="site:www.tracholar.top">
					</form>
					
					</li>
				</ul>
			</nav>			
</div>
    </header>
    <div id="container">
      <div id="main">

   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2018/01/13/blockchain-intro/" title="什么是区块链技术？初学者指南" itemprop="url">什么是区块链技术？初学者指南</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="zhizi" target="_blank" itemprop="author">zhizi</a>
		
  <p class="article-time">
    <time datetime="2018-01-13T04:13:41.000Z" itemprop="datePublished"> Published 2018-01-13</time>
    
  </p>
</header>
    <div class="article-content">
        
        <h2><span id="区块链技术是新的互联网吗">区块链技术是新的互联网吗？</span></h2><p>区块链毫无疑问是一个的巧妙发明 —— 一个由化名<a href="https://en.wikipedia.org/wiki/Satoshi_Nakamoto" target="_blank" rel="noopener">Satoshi Nakamoto</a>的人或一群人的心血结晶。但是从那以后，它演变成了更大的东西，每个人都在问的主要问题是：什么是区块链？</p>
<p>通过允许数字信息分发而不复制，区块链技术创造了一种新型互联网的基础。最初设计为数字货币、比特币，现在该技术社区发现其他潜在用途。</p>
<p>比特币被称为“数字黄金”，并有一个很好的理由。迄今为止，该货币的总价值接近90亿美元。区块链也可以创造其他类型的数字价值。就像互联网（或你的车）一样，你不需要知道区块链怎么工作就可以使用它。但是，掌握这项新技术的基本知识将说明为什么它被认为是革命性的。所以，我们希望你喜欢这个区块链指南。</p>
<p><img src="https://blockgeeks-assets.scdn7.secure.raxcdn.com/wp-content/uploads/2016/09/infographics0517-01-1.png" alt="什么是区块链技术？"></p>
<h2><span id="什么是区块链技术">什么是区块链技术？</span></h2><blockquote>
<p>“区块链是一个经济交易中廉洁的数字分类账簿，可以被编程来记录几乎任何有价值的东西，而不仅是金融交易。”<br>—— Blockchain Revolution（2016）作者 Don＆Alex Tapscott，</p>
</blockquote>
<h2><span id="分布式数据库">分布式数据库</span></h2><p>设想一个通过计算机网络复制数千次的电子表格，这个网络的目的是定期更新这个电子表格，然后你将对区块链有一个基本的了解。</p>
<p>在区块链上保存的信息是作为一个共享的，并持续保证一致的数据库而存在的。这是使用这种网络的明显优势。区块链数据库不存储在任何单点位置，这意味着它保存的记录是真正公开的并且容易验证。从而，不存在中心化系统的黑客攻击。利用数百万台计算机同时托管这些信息，互联网上的任何人都可以访问该数据。</p>
<blockquote>
<h3><span id="区块链作为google文档">区块链作为Google文档</span></h3><p>共享文档共享的传统方式是将 Microsoft Word 文档发送给其他收件人，并要求他们对其进行修改。问题是，您需要等到收到退货副本，才能看到或做出其他更改，因为您已被锁定，无法编辑它，直到其他人完成更改。这就是今天数据库的工作方式。两个人不能同时操作同一个记录。这就是银行如何维持货币余额的一致和移动。他们暂时锁定访问权限（或减少余额），然后更新对方，然后重新打开访问权限（或再次更新）。使用Google文档（或Google表格），双方都可以访问相同的文档同时，该文档的单一版本始终对它们都是可见的。它就像一个共享账簿，但它是一个共享文档。当分享涉及许多人时，分布式部分就会起作用。</p>
<p>想象一下应该以这种方式使用的法律文件的数量。与其将它们传递给对方，丢失版本的跟踪，而不与其他版本同步，那为什么不能将所有的业务文档共享。对于有很多这种类型的法律合同来说，这种工作流程将会是理想的方案。当然，你不需要区块链来共享文件，但和共享文件方法是相似的。</p>
<p>—— William Mougayar，创业顾问，4x企业家，市场营销人员，策略师和区块链专家</p>
</blockquote>
<h2><span id="区块链耐用性和鲁邦性">区块链耐用性和鲁邦性</span></h2><p>区块链技术就像互联网一样，具有内置的鲁邦性。通过存储在其网络上相同的信息块，区块链不能：</p>
<ol>
<li>受任何单一实体控制。</li>
<li>没有单点故障。</li>
</ol>
<p>比特币是在2008年发明的，从那以后，比特币区块链就没有受到明显的干扰地运行。（到目前为止，与比特币相关的任何问题都是由于黑客攻击或管理不善造成的，换句话说，这些问题来自恶意和人为错误，而不是基本概念上的缺陷。</p>
<p>互联网本身已被证明可以持续近30年。这是一个有利于区块链技术发展的良好记录。</p>
<p>TEDx演讲者Ian Khan</p>
<p>“正如听起来那样具有革命性意义，Blockchain真正是一个使每个人都能够承担最高责任的机制。没有更多的错过交易，人为或机器错误，甚至没有经过有关各方的同意而进行的交换。最重要的是，Blockchain帮助的最关键的领域是通过记录在一个主要的寄存器上，而不是一个连接的分布式系统的寄存器来保证交易的有效性，所有这些都通过一个安全的验证机制连接起来。</p>
<ul>
<li>Ian Khan ，  TEDx扬声器 | 作者| 技术未来学家</li>
</ul>
<p>透明和不腐败<br>区块链网络处于共识状态，每10分钟自动检查一次。网络是一种数字价值的自我审计生态系统，它协调每隔十分钟发生一次的交易。这些交易的每一组被称为“块”。由此产生两个重要的特性：</p>
<p>透明度 数据作为一个整体嵌入到网络中，根据定义它是公开的。<br>它不能被破坏， 改变区块链上的任何信息单元意味着使用巨大的计算能力来覆盖整个网络。</p>
<p>理论上这可能是可能的。实际上，这不太可能发生。例如，控制系统捕获比特币也会破坏其价值。</p>
<p>以太坊的发明者Vitalik Buterin</p>
<p>“区块链解决了操纵问题。当我在西方谈论这件事的时候，人们说他们信任Google，Facebook或者他们的银行。但世界其他国家并不相信组织和公司，我指的是非洲，印度，东欧或俄罗斯。这不是关于人们真正富有的地方。区块链的机会是尚未达到该水平的国家中最高的。“<br>以太坊发明者Vitalik Buterin</p>
<p>节点网络<br>所谓的计算“节点”网络组成了区块链。</p>
<p>什么是区块链技术？ 一步一步的指导比任何人都能理解</p>
<p>节点<br>（使用执行验证和中继事务的客户端连接到区块链网络的计算机）获取区块链的副本，区块链在加入区块链网络时自动下载。</p>
<p>他们一起创建了一个强大的二级网络，对于互联网如何运作完全不同。</p>
<p>每个节点都是区块链的“管理员”，并自愿加入网络（从这个意义上说，网络是分散的）。然而，每个人都有参与网络的动机：获得比特币的机会。</p>
<p>据说节点是“挖掘”比特币，但是​​这个术语有点用词不当。事实上，每个人都在通过解决计算难题来赢得比特币。比特币是最初构想的区块链的存在理由。现在已经认识到这只是该技术许多潜在应用中的第一个。</p>
<p>估计已经有700种类似比特币的加密货币（可交换价值代币）。此外，原始区块链概念的其他一些潜在适应性目前正在积极或正在开发中。</p>
<p>前美国财政部长拉里·萨默斯（Larry Summers）</p>
<p>“比特币与传真机具有相同的特征。一台传真机是门禁。每个人都有传真机的世界是非常有价值的东西。“<br>前美国财政部长拉里·萨默斯（Larry Summers）</p>
<p>分权的想法<br>在设计上，区块链是一种分散的技术。</p>
<p>发生的任何事情都是整个网络的一个功能。一些重要的含义源于此。通过创建一个新的方式来验证交易传统的商业方面可能变得没有必要。例如，股市交易在区块链上变得几乎同时存在，或者可以使记录保持类型（如土地登记）完全公开。分权已经成为现实。</p>
<p>全球计算机网络使用区块链技术来共同管理记录比特币交易的数据库。也就是说，比特币是由其网络管理的，而不是任何一个中央机关。分散化意味着网络以用户到用户（或对等）为基础运行。这种可能的群众合作形式刚刚开始被调查。</p>
<p>Melanie Swan，作者区块链：新经济蓝图（2015）</p>
<p>“我认为分散的网络将成为技术领域的下一个巨大浪潮。”<br>Melanie Swan，“区块链：新经济蓝图”（2015）</p>
<p>谁会使用区块链？<br>作为网络基础设施，您不需要知道区块链是否对您的生活有用。</p>
<p>目前，金融提供了最强大的技术用例。国际汇款，例如。据世界银行估计，2015年有超过4300亿美元的资金转移。目前对区块链开发商的需求很高。</p>
<p>区块链可能会为这些类型的交易切断中间商。随着“桌面”形式的图形用户界面（Graphical User Interface，GUI）的发明，个人计算变得对普通公众开放。同样，为区块链设计的最常见的GUI是所谓的“钱包”应用程序，人们用比特币购买东西，并将其与其他加密货币一起存储。</p>
<p>在线交易与身份验证过程密切相关。很容易想象，钱包应用程序将在未来几年转变，包括其他类型的身份管理。</p>
<p>什么是区块链技术？ 一步一步的指导比任何人都能理解</p>
<p>“网上身份和声誉将分散。我们将拥有属于我们的数据。“<br>William Mougayar，作者The Business Blockchain：下一代互联网技术的承诺，实践和应用（2016）</p>
<p>区块链和增强的安全性<br>通过在网络上存储数据，区块链消除了数据集中存在的风险。</p>
<p>它的网络缺乏计算机黑客可以利用的中心漏洞。今天的互联网有安全问题，每个人都很熟悉。我们都依靠“用户名/密码”系统来保护我们的身份和资产在线。区块链安全方法使用加密技术。</p>
<p>这个基础是所谓的公共和私人“钥匙”。一个“公钥”（一个随机生成的长字符串）是用户在区块链上的地址。通过网络发送的比特币被记录为属于该地址。“私钥”就像一个给其所有者访问比特币或其他数字资产的密码。将数据存储在区块链中，并且是不可破坏的。这是真的，虽然保护您的数字资产也将需要通过打印出来保护您的私钥，创建所谓的纸钱包。</p>
<p>什么是区块链技术？ 一步一步的指导比任何人都能理解保存</p>
<p>二级网络<br>通过区块链技术，网络获得了新的功能层。</p>
<p>用户之间可以直接进行交易 - 2016年的比特币交易平均每天超过20万美元。随着区块链带来的更多安全性，新的互联网业务正在分拆传统的金融机构。</p>
<p>高盛认为，区块链技术具有巨大的潜力，特别是优化清算和结算，可以代表全球每年高达60亿美元的储蓄。</p>
<p>乔治 - 霍华德 - 副教授 - 教授 - 棕成都大学学报</p>
<p>“2017年将是区块链技术的关键一年。这个领域的许多创业公司要么开始创造收入 - 通过提供产品的市场需求/价值，要么由于用完现金而蒸发。换句话说，2017年应该是利用区块链技术实现更多产品的一年，而区块链技术就是可以洒在所有东西上的神奇精灵尘埃。当然，从客户的角度来看，区块链技术应该是不可见的 - 即使它的功能和功能可以改善人们的生活。我个人熟悉2017年即将启动的大量区块链技术用例。2017年应该体现的这个实施阶段是区块链技术的更大采用的关键一步，</p>
<ul>
<li>乔治·霍华德，布朗大学副教授，伯克利音乐学院和乔治·霍华德战略创始人</li>
</ul>
<p>区块链新的Web 3.0？<br>区块链使互联网用户能够创造价值和认证数字信息。新的业务应用程序会产生什么</p>
<p>智能合约<br>分布式分类账可以实现在满足特定条件时执行的简单合同的编码。以太坊是一个开源的区块链项目，专门为实现这种可能性而构建。尽管如此，在早期阶段，以太坊仍然有可能在真正世界级的规模上利用区块链的实用性。</p>
<p>在技​​术目前的发展水平，智能合约可以编程执行简单的功能。例如，当金融工具符合某个基准时，可以使用区块链技术和比特币来支付衍生工具，从而实现支付自动化。</p>
<p>分享经济<br>随着Uber和AirBnB等公司的蓬勃发展，共享经济已经被证明是成功的。然而，目前，想要乘坐乘车分享服务的用户不得不依赖像Uber这样的中介。通过支持点对点支付，区块链为各方之间的直接互动打开了大门 - 真正实现分散的共享经济。</p>
<p>一个早期的例子，OpenBazaar使用区块链来创建点对点的eBay。将应用程序下载到您的计算设备上，您可以与OpenBarzzar供应商进行交易，而无需支付交易费用。协议的“无规则”精神意味着个人声誉对于企业交互而言将比现在在eBay上更为重要。</p>
<p>众筹<br>像Kickstarter和Gofundme这样的众筹计划正在为新兴的点对点经济做好前期工作。这些网站的受欢迎程度表明人们希望在产品开发方面有直接的发言权。区块链把这个兴趣提高到一个新的水平，可能创造众包的风险投资基金。</p>
<p>在2016年，一个这样的实验，即基于以太坊的DAO（分散式自治组织），在短短两个月内就筹集了惊人的2亿美元。参与者购买了“DAO令牌”，允许他们对智能合约风险投资进行投票（投票权与他们持有的DAO数量相称）。随后的一系列项目资金证明，这个项目是在没有适当的尽职调查的情况下启动的，后果不堪设想。无论如何，DAO实验表明，区块链有可能引入“新的经济合作范式”。</p>
<p>治理<br>通过使结果完全透明和公开，分布式数据库技术可以为选举或任何其他类型的民意调查提供充分的透明度。以太坊的智能合约有助于实现这一过程的自动化。</p>
<p>这个应用程序，会议室，使组织决策发生在区块链上。实际上，这意味着在管理数字资产，股权或信息时，公司治理变得完全透明和可验证。</p>
<p>供应链审计<br>消费者越来越想知道，公司对其产品的道德要求是真实的。分布式账本提供了一个简单的方法来证明我们购买的东西是真实的。透明度带有基于区块链的日期和位置的时间戳 - 例如对于道德钻石 - 与商品编号相对应。</p>
<p>英国的Provenance为一系列消费品提供供应链审计。利用以太坊区块链，Provenance试点项目确保日本寿司餐厅出售的鱼类在印度尼西亚供应商可持续收获。</p>
<p>文件存储<br>分散在互联网上的文件存储带来明显的好处。在整个网络中分配数据可以防止文件被黑客入侵或丢失。</p>
<p>互联星球文件系统（IPFS）可以很容易地概念化分布式网络的运行方式。类似于Bittorrent在互联网上传输数据的方式，IPFS摆脱了对集中式客户端 - 服务器关系（即当前网络）的需求。由完全分散的网站组成的互联网有可能加速文件传输和流式传输时间。这样的改进不仅方便。这是网络当前超载的内容交付系统的必要升级。</p>
<p>预测市场<br>事件概率预测的众包被证明具有高度的准确性。平均意见取消了歪曲判断的未经审查的偏见。根据事件结果进行支付的预测市场已经很活跃。区块链是“人群中的智慧”技术，无疑将会在未来几年找到其他应用。</p>
<p>尽管如此，在Beta版中，预测市场应用程序Augur在现实世界事件的结果上提供了分享产品。参与者可以通过购买正确的预测来赚钱。购买正确结果的股票越多，支出就越高。只需少量资金（少于一美元），任何人都可以提出问题，根据预测结果创建市场，并收取市场产生的一半交易费用。</p>
<p>保护知识产权<br>众所周知，数字信息可以无限复制，并可以通过互联网进行广泛传播。这为全球网络用户提供了免费内容的金矿。然而，版权所有者并不那么幸运，因此失去了对知识产权的控制，并因此而遭受经济损失。智能合约可以保护版权，并在线自动销售创意作品，消除文件复制和再分发的风险。</p>
<p>Mycelia使用区块链创建点对点音乐分配系统。Mycelia由英国创作歌手Imogen Heap创立，使音乐家能够直接向观众销售歌曲，还可以向制作人颁发许可证样本，并向歌曲作者和音乐家分配版税 - 所有这些功能都通过智能合约实现自动化。区块链以小数加密货币金额（小额支付）发行支付的能力表明，区块链的这种使用情况具有很大的成功机会。</p>
<p>物联网（IoT）<br>什么是物联网？某些类型的电子设备的网络控制管理 - 例如监控存储设备的空气温度。智能合同使远程系统管理的自动化成为可能。软件，传感器和网络的组合促进了对象和机制之间的数据交换。结果提高了系统效率并改善了成本监控。</p>
<p>制造业，科技和电信领域的最大厂商都在争夺物联网的主导地位。想想三星，IBM和AT＆T。现有基础架构由现有运营商控制的自然延伸，物联网应用将从机械部件的预测性维护到数据分析，以及大规模自动化系统管理。</p>
<p>邻里微电网<br>区块链技术使购买和销售由邻近微电网产生的可再生能源成为可能。当太阳能电池板产生多余能源时，以太坊智能合约会自动重新分配。随着物联网成为现实，相似类型的智能合约自动化将具有许多其他应用。</p>
<p>Consensys位于布鲁克林，是全球范围内开发以太坊应用的领先企业之一。他们合作的一个项目是Transactive Grid，与分布式能源设备LO3合作。目前正在运行的原型项目使用以太坊智能合约来自动监控和重新分配微电网能源。这个所谓的“智能电网”是物联网功能的早期例子。</p>
<p>身份管理<br>网络上有更好的身份管理需求。验证身份的能力是在线发生的金融交易的关键。但是，网络商务带来的安全风险的补救措施并不完善。分布式账本提供增强的方法来证明你是谁，以及数字化个人文件的可能性。拥有安全的身份对于在线交互也很重要，例如在共享经济中。毕竟，良好的声誉是在线交易最重要的条件。</p>
<p>发展数字身份标准被证明是一个非常复杂的过程。抛开技术挑战，一个普遍的在线身份解决方案需要私营机构和政府之间的合作 除此之外，需要在不同的国家驾驶法律系统，这个问题变得非常困难。互联网上的电子商务目前依靠SSL证书（绿色的小锁）进行网络上的安全交易。Netki是一家致力于为区块链创建SSL标准的创业公司。最近宣布了一轮350万美元的种子轮，Netki预计在2017年初推出一款产品。</p>
<p>反洗钱和KYC<br>反洗钱（AML）和知道你的客户（KYC）的做法有很大的潜力适应区块链。目前，金融机构必须为每个新客户执行一个劳动密集型的多步骤流程。通过跨机构客户端验证可以降低KYC成本，同时提高监控和分析效率。</p>
<p>启动Polycoin有一个涉及分析交易的AML / KYC解决方案。被认定为可疑的交易被转交给合规官。另一家创业公司Tradle正在开发名为Trust in Motion（TiM）的应用程序。TiM被称为“KYC的Instagram”，允许客户拍摄关键文件（护照，公用事业账单等）的快照。一旦被银行验证，这些数据就会密码保存在区块链中。</p>
<p>数据管理<br>今天，为了换取他们的个人资料，人们可以免费使用Facebook等社交媒体平台。将来，用户将能够管理和销售其在线活动所产生的数据。因为它可以很容易地分布在小部分，比特币或类似的东西很可能是用于这种类型的交易的货币。</p>
<p>MIT项目Enigma明白，用户隐私是创建个人数据市场的关键先决条件。Enigma使用加密技术来允许单个数据集在节点之间分离，同时在整个数据组上进行批量计算。对数据进行碎片化也使得Enigma具有可扩展性（与那些在每个节点上复制数据的区块链解决方案不同）。测试版本将在未来六个月内发布。</p>
<p>土地所有权登记<br>作为可公开访问的分类账，区块链可以使各种记录更加高效。产权是一个恰当的例子。他们往往容易受到欺诈，以及昂贵的劳动力密集的管理。</p>
<p>一些国家正在开展基于区块链的土地登记项目。洪都拉斯是第一个在2015年宣布这一倡议的政府，尽管该项目目前的状况尚不清楚。今年，佐治亚共和国与Bitfury集团达成了一项协议，开发了一个财产权区块链系统。据报道，高调的经济学家和产权代言人赫尔南多·德索托（Hernando de Soto）将就该项目提供咨询意见。最近，瑞典宣布正在试验一个区块链应用程序。</p>
<p>股票交易<br>股票结算中增加效率的潜力，为股票交易中的区块链提供了强有力的用例。当执行点对点时，交易确认几乎是瞬间的（而不是三天的交易）。潜在的，这意味着中介机构，如信息交换所，审计师和保管人，将被从流程中移除。</p>
<p>众多股票和商品交易所正在为他们提供的服务（包括澳大利亚证券交易所（ASX），德意志交易所（DeutscheBärse）（法兰克福证券交易所）和JPX（日本交易所集团））提供原型区块链应用。纳斯达克的Linq是私人市场交易的平台（通常是在上市前的创业公司和投资者之间），因此最受瞩目的是该领域公认的先行者。与区块链技术公司Chain，Linq的合作伙伴宣布完成2015年的第一笔交易。最近，纳斯达克宣布为爱沙尼亚股票市场进行代理投票试点项目的开发。</p>
<p>什么是区块链技术？保存</p>
<p>贾德巴格利：什么是区块链</p>
<p>“2016年是区块链理论获得普遍接受的一年，但理论上依然存在，大牌球员徘徊在等待谁看第一枪。随着年度的结束，区块链技术正在逼近转折点，进入小规模商业领域。总的来说，2017年将是充分考虑和资金充足的概念验证的一年，少数项目获得收入正面地位。风险投资将继续保持强劲，但低于我们在2016年和2015年的预期。我预计通过收购将有一两个退出。“</p>
<ul>
<li>Overstock的Judd Bagley  通讯总监。com和首席宣传员在t0。COM</li>
</ul>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">


</div>




<div class="comments-count">
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2018/01/12/RDD-guide/" title="RDD 编程指南" itemprop="url">RDD 编程指南</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="zhizi" target="_blank" itemprop="author">zhizi</a>
		
  <p class="article-time">
    <time datetime="2018-01-12T14:23:30.000Z" itemprop="datePublished"> Published 2018-01-12</time>
    
  </p>
</header>
    <div class="article-content">
        
        <h2><span id="概观">概观</span></h2><p>在高层次上，每个Spark应用程序都包含一个驱动程序，该程序运行用户的main功能，并在集群上执行各种并行操作。Spark提供的主要抽象是一个弹性分布式数据集（RDD），它是在集群节点间进行分区的元素集合，可以并行操作。RDD是通过从Hadoop文件系统（或任何其他Hadoop支持的文件系统）中的文件或驱动程序中现有的Scala集合开始创建的，并对其进行转换。用户还可以要求火花持续存储器中的RDD，允许其有效地跨越并行操作被重复使用。最后，RDD自动从节点故障中恢复。</p>
<p>Spark中的第二个抽象是可用于并行操作的共享变量。默认情况下，Spark在不同节点上并行执行一组任务时，会将该函数中使用的每个变量的副本传送给每个任务。有时候，变量需要在任务之间，或任务与驱动程序之间共享。Spark支持两种类型的共享变量：广播变量，可用于在所有节点上缓存内存中的值，以及累加器，这些变量只是“添加”到的变量，如计数器和总和。</p>
<p>本指南显示了Spark支持的各种语言中的每个功能。如果您启动Spark的交互式shell（无论bin/spark-shell是Scala shell还是 bin/pysparkPython的），最容易跟随。</p>
<h2><span id="链接到spark">链接到Spark</span></h2><p>Spark 2.2.1是构建和分发的，默认使用Scala 2.11。（Spark也可以与Scala的其他版本一起工作。）要在Scala中编写应用程序，您需要使用兼容的Scala版本（例如2.11.X）。</p>
<p>要编写Spark应用程序，您需要在Spark上添加Maven依赖项。Spark可以通过Maven Central获得：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">groupId = org.apache.spark</span><br><span class="line">artifactId = spark-core_2.11</span><br><span class="line">version = 2.2.1</span><br></pre></td></tr></table></figure>
<p>另外，如果您希望访问HDFS集群，则需要hadoop-client为您的HDFS版本添加依赖项 。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">groupId = org.apache.hadoop</span><br><span class="line">artifactId = hadoop-client</span><br><span class="line">version = &lt;your-hdfs-version&gt;</span><br></pre></td></tr></table></figure>
<p>最后，您需要将一些Spark类导入到您的程序中。添加以下行：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.apache.spark.<span class="type">SparkContext</span></span><br><span class="line"><span class="keyword">import</span> org.apache.spark.<span class="type">SparkConf</span></span><br></pre></td></tr></table></figure>
<p>（在Spark 1.3.0之前，您需要明确<code>import org.apache.spark.SparkContext._</code>地启用基本的隐式转换。）</p>
<h2><span id="初始化spark">初始化Spark</span></h2><p>Spark程序必须做的第一件事就是创建一个SparkContext对象，它告诉Spark如何访问一个集群。要创建一个SparkContext你首先需要建立一个包含你的应用程序信息的SparkConf对象。</p>
<p>每个JVM只能有一个SparkContext处于活动状态。stop()在创建一个新的SparkContext之前，您必须使用活动的SparkContext。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> conf = <span class="keyword">new</span> <span class="type">SparkConf</span>().setAppName(appName).setMaster(master)</span><br><span class="line"><span class="keyword">new</span> <span class="type">SparkContext</span>(conf)</span><br></pre></td></tr></table></figure>
<p>该appName参数是您的应用程序在集群UI上显示的名称。 master是Spark，Mesos或YARN群集URL，或者是以本地模式运行的特殊“本地”字符串。实际上，在群集上运行时，您不希望master在程序中进行硬编码，而是启动应用程序spark-submit并在其中接收应用程序。但是，对于本地测试和单元测试，您可以通过“本地”来运行进程中的Spark。</p>
<p>在Spark shell中，已经为您创建了一个特殊的解释器感知的SparkContext，它被称为变量sc。制作自己的SparkContext将不起作用。您可以使用–master参数来设置上下文所连接的主机，并且可以通过将逗号分隔列表传递给参数来将JAR添加到类路径中–jars。您还可以通过向参数提供逗号分隔的Maven坐标列表来将依赖关系（例如Spark包）添加到shell会话中–packages。可能存在依赖关系的任何附加存储库（例如Sonatype）都可以传递给–repositories参数。例如，要bin/spark-shell在四个内核上运行，请使用：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ./bin/spark-shell --master local[4]</span><br></pre></td></tr></table></figure>
<p>或者，也要添加code.jar到其类路径中，请使用：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ./bin/spark-shell --master local[4] --jars code.jar</span><br></pre></td></tr></table></figure>
<p>要使用Maven坐标包含依赖项：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ./bin/spark-shell --master local[<span class="number">4</span>] --packages <span class="string">"org.example:example:0.1"</span></span><br></pre></td></tr></table></figure>
<p>有关选项的完整列表，请运行spark-shell –help。在幕后， spark-shell调用更一般的spark-submit脚本。</p>
<h2><span id="弹性分布式数据集rdd">弹性分布式数据集（RDD）</span></h2><p>Spark围绕弹性分布式数据集（RDD）的概念展开，RDD是可以并行操作的容错元素集合。有两种方法可以创建RDD：并行化 驱动程序中的现有集合，或在外部存储系统（如共享文件系统，HDFS，HBase或提供Hadoop InputFormat的任何数据源）中引用数据集。</p>
<h3><span id="并行集合">并行集合</span></h3><p>并行化集合是通过调用驱动程序（Scala ）中现有集合上SparkContext的parallelize方法来创建的Seq。集合的元素被复制以形成可以并行操作的分布式数据集。例如，下面是如何创建一个保存数字1到5的并行化集合：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> data = <span class="type">Array</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>)</span><br><span class="line"><span class="keyword">val</span> distData = sc.parallelize(data)</span><br></pre></td></tr></table></figure>
<p>一旦创建，分布式数据集（distData）可以并行操作。例如，我们可能调用distData.reduce((a, b) =&gt; a + b)将数组的元素相加。我们稍后介绍分布式数据集上的操作。</p>
<p>并行收集的一个重要参数是要将数据集剪切成的分区数量。Spark将为群集的每个分区运行一个任务。通常情况下，您需要为群集中的每个CPU分配2-4个分区。通常情况下，Spark会尝试根据您的群集自动设置分区数量。但是，也可以通过将其作为第二个参数传递给parallelize（eg sc.parallelize(data, 10)）来进行手动设置。注意：代码中的一些地方使用术语切片（分区的同义词）来维持向后兼容性。</p>
<h3><span id="外部数据集">外部数据集</span></h3><p>Spark可以从Hadoop支持的任何存储源（包括本地文件系统，HDFS，Cassandra，HBase，Amazon S3等）创建分布式数据集.Spark支持文本文件，SequenceFile和任何其他Hadoop InputFormat。</p>
<p>文本文件RDDS可以使用创建SparkContext的textFile方法。此方法需要一个URI的文件（本地路径的机器上，或一个hdfs://，s3n://等URI），并读取其作为行的集合。这是一个示例调用：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; <span class="keyword">val</span> distFile = sc.textFile(<span class="string">"data.txt"</span>)</span><br><span class="line">distFile: org.apache.spark.rdd.<span class="type">RDD</span>[<span class="type">String</span>] = data.txt <span class="type">MapPartitionsRDD</span>[<span class="number">10</span>] at textFile at &lt;console&gt;:<span class="number">26</span></span><br></pre></td></tr></table></figure>
<p>一旦创建，distFile可以通过数据集操作进行操作。例如，我们可以使用map和reduce操作加起来所有行的大小如下：<code>distFile.map(s =&gt; s.length).reduce((a, b) =&gt; a + b)</code>。</p>
<p>使用Spark读取文件的一些注意事项：</p>
<p>如果在本地文件系统上使用路径，则该文件也必须可以在工作节点上的相同路径上访问。将文件复制到所有工作人员或使用网络安装的共享文件系统。</p>
<p>Spark的所有基于文件的输入方法，包括textFile支持在目录，压缩文件和通配符上运行。例如，你可以使用<code>textFile(&quot;/my/directory&quot;)，textFile(&quot;/my/directory/*.txt&quot;)和textFile(&quot;/my/directory/*.gz&quot;)</code>。</p>
<p>该textFile方法还采用可选的第二个参数来控制文件的分区数量。默认情况下，Spark为文件的每个块创建一个分区（HDFS中的块默认为128MB），但是您也可以通过传递更大的值来请求更多的分区。请注意，您不能有比块更少的分区。</p>
<p>除了文本文件外，Spark的Scala API还支持其他几种数据格式：</p>
<ul>
<li><p>SparkContext.wholeTextFiles让你阅读一个包含多个小文本文件的目录，并将它们作为（文件名，内容）对返回。这与textFile每个文件每行返回一条记录相反。分区由数据局部性决定，在某些情况下可能导致分区太少。对于这些情况，wholeTextFiles提供一个可选的第二个参数来控制分区的最小数量。</p>
</li>
<li><p>对于SequenceFiles，使用SparkContext的sequenceFile[K, V]方法，其中K和V是文件中的键和值的类型。这些应该是Hadoop的Writable接口的子类，如IntWritable和Text。另外，Spark允许您为几个常见Writable指定本机类型; 例如，sequenceFile[Int, String]将自动读取IntWritables和文本。</p>
</li>
<li><p>对于其他Hadoop InputFormats，您可以使用该SparkContext.hadoopRDD方法，该方法采用任意的JobConf输入格式类，关键类和值类。将它们设置为您使用输入源进行Hadoop作业的方式相同。您也可以使用SparkContext.newAPIHadoopRDD基于“新”MapReduce API（org.apache.hadoop.mapreduce）的InputFormats 。</p>
</li>
<li><p>RDD.saveAsObjectFile并SparkContext.objectFile支持以包含序列化Java对象的简单格式保存RDD。虽然这不像Avro这样的专业格式，但它提供了一种简单的方法来保存任何RDD。</p>
</li>
</ul>
<h3><span id="rdd操作">RDD操作</span></h3><p>RDDS支持两种类型的操作：转变，从现有的创建一个新的数据集和行动，其上运行的数据集的计算后的值返回驱动程序。例如，map是一个通过函数传递每个数据集元素的变换，并返回表示结果的新RDD。另一方面，reduce是一个动作，使用某个函数来聚合RDD的所有元素，并将最终结果返回给驱动程序（尽管也有一个并行reduceByKey返回分布式数据集）。</p>
<p>Spark中的所有转换都是懒惰的，因为它们不会马上计算结果。相反，他们只记得应用于某些基础数据集（例如文件）的转换。只有在动作需要将结果返回给驱动程序时才会计算转换。这种设计使Spark能够更高效地运行。例如，我们可以认识到，通过创建的数据集map将被用于a中，reduce并且只返回reduce给驱动程序的结果，而不是更大的映射数据集。</p>
<p>默认情况下，每次对其执行操作时，每个已转换的RDD都可能重新计算。但是，您也可以使用（或）方法将RDD 保留在内存中，在这种情况下，Spark将保留群集中的元素，以便在下次查询时快速访问。还支持在磁盘上持久化RDD，或在多个节点上复制RDD。persistcache</p>
<h4><span id="基本">基本</span></h4><p>为了说明RDD基础知识，请考虑下面的简单程序：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> lines = sc.textFile(<span class="string">"data.txt"</span>)</span><br><span class="line"><span class="keyword">val</span> lineLengths = lines.map(s =&gt; s.length)</span><br><span class="line"><span class="keyword">val</span> totalLength = lineLengths.reduce((a, b) =&gt; a + b)</span><br></pre></td></tr></table></figure>
<p>第一行定义了来自外部文件的基本RDD。这个数据集不会被加载到内存中或者作用于其他地方：lines仅仅是一个指向文件的指针。第二行定义lineLengths为map转换的结果。再次，lineLengths 是不是马上计算，由于懒惰。最后，我们跑reduce，这是一个行动。在这一点上，Spark将计算分解为在不同机器上运行的任务，每台机器既运行其地图部分又运行局部缩减，只返回驱动程序的答案。</p>
<p>如果我们还想以后再使用lineLengths，可以添加：</p>
<p>lineLengths.persist()<br>之前reduce，这将导致lineLengths在第一次计算后保存在内存中。</p>
<h4><span id="将函数传递给spark">将函数传递给Spark</span></h4><p>Spark的API在很大程度上依赖于将驱动程序中的函数传递到集群上运行。有两种建议的方法来做到这一点：</p>
<p>匿名函数的语法，可用于短小的代码。<br>全局单例对象中的静态方法 例如，您可以定义object MyFunctions并传递MyFunctions.func1，如下所示：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">MyFunctions</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">func1</span></span>(s: <span class="type">String</span>): <span class="type">String</span> = &#123; ... &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">myRdd.map(<span class="type">MyFunctions</span>.func1)</span><br></pre></td></tr></table></figure>
<p>请注意，虽然也可以在类实例中传递对方法的引用（与单例对象相反），但这需要将包含该类的对象与方法一起发送。例如，考虑：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">func1</span></span>(s: <span class="type">String</span>): <span class="type">String</span> = &#123; ... &#125;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">doStuff</span></span>(rdd: <span class="type">RDD</span>[<span class="type">String</span>]): <span class="type">RDD</span>[<span class="type">String</span>] = &#123; rdd.map(func1) &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这里，如果我们创建一个新的MyClass实例并对其进行调用doStuff，那么其中的map内部引用了该实例的 func1方法，因此需要将整个对象发送到集群。这与写作相似。MyClassrdd.map(x =&gt; this.func1(x))</p>
<p>以类似的方式，访问外部对象的字段将引用整个对象：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> </span>&#123;</span><br><span class="line">  <span class="keyword">val</span> field = <span class="string">"Hello"</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">doStuff</span></span>(rdd: <span class="type">RDD</span>[<span class="type">String</span>]): <span class="type">RDD</span>[<span class="type">String</span>] = &#123; rdd.map(x =&gt; field + x) &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>相当于写作rdd.map(x =&gt; this.field + x)，其中引用所有的this。为了避免这个问题，最简单的方法是复制field到本地变量而不是从外部访问：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">doStuff</span></span>(rdd: <span class="type">RDD</span>[<span class="type">String</span>]): <span class="type">RDD</span>[<span class="type">String</span>] = &#123;</span><br><span class="line">  <span class="keyword">val</span> field_ = <span class="keyword">this</span>.field</span><br><span class="line">  rdd.map(x =&gt; field_ + x)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2><span id="了解闭包">了解闭包</span></h2><p>Spark的难点之一是在集群中执行代码时理解变量和方法的范围和生命周期。修改范围之外的变量的RDD操作可能是混淆的常见来源。在下面的例子中，我们将看看foreach()用于递增计数器的代码，但是其他操作也会出现类似的问题。</p>
<h3><span id="例">例</span></h3><p>考虑下面的天真的RDD元素总和，根据执行是否发生在同一个JVM中，这可能会有不同的表现。一个常见的例子是在local模式（–master = local[n]）中运行Spark 而不是将Spark应用程序部署到集群（例如，通过spark-submit to YARN）：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> counter = <span class="number">0</span></span><br><span class="line"><span class="keyword">var</span> rdd = sc.parallelize(data)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Wrong: Don't do this!!</span></span><br><span class="line">rdd.foreach(x =&gt; counter += x)</span><br><span class="line"></span><br><span class="line">println(<span class="string">"Counter value: "</span> + counter)</span><br></pre></td></tr></table></figure>
<h3><span id="本地或集群模式">本地或集群模式</span></h3><p>上面的代码的行为是未定义的，并可能无法正常工作。为了执行作业，Spark将RDD操作的处理分解为任务，每个任务由执行者执行。在执行之前，Spark计算任务的关闭。闭包是执行者在RDD上执行其计算的那些变量和方法（在这种情况下foreach()）。这个封闭序列化并发送给每个执行者。</p>
<p>发送给每个执行程序的闭包内的变量现在是副本，因此，当函数内引用计数器时foreach，它不再是驱动程序节点上的计数器。驱动程序节点的内存中还有一个计数器，但执行程序不再可见！执行者只能看到序列化闭包的副本。因此，计数器的最终值仍然是零，因为计数器上的所有操作都引用了序列化闭包内的值。</p>
<p>在本地模式下，在某些情况下，该foreach函数将在与驱动程序相同的JVM中实际执行，并将引用相同的原始计数器，并可能实际更新它。</p>
<p>为了确保在这些场景中明确定义的行为，应该使用一个Accumulator。Spark中的累加器专门用于提供一种在集群中的工作节点之间执行拆分时安全地更新变量的机制。本指南的“累加器”部分更详细地讨论了这些内容。</p>
<p>一般来说，闭包 - 像循环或本地定义的方法这样的构造不应该被用来改变一些全局状态。Spark并没有定义或保证对从封闭外引用的对象的突变行为。这样做的一些代码可能在本地模式下工作，但这是偶然的，这样的代码不会按预期在分布式模式下运行。如果需要全局聚合，请使用累加器。</p>
<h3><span id="打印rdd的元素">打印RDD的元素</span></h3><p>另一个常见的习惯是试图用rdd.foreach(println)or 打印RDD的元素rdd.map(println)。在一台机器上，这将产生预期的输出并打印所有RDD的元素。然而，在cluster模式下，stdout执行者所调用的输出现在是写给执行者的，stdout而不是驱动器上的，所以stdout驱动程序不会显示这些！要打印驱动程序中的所有元素，可以使用该collect()方法首先将RDD带到驱动程序节点：rdd.collect().foreach(println)。这可能会导致驱动程序内存不足，因为collect()将整个RDD提取到一台机器; 如果您只需要打印RDD的一些元素，则更安全的方法是使用take()：rdd.take(100).foreach(println)。</p>
<h2><span id="使用键值对">使用键值对</span></h2><p>虽然大多数Spark操作在包含任何类型对象的RDD上工作，但是一些特殊操作仅在键 - 值对的RDD上可用。最常见的是分布式的“随机”操作，如按键分组或聚合元素。</p>
<p>在Scala中，这些操作可以在包含Tuple2对象的RDD上自动使用 （语言中的内置元组，通过简单的书写创建(a, b)）。PairRDDFunctions类中提供了键值对操作， 该类会自动包装元组的RDD。</p>
<p>例如，以下代码使用reduceByKey键值对上的操作来计算文本中每行文本的出现次数：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> lines = sc.textFile(<span class="string">"data.txt"</span>)</span><br><span class="line"><span class="keyword">val</span> pairs = lines.map(s =&gt; (s, <span class="number">1</span>))</span><br><span class="line"><span class="keyword">val</span> counts = pairs.reduceByKey((a, b) =&gt; a + b)</span><br></pre></td></tr></table></figure>
<p>counts.sortByKey()例如，我们也可以按字母顺序对这些对进行排序，最后 counts.collect()把它们作为一个对象数组返回给驱动程序。</p>
<p>注意：在使用自定义对象作为键值对操作中的键时，必须确保自定义equals()方法附带匹配hashCode()方法。有关完整的详细信息，请参阅Object.hashCode（）文档中概述的合同。</p>
<h2><span id="transform">Transform</span></h2><p>下表列出了Spark支持的一些常见转换。有关详细信息，请参阅RDD API文档（Scala， Java， Python， R）和RDD函数doc（Scala， Java）。</p>
<ul>
<li>map（func）    通过函数func传递源的每个元素来形成一个新的分布式数据集。</li>
<li>filter（func）    通过选择func返回true 的源的元素返回一个新的数据集。</li>
<li>flatMap（func）    类似于map，但是每个输入项可以映射到0个或更多个输出项（所以func应该返回一个Seq而不是单个项）。</li>
<li>mapPartitions（func）    与map类似，但是在RDD的每个分区（块）上分别运行，所以当在T型RDD上运行时，func必须是Iterator <t> =&gt; Iterator <u>类型。</u></t></li>
<li>mapPartitionsWithIndex（func）    类似于mapPartitions，而且还提供FUNC与表示所述分区的索引的整数值，所以FUNC必须是类型（中间体，迭代器<t>）=&gt;的迭代器上类型T的RDD运行时<u></u></t></li>
<li>sample（与更换，分数，种子）    使用给定的随机数发生器种子对数据的一小部分进行采样，有或没有替换。</li>
<li>union（otherDataset）    返回包含源数据集中的元素和参数的联合的新数据集。</li>
<li>intersection（otherDataset）    返回一个新的RDD，其中包含源数据集中的元素和参数的交集。</li>
<li>distinct（[ numTasks ]））    返回包含源数据集的不同元素的新数据集。</li>
<li>groupByKey（[ numTasks ]）    当调用（K，V）对的数据集时，返回（K，Iterable <v>）对的数据集。<br>注意：如果您正在对每个密钥执行汇总（例如总计或平均），则使用reduceByKey或aggregateByKey将产生更好的性能。<br>注：默认情况下，输出中的并行级别取决于父RDD的分区数量。您可以传递可选numTasks参数来设置不同数量的任务。</v></li>
<li>reduceByKey（func，[ numTasks ]）    当调用（K，V）对的数据集时，返回（K，V）对的数据集，其中每个键的值使用给定的reduce函数func进行聚合，函数func必须是（V，V）=&gt; V.像in一样groupByKey，reduce任务的数量可以通过可选的第二个参数来配置。</li>
<li>aggregateByKey（zeroValue）（seqOp，combOp，[ numTasks ]）    当调用（K，V）对的数据集时，返回（K，U）对的数据集，其中使用给定的组合函数和中性的“零”值来汇总每个键的值。允许与输入值类型不同的聚合值类型，同时避免不必要的分配。像in一样groupByKey，reduce任务的数量可以通过可选的第二个参数来配置。</li>
<li>sortByKey（[ ascending ]，[ numTasks ]）    当调用K实现Ordered的（K，V）对的数据集时，按照布尔ascending参数中的指定，按照升序或降序返回按键排序的（K，V）对的数据集。</li>
<li>join（otherDataset，[ numTasks ]）    当（K，V）和（K，W）类型的数据集被调用时，返回（K，（V，W））对的每个键的所有元素对的数据集。外连接通过支持leftOuterJoin，rightOuterJoin和fullOuterJoin。</li>
<li>cogroup（otherDataset，[ numTasks ]）    当（K，V）和（K，W）类型的数据集被调用时，返回（K，（Iterable <v>，Iterable <w>））元组的数据集。这个操作也被称为groupWith。</w></v></li>
<li>cartesian（otherDataset）    当调用类型T和U的数据集时，返回（T，U）对（所有元素对）的数据集。</li>
<li>pipe（命令，[envVars]）    通过shell命令管理RDD的每个分区，例如Perl或bash脚本。RDD元素被写入进程的stdin，输出到stdout的行被作为字符串的RDD返回。</li>
<li>coalesce（numPartitions）    减少RDD中的分区数量为numPartitions。用于在过滤大型数据集后更高效地运行操作。</li>
<li>repartition（numPartitions）    随机调整RDD中的数据以创建更多或更少的分区并在其间进行平衡。这总是通过网络混洗所有数据。</li>
<li>repartitionAndSortWithinPartitions（partitioner）    根据给定的分区器对RDD进行重新分区，并在每个结果分区中按键分类记录。这比repartition在每个分区中调用然后排序更高效，因为它可以将排序推送到洗牌机器中。</li>
</ul>
<h2><span id="actions">Actions</span></h2><p>下表列出了Spark支持的一些常用操作。请参阅RDD API文档（Scala， Java， Python， R）</p>
<p>并配对RDD函数doc（Scala， Java）以获取详细信息。</p>
<p>行动    含义<br>减少（func）    使用函数func（它接受两个参数并返回一个）来聚合数据集的元素。该函数应该是可交换和关联的，以便它可以被正确地并行计算。<br>collect（）    在驱动程序中将数据集的所有元素作为数组返回。在过滤器或其他操作返回足够小的数据子集之后，这通常很有用。<br>count（）    返回数据集中元素的数量。<br>第一（）    返回数据集的第一个元素（类似于take（1））。<br>拿（n）    用数据集的前n个元素返回一个数组。<br>takeSample（withReplacement，num，[ seed ]）    返回一个阵列的随机样本NUM数据集的元素，具有或不具有取代，任选地预先指定的随机数发生器的种子。<br>takeOrdered（n，[订购]）    使用自然顺序或自定义比较器返回RDD 的前n个元素。<br>saveAsTextFile（路径）    将数据集的元素作为文本文件（或文本文件集）写入本地文件系统，HDFS或任何其他Hadoop支持的文件系统的给定目录中。Spark将在每个元素上调用toString将其转换为文件中的一行文本。<br>saveAsSequenceFile（路径）<br>（Java和Scala）    将数据集的元素作为Hadoop SequenceFile写入本地文件系统，HDFS或任何其他Hadoop支持的文件系统的给定路径中。这在实现Hadoop的Writable接口的键值对的RDD上是可用的。在Scala中，它也可用于可隐式转换为Writable的类型（Spark包含Int，Double，String等基本类型的转换）。<br>saveAsObjectFile（路径）<br>（Java和Scala）    使用Java序列化以简单的格式写入数据集的元素，然后可以使用Java序列化加载 SparkContext.objectFile()。<br>countByKey（）    仅适用于类型（K，V）的RDD。返回（K，Int）对的hashmap和每个键的计数。<br>foreach（func）    在数据集的每个元素上运行函数func。这通常用于副作用，如更新累加器或与外部存储系统交互。<br>注意：修改除“累加器”以外的变量foreach()可能会导致未定义的行为。请参阅了解更多细节。<br>Spark RDD API还公开了一些动作的异步版本，比如foreachAsyncfor foreach，它立即返回FutureAction给调用者，而不是完成动作时的阻塞。这可以用来管理或等待操作的异步执行。</p>
<h2><span id="shuffle-操作">shuffle 操作</span></h2><p>Spark中的某些操作会触发一个称为shuffle的事件。洗牌是Spark重新分配数据的机制，以便在不同分区之间进行分组。这通常涉及在执行者和机器之间复制数据，使得洗牌成为复杂而昂贵的操作。</p>
<h3><span id="背景">背景</span></h3><p>为了理解在洗牌过程中会发生什么，我们可以考虑reduceByKey操作的例子 。该reduceByKey操作将生成一个新的RDD，其中单个键的所有值都组合为一个元组 - 键和对与该键相关的所有值执行reduce函数的结果。面临的挑战是，并不是所有的单个密钥的值都必须位于同一个分区，甚至是同一个机器上，但是它们必须位于同一地点才能计算出结果。</p>
<p>在Spark中，数据通常不是跨分区分布，而是在特定操作的必要位置。在计算过程中，单个任务将在单个分区上运行 - 因此，要组织所有数据reduceByKey以执行单个reduce任务，Spark需要执行全部操作。它必须从所有分区中读取所有键的值，然后将各个分区上的值汇总在一起，以计算每个键的最终结果 - 这就是所谓的混洗。</p>
<p>虽然新洗牌数据的每个分区中的元素集合是确定性的，分区本身的排序也是确定性的，但这些元素的排序并不是这样。如果一个人在随机播放之后需要可预测的有序数据，那么可以使用：</p>
<p>mapPartitions 使用例如对每个分区进行排序， .sorted<br>repartitionAndSortWithinPartitions 在对分区进行有效分类的同时进行分区<br>sortBy 做一个全球有序的RDD<br>这可能会导致一个洗牌的操作包括重新分区一样操作 repartition和coalesce，ByKey”操作，比如（除计数）groupByKey，并reduceByKey和 参加操作，如cogroup和join。</p>
<h3><span id="性能影响">性能影响</span></h3><p>所述随机播放是昂贵的操作，因为它涉及的磁盘I / O，数据序列，和网络I / O。为了组织数据，Spark生成一组任务 - 映射任务来组织数据，以及一组reduce任务来聚合它。这个术语来自MapReduce，并不直接涉及到Spark map和reduce操作。</p>
<p>在内部，来自个别地图任务的结果被保存在内存中，直到它们不适合为止。然后，这些将根据目标分区进行排序并写入单个文件。在减少方面，任务读取相关的排序块。</p>
<p>某些随机操作会消耗大量的堆内存，因为它们使用内存中的数据结构来在传输之前或之后组织记录。具体而言， reduceByKey并aggregateByKey创建在地图上侧这样的结构，和’ByKey操作产生这些上减少侧。当数据不适合存储在内存中时，Spark会将这些表泄露到磁盘，导致额外的磁盘I / O开销和增加的垃圾回收。</p>
<p>Shuffle也会在磁盘上生成大量的中间文件。从Spark 1.3开始，这些文件将被保留，直到相应的RDD不再使用并被垃圾回收。这样做是为了在重新计算谱系时不需要重新创建洗牌文件。如果应用程序保留对这些RDD的引用，或者GC不经常引入，垃圾收集可能会在很长一段时间后才会发生。这意味着长时间运行的Spark作业可能会消耗大量的磁盘空间。临时存储目录spark.local.dir在配置Spark上下文时由配置参数指定 。</p>
<p>随机行为可以通过调整各种配置参数来调整。请参阅“ Spark配置指南 ”中的“Shuffle Behavior”部分。</p>
<h3><span id="rdd持久性">RDD持久性</span></h3><p>Spark中最重要的功能之一就是在内存中持续（或缓存）一个数据集。当持久化RDD时，每个节点存储它在内存中计算的所有分区，并在该数据集的其他操作（或从中派生的数据集）中重用它们。这使未来的行动更快（通常超过10倍）。缓存是迭代算法和快速交互式使用的关键工具。</p>
<p>你可以用一个persist()或者多个cache()方法来标记一个RDD 。第一次在动作中计算时，它将被保存在节点的内存中。Spark的缓存是容错的 - 如果RDD的任何分区丢失，它将自动使用最初创建它的转换重新计算。</p>
<p>另外，每个持久RDD可以使用不同的存储级别进行存储，例如，允许您将数据集保存在磁盘上，将其保存在内存中，但是作为序列化的Java对象（以节省空间）将其复制到节点上。这些级别通过传递一个 StorageLevel对象（Scala， Java， Python）来设置persist()。该cache()方法是使用默认存储级别的简写，它是StorageLevel.MEMORY_ONLY（将反序列化对象存储在内存中）。全套存储级别是：</p>
<p>存储级别    含义<br>MEMORY_ONLY    将RDD作为反序列化的Java对象存储在JVM中。如果RDD不适合内存，某些分区将不会被缓存，并且每次需要时都会重新进行计算。这是默认级别。<br>MEMORY_AND_DISK    将RDD作为反序列化的Java对象存储在JVM中。如果RDD不适合内存，请存储不适合磁盘的分区，并在需要时从中读取。<br>MEMORY_ONLY_SER<br>（Java和Scala）    将RDD存储为序列化的 Java对象（每个分区一个字节的数组）。这通常比反序列化的对象更节省空间，特别是在使用 快速序列化器的情况下，但需要消耗更多的CPU资源。<br>MEMORY_AND_DISK_SER<br>（Java和Scala）    与MEMORY_ONLY_SER类似，但是将不适合内存的分区溢出到磁盘，而不是每次需要时重新计算它们。<br>DISK_ONLY    将RDD分区仅存储在磁盘上。<br>MEMORY_ONLY_2，MEMORY_AND_DISK_2等    与上面的级别相同，但复制两个群集节点上的每个分区。<br>OFF_HEAP（实验）    与MEMORY_ONLY_SER类似，但将数据存储在 堆内存中。这需要启用堆堆内存。<br>注意： 在Python中，存储对象将始终与Pickle库序列化，所以选择序列化级别无关紧要。Python中的可用存储级别包括MEMORY_ONLY，MEMORY_ONLY_2， MEMORY_AND_DISK，MEMORY_AND_DISK_2，DISK_ONLY，和DISK_ONLY_2。</p>
<p>reduceByKey即使没有用户调用，Spark也会自动保留一些中间数据（例如）persist。这样做是为了避免在洗牌过程中节点失败时重新输入整个输入。我们仍然建议用户调用persist所产生的RDD，如果他们打算重用它。</p>
<h3><span id="选择哪个存储级别">选择哪个存储级别？</span></h3><p>Spark的存储级别旨在提供内存使用和CPU效率之间的不同折衷。我们建议通过以下过程来选择一个：</p>
<p>如果你的RDD适合默认的存储级别（MEMORY_ONLY），那就留下来吧。这是CPU效率最高的选项，允许RDD上的操作尽可能快地运行。</p>
<p>如果没有，尝试使用MEMORY_ONLY_SER和选择一个快速的序列化库，使对象更加节省空间，但仍然相当快地访问。（Java和Scala）</p>
<p>除非计算您的数据集的函数很昂贵，否则他们会过滤大量数据，否则不要泄露到磁盘。否则，重新计算分区可能与从磁盘读取分区一样快。</p>
<p>如果要快速恢复故障，请使用复制的存储级别（例如，如果使用Spark来为Web应用程序提供请求）。所有的存储级别通过重新计算丢失的数据来提供完整的容错能力，但是复制的容量可以让您继续在RDD上运行任务，而无需等待重新计算丢失的分区。</p>
<h3><span id="删除数据">删除数据</span></h3><p>Spark会自动监视每个节点上的高速缓存使用情况，并以最近最少使用（LRU）方式删除旧的数据分区。如果您想要手动删除RDD，而不是等待其从缓存中删除，请使用该RDD.unpersist()方法。</p>
<h2><span id="共享变量">共享变量</span></h2><p>通常，当传递给Spark操作（如mapor reduce）的函数在远程集群节点上执行时，它将在函数中使用的所有变量的单独副本上工作。这些变量被复制到每台机器上，远程机器上的变量没有更新传播到驱动程序。支持通用的，可读写的共享变量将是低效的。但是，Spark 为两种常见使用模式提供了两种有限类型的共享变量：广播变量和累加器。</p>
<h3><span id="广播变量">广播变量</span></h3><p>广播变量允许程序员在每台机器上保存一个只读变量，而不是用任务发送一个只读变量的副本。例如，可以使用它们以有效的方式为每个节点提供大型输入数据集的副本。Spark还尝试使用高效的广播算法来分发广播变量，以降低通信成本。</p>
<p>Spark动作是通过一系列阶段执行的，由分散的“随机”操作分开。Spark会自动播放每个阶段中任务所需的通用数据。以这种方式广播的数据以序列化形式缓存，并在运行每个任务之前反序列化。这意味着只有跨多个阶段的任务需要相同的数据或以反序列化的形式缓存数据时，显式创建广播变量才是有用的。</p>
<p>广播变量是v通过调用从一个变量创建的SparkContext.broadcast(v)。广播变量是一个包装器v，它的值可以通过调用value 方法来访问。下面的代码显示了这一点：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; <span class="keyword">val</span> broadcastVar = sc.broadcast(<span class="type">Array</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>))</span><br><span class="line">broadcastVar: org.apache.spark.broadcast.<span class="type">Broadcast</span>[<span class="type">Array</span>[<span class="type">Int</span>]] = <span class="type">Broadcast</span>(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">scala&gt; broadcastVar.value</span><br><span class="line">res0: <span class="type">Array</span>[<span class="type">Int</span>] = <span class="type">Array</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br></pre></td></tr></table></figure>
<p>在创建广播变量之后，应该使用它来代替v群集上运行的任何函数中的值，以便v不会多次将其发送到节点。另外，v为了确保所有节点获得广播变量的相同值（例如，如果变量稍后被运送到新节点），该对象 在广播之后不应被修改。</p>
<h3><span id="累加器">累加器</span></h3><p>累加器是只能通过关联和交换操作“添加”的变量，因此可以并行有效地支持。它们可以用来实现计数器（如在MapReduce中）或者和。Spark本身支持数字类型的累加器，程序员可以添加对新类型的支持。</p>
<p>作为用户，您可以创建名称或未命名的累加器。如下图所示，一个命名的累加器（在这种情况下counter）将显示在Web用户界面中修改该累加器的阶段。Spark显示由“任务”表中的任务修改的每个累加器的值。</p>
<p><img src="https://spark.apache.org/docs/latest/img/spark-webui-accumulators.png" alt="Spark UI中的累加器"></p>
<p>跟踪用户界面中的累加器对于理解运行阶段的进度非常有用（注意：Python尚不支持）。</p>
<p>数值累加器可以通过调用SparkContext.longAccumulator()或SparkContext.doubleAccumulator() 累加Long或Double类型的值来创建。在集群上运行的任务可以使用该add方法添加到集群中。但是，他们无法读懂它的价值。只有驱动程序可以使用其value方法读取累加器的值。</p>
<p>下面的代码显示了一个累加器被用来加总一个数组的元素：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; <span class="keyword">val</span> accum = sc.longAccumulator(<span class="string">"My Accumulator"</span>)</span><br><span class="line">accum: org.apache.spark.util.<span class="type">LongAccumulator</span> = <span class="type">LongAccumulator</span>(id: <span class="number">0</span>, name: <span class="type">Some</span>(<span class="type">My</span> <span class="type">Accumulator</span>), value: <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">scala&gt; sc.parallelize(<span class="type">Array</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>)).foreach(x =&gt; accum.add(x))</span><br><span class="line">...</span><br><span class="line"><span class="number">10</span>/<span class="number">09</span>/<span class="number">29</span> <span class="number">18</span>:<span class="number">41</span>:<span class="number">08</span> <span class="type">INFO</span> <span class="type">SparkContext</span>: <span class="type">Tasks</span> finished in <span class="number">0.317106</span> s</span><br><span class="line"></span><br><span class="line">scala&gt; accum.value</span><br><span class="line">res2: <span class="type">Long</span> = <span class="number">10</span></span><br></pre></td></tr></table></figure>
<p>虽然这段代码使用了对Long类型的累加器的内置支持，程序员也可以通过继承AccumulatorV2来创建它们自己的类型。AccumulatorV2抽象类有几个方法必须覆盖：reset将累加器重置为零，add向累加器中添加另一个值，merge将另一个相同类型的累加器合并到该累加器中 。其他必须被覆盖的方法包含在API文档中。例如，假设我们有一个MyVector表示数学向量的类，我们可以这样写：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">VectorAccumulatorV2</span> <span class="keyword">extends</span> <span class="title">AccumulatorV2</span>[<span class="type">MyVector</span>, <span class="type">MyVector</span>] </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">val</span> myVector: <span class="type">MyVector</span> = <span class="type">MyVector</span>.createZeroVector</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">reset</span></span>(): <span class="type">Unit</span> = &#123;</span><br><span class="line">    myVector.reset()</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">add</span></span>(v: <span class="type">MyVector</span>): <span class="type">Unit</span> = &#123;</span><br><span class="line">    myVector.add(v)</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Then, create an Accumulator of this type:</span></span><br><span class="line"><span class="keyword">val</span> myVectorAcc = <span class="keyword">new</span> <span class="type">VectorAccumulatorV2</span></span><br><span class="line"><span class="comment">// Then, register it into spark context:</span></span><br><span class="line">sc.register(myVectorAcc, <span class="string">"MyVectorAcc1"</span>)</span><br></pre></td></tr></table></figure>
<p>请注意，当程序员定义自己的AccumulatorV2类型时，结果类型可能与添加元素的类型不同。</p>
<p>对于仅在动作内执行的累加器更新，Spark保证每个任务对累加器的更新只应用一次，即重新启动的任务不会更新值。在转换中，用户应该意识到，如果任务或作业阶段被重新执行，每个任务的更新可能会被应用多次。</p>
<p>累加器不会改变Spark的懒惰评估模型。如果它们在RDD上的操作中被更新，则其值仅在RDD作为动作的一部分计算之后才被更新。因此，累加器更新不能保证在像lazy这样的惰性转换中执行map()。下面的代码片段演示了这个属性：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> accum = sc.longAccumulator</span><br><span class="line">data.map &#123; x =&gt; accum.add(x); x &#125;</span><br><span class="line"><span class="comment">// Here, accum is still 0 because no actions have caused the map operation to be computed.</span></span><br></pre></td></tr></table></figure>
<h2><span id="部署到群集">部署到群集</span></h2><p>在提交申请指南介绍了如何提交申请到集群。简而言之，一旦将应用程序打包为JAR（Java / Scala）或一组.py或多个.zip文件（Python），bin/spark-submit脚本就可以将其提交给任何受支持的集群管理器。</p>
<h2><span id="从java-scala启动spark作业">从Java / Scala启动Spark作业</span></h2><p>该org.apache.spark.launcher 包提供类推出的Spark作为工作使用一个简单的Java API的子进程。</p>
<h2><span id="单元测试">单元测试</span></h2><p>Spark对任何流行的单元测试框架的单元测试都很友好。只需SparkContext在您的测试中创建一个主URL设置为local，运行您的操作，然后打电话SparkContext.stop()把它撕下来。确保停止finally块或测试框架tearDown方法中的上下文，因为Spark不支持在同一个程序中同时运行的两个上下文。</p>
<h2><span id="接下来">接下来</span></h2><p>您可以在Spark网站上看到一些Spark程序示例。另外，Spark在examples目录（Scala， Java， Python， R）中包含了几个示例。您可以通过将类名传递给Spark bin/run-example脚本来运行Java和Scala示例; 例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./bin/run-example SparkPi</span><br></pre></td></tr></table></figure>
<p>对于Python示例，请spark-submit改为使用：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./bin/spark-submit examples/src/main/python/pi.py</span><br></pre></td></tr></table></figure></p>
<p>对于R示例，请spark-submit改用：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./bin/spark-submit examples/src/main/r/dataframe.R</span><br></pre></td></tr></table></figure></p>
<p>有关优化程序的帮助，配置和 调优指南提供有关最佳实践的信息。它们对于确保您的数据以高效格式存储在内存中尤为重要。有关部署的帮助，群集模式概述描述了分布式操作中涉及的组件以及支持的群集管理器。</p>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/spark/">spark</a>
</div>


</div>




<div class="comments-count">
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2018/01/12/spark-tutorial/" title="spark 官方教程" itemprop="url">spark 官方教程</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="zhizi" target="_blank" itemprop="author">zhizi</a>
		
  <p class="article-time">
    <time datetime="2018-01-12T14:08:50.000Z" itemprop="datePublished"> Published 2018-01-12</time>
    
  </p>
</header>
    <div class="article-content">
        
        <p>本教程提供了使用Spark的快速入门。我们将首先通过Spark的交互式shell（Python或Scala）介绍API，然后展示如何用Java，Scala和Python编写应用程序。</p>
<p>要遵循本指南，请先从Spark网站下载Spark的打包版本 。由于我们不会使用HDFS，因此您可以下载任何版本的Hadoop的软件包。</p>
<p>请注意，在Spark 2.0之前，Spark的主要编程接口是弹性分布式数据集（RDD）。在Spark 2.0之后，RDD被数据集取代，数据集类似于RDD类型强大的类型，但在引擎盖下有更丰富的优化。RDD接口仍然受支持，您可以在RDD编程指南中获得更完整的参考资料。但是，我们强烈建议您切换到使用数据集，这比RDD具有更好的性能。请参阅SQL编程指南以获取有关数据集的更多信息。</p>
<h2><span id="使用spark-shell进行交互式分析">使用Spark Shell进行交互式分析</span></h2><h3><span id="基本">基本</span></h3><p>Spark的shell提供了一个学习API的简单方法，也是一个交互式分析数据的强大工具。它可以在Scala（在Java VM上运行，因此是使用现有Java库的好方法）或Python中提供。通过在Spark目录中运行以下代码来启动它：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./bin/spark-shell</span><br></pre></td></tr></table></figure>
<p>Spark的主要抽象是一个名为Dataset的分布式集合。数据集可以通过Hadoop InputFormats（例如HDFS文件）或通过转换其他数据集来创建。让我们从Spark源目录中的README文件的文本中创建一个新的数据集：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; <span class="keyword">val</span> textFile = spark.read.textFile(<span class="string">"README.md"</span>)</span><br><span class="line">textFile: org.apache.spark.sql.<span class="type">Dataset</span>[<span class="type">String</span>] = [value: string]</span><br></pre></td></tr></table></figure>
<p>您可以直接从数据集中获取值，通过调用某些操作，或者转换数据集来获取新的值。有关更多详细信息，请阅读API文档。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; textFile.count() <span class="comment">// Number of items in this Dataset</span></span><br><span class="line">res0: <span class="type">Long</span> = <span class="number">126</span> <span class="comment">// May be different from yours as README.md will change over time, similar to other outputs</span></span><br><span class="line"></span><br><span class="line">scala&gt; textFile.first() <span class="comment">// First item in this Dataset</span></span><br><span class="line">res1: <span class="type">String</span> = # <span class="type">Apache</span> <span class="type">Spark</span></span><br></pre></td></tr></table></figure>
<p>现在让我们转换这个数据集到一个新的。我们调用filter返回一个新的数据集与文件中的项目的一个子集。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; <span class="keyword">val</span> linesWithSpark = textFile.filter(line =&gt; line.contains(<span class="string">"Spark"</span>))</span><br><span class="line">linesWithSpark: org.apache.spark.sql.<span class="type">Dataset</span>[<span class="type">String</span>] = [value: string]</span><br></pre></td></tr></table></figure>
<p>我们可以把变革和行动联系在一起：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; textFile.filter(line =&gt; line.contains(<span class="string">"Spark"</span>)).count() <span class="comment">// How many lines contain "Spark"?</span></span><br><span class="line">res3: <span class="type">Long</span> = <span class="number">15</span></span><br></pre></td></tr></table></figure>
<h3><span id="更多关于数据集操作">更多关于数据集操作</span></h3><p>数据集操作和转换可用于更复杂的计算。比方说，我们想找到最多的单词：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; textFile.map(line =&gt; line.split(<span class="string">" "</span>).size).reduce((a, b) =&gt; <span class="keyword">if</span> (a &gt; b) a <span class="keyword">else</span> b)</span><br><span class="line">res4: <span class="type">Long</span> = <span class="number">15</span></span><br></pre></td></tr></table></figure>
<p>这首先将一行映射到一个整数值，创建一个新的数据集。reduce在该数据集上调用以查找最大的字数。参数map和reduce是Scala函数文字（闭包），并可以使用任何语言功能或Scala / Java库。例如，我们可以轻松地调用其他地方声明的函数。我们将使用Math.max()函数来使这个代码更容易理解：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; <span class="keyword">import</span> java.lang.<span class="type">Math</span></span><br><span class="line"><span class="keyword">import</span> java.lang.<span class="type">Math</span></span><br><span class="line"></span><br><span class="line">scala&gt; textFile.map(line =&gt; line.split(<span class="string">" "</span>).size).reduce((a, b) =&gt; <span class="type">Math</span>.max(a, b))</span><br><span class="line">res5: <span class="type">Int</span> = <span class="number">15</span></span><br></pre></td></tr></table></figure>
<p>一种常见的数据流模式是MapReduce，正如Hadoop所普及的。Spark可以轻松实现MapReduce流程：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; <span class="keyword">val</span> wordCounts = textFile.flatMap(line =&gt; line.split(<span class="string">" "</span>)).groupByKey(identity).count()</span><br><span class="line">wordCounts: org.apache.spark.sql.<span class="type">Dataset</span>[(<span class="type">String</span>, <span class="type">Long</span>)] = [value: string, count(<span class="number">1</span>): bigint]</span><br></pre></td></tr></table></figure>
<p>在这里，我们要求flatMap将一行数据集转换为一个数据集的单词，然后组合groupByKey并count计算文件中每个单词的数量作为（String，Long）对的数据集。为了收集我们shell中的字数，我们可以调用collect：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; wordCounts.collect()</span><br><span class="line">res6: <span class="type">Array</span>[(<span class="type">String</span>, <span class="type">Int</span>)] = <span class="type">Array</span>((means,<span class="number">1</span>), (under,<span class="number">2</span>), (<span class="keyword">this</span>,<span class="number">3</span>), (<span class="type">Because</span>,<span class="number">1</span>), (<span class="type">Python</span>,<span class="number">2</span>), (agree,<span class="number">1</span>), (cluster.,<span class="number">1</span>), ...)</span><br></pre></td></tr></table></figure>
<h3><span id="缓存">缓存</span></h3><p>Spark还支持将数据集提取到集群范围内的内存缓存中。当重复访问数据时，如查询小的“热”数据集或运行迭代算法（如PageRank）时，这非常有用。作为一个简单的例子，让我们标记我们的linesWithSpark数据集被缓存：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; linesWithSpark.cache()</span><br><span class="line">res7: linesWithSpark.<span class="keyword">type</span> = [value: string]</span><br><span class="line"></span><br><span class="line">scala&gt; linesWithSpark.count()</span><br><span class="line">res8: <span class="type">Long</span> = <span class="number">15</span></span><br><span class="line"></span><br><span class="line">scala&gt; linesWithSpark.count()</span><br><span class="line">res9: <span class="type">Long</span> = <span class="number">15</span></span><br></pre></td></tr></table></figure>
<p>使用Spark探索和缓存100行文本文件似乎很愚蠢。有趣的部分是这些相同的函数可以用在非常大的数据集上，即使它们被划分为数十或数百个节点。您也可以bin/spark-shell按照RDD编程指南中的描述，通过连接到集群来交互地完成此操作。</p>
<h2><span id="自包含的应用程序">自包含的应用程序</span></h2><p>假设我们希望使用Spark API编写一个自包含的应用程序。我们将通过一个简单的应用程序在Scala（与SBT），Java（与Maven）和Python（PIP）。</p>
<p>我们将在Scala中创建一个非常简单的Spark应用程序 - 这么简单，事实上，它被命名为SimpleApp.scala：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* SimpleApp.scala */</span></span><br><span class="line"><span class="keyword">import</span> org.apache.spark.sql.<span class="type">SparkSession</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">SimpleApp</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]) &#123;</span><br><span class="line">    <span class="keyword">val</span> logFile = <span class="string">"YOUR_SPARK_HOME/README.md"</span> <span class="comment">// Should be some file on your system</span></span><br><span class="line">    <span class="keyword">val</span> spark = <span class="type">SparkSession</span>.builder.appName(<span class="string">"Simple Application"</span>).getOrCreate()</span><br><span class="line">    <span class="keyword">val</span> logData = spark.read.textFile(logFile).cache()</span><br><span class="line">    <span class="keyword">val</span> numAs = logData.filter(line =&gt; line.contains(<span class="string">"a"</span>)).count()</span><br><span class="line">    <span class="keyword">val</span> numBs = logData.filter(line =&gt; line.contains(<span class="string">"b"</span>)).count()</span><br><span class="line">    println(<span class="string">s"Lines with a: <span class="subst">$numAs</span>, Lines with b: <span class="subst">$numBs</span>"</span>)</span><br><span class="line">    spark.stop()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>请注意，应用程序应该定义一个main()方法而不是扩展scala.App。子类scala.App可能无法正常工作。</p>
<p>这个程序只是计算Spark自述文件中包含’a’的行数和包含’b’的数字。请注意，您需要将YOUR_SPARK_HOME替换为安装Spark的位置。与之前使用Spark shell初始化自己的SparkSession的例子不同，我们初始化一个SparkSession作为程序的一部分。</p>
<p>我们调用SparkSession.builder构造[[SparkSession]]，然后设置应用程序名称，最后调用getOrCreate获取[[SparkSession]]实例。</p>
<p>我们的应用程序依赖于Spark API，所以我们还将包含一个sbt配置文件 build.sbt，它解释了Spark是一个依赖项。该文件还添加了Spark所依赖的存储库：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">name := &quot;Simple Project&quot;</span><br><span class="line"></span><br><span class="line">version := &quot;1.0&quot;</span><br><span class="line"></span><br><span class="line">scalaVersion := &quot;2.11.8&quot;</span><br><span class="line"></span><br><span class="line">libraryDependencies += &quot;org.apache.spark&quot; %% &quot;spark-sql&quot; % &quot;2.2.1&quot;</span><br></pre></td></tr></table></figure>
<p>对于SBT正常工作，我们需要布局SimpleApp.scala并build.sbt 根据典型的目录结构。一旦到位，我们可以创建一个包含应用程序代码的JAR包，然后使用spark-submit脚本来运行我们的程序。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"># Your directory layout should look like this</span><br><span class="line">$ find .</span><br><span class="line">.</span><br><span class="line">./build.sbt</span><br><span class="line">./src</span><br><span class="line">./src/main</span><br><span class="line">./src/main/scala</span><br><span class="line">./src/main/scala/SimpleApp.scala</span><br><span class="line"></span><br><span class="line"># Package a jar containing your application</span><br><span class="line">$ sbt package</span><br><span class="line">...</span><br><span class="line">[info] Packaging &#123;..&#125;/&#123;..&#125;/target/scala-2.11/simple-project_2.11-1.0.jar</span><br><span class="line"></span><br><span class="line"># Use spark-submit to run your application</span><br><span class="line">$ YOUR_SPARK_HOME/bin/spark-submit \</span><br><span class="line">  --class &quot;SimpleApp&quot; \</span><br><span class="line">  --master local[4] \</span><br><span class="line">  target/scala-2.11/simple-project_2.11-1.0.jar</span><br><span class="line">...</span><br><span class="line">Lines with a: 46, Lines with b: 23</span><br></pre></td></tr></table></figure>
<h2><span id="更多">更多</span></h2><p>祝贺您运行您的第一个Spark应用程序！</p>
<p>有关API的深入概述，请从RDD编程指南和SQL编程指南开始，或者参阅其他组件的“编程指南”菜单。<br>要在群集上运行应用程序，请转到部署概述。<br>最后，Spark在examples目录（Scala， Java， Python， R）中包含了几个样本。你可以运行它们如下：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># <span class="type">For</span> <span class="type">Scala</span> and <span class="type">Java</span>, use run-example:</span><br><span class="line">./bin/run-example <span class="type">SparkPi</span></span><br><span class="line"></span><br><span class="line"># <span class="type">For</span> <span class="type">Python</span> examples, use spark-submit directly:</span><br><span class="line">./bin/spark-submit examples/src/main/python/pi.py</span><br><span class="line"></span><br><span class="line"># <span class="type">For</span> <span class="type">R</span> examples, use spark-submit directly:</span><br><span class="line">./bin/spark-submit examples/src/main/r/dataframe.<span class="type">R</span></span><br></pre></td></tr></table></figure>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/spark/">spark</a>
</div>


</div>




<div class="comments-count">
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2018/01/12/python-metaclass/" title="python metaclass" itemprop="url">python metaclass</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="zhizi" target="_blank" itemprop="author">zhizi</a>
		
  <p class="article-time">
    <time datetime="2018-01-12T13:49:19.000Z" itemprop="datePublished"> Published 2018-01-12</time>
    
  </p>
</header>
    <div class="article-content">
        
        <h2><span id="简介">简介</span></h2><p>元类是一个类的类。就像一个类定义一个类的实例的行为一样，元类定义了一个类的行为。一个类是一个元类的一个实例。</p>
<p><img src="https://i.stack.imgur.com/QQ0OK.png" alt="元类图"></p>
<p>在Python中，你可以为元类使用任意的可调参数，但更有用的方法实际上是将它自己变成一个实际的类。type是Python中常用的元类。type它本身就是一个类，而且是它自己的类型。你将无法在Python中重新创建像type一样的东西，但是Python会作弊。要在Python中创建自己的元类，你只要type的子类。</p>
<p>元类最常用作类工厂。就像通过调用类创建类的实例一样，Python通过调用元类来创建一个新类（当它执行’class’语句时）。结合常规<strong>init</strong>和<strong>new</strong>方法，元类因此允许你在创建一个类时做“额外的事情”，比如用一些注册表来注册新类，或者甚至用其他东西来完全替换类。</p>
<p>当class语句被执行时，Python首先class以正常的代码块的形式执行语句的主体。由此产生的命名空间（一个字典）保存待分类的属性。元类是通过查看将被类（元类继承的）的基类，要被类<strong>metaclass</strong>（如果有的话）或<strong>metaclass</strong>全局变量的属性来确定的。元类然后调用类的名称，基类和属性来实例化它。</p>
<p>然而，元类实际上定义了一个类的类型，而不仅仅是一个工厂，所以你可以做更多的事情。例如，您可以在元类上定义常规方法。这些元类方法就像类方法，因为它们可以在没有实例的情况下在类上调用，但是它们也不像类方法，因为它们不能在类的实例上调用。type.<strong>subclasses</strong>()是type元类的一个方法的一个例子。您还可以定义正常的“魔力”的方法，如<strong>add</strong>，<strong>iter</strong>和<strong>getattr</strong>，执行或更改类的行为。</p>
<p>以下是一些小部分的汇总示例：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">make_hook</span><span class="params">(f)</span>:</span></span><br><span class="line">    <span class="string">"""Decorator to turn 'foo' method into '__foo__'"""</span></span><br><span class="line">    f.is_hook = <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> f</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyType</span><span class="params">(type)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__new__</span><span class="params">(cls, name, bases, attrs)</span>:</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> name.startswith(<span class="string">'None'</span>):</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">None</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># Go over attributes and see if they should be renamed.</span></span><br><span class="line">        newattrs = &#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> attrname, attrvalue <span class="keyword">in</span> attrs.iteritems():</span><br><span class="line">            <span class="keyword">if</span> getattr(attrvalue, <span class="string">'is_hook'</span>, <span class="number">0</span>):</span><br><span class="line">                newattrs[<span class="string">'__%s__'</span> % attrname] = attrvalue</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                newattrs[attrname] = attrvalue</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> super(MyType, cls).__new__(cls, name, bases, newattrs)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name, bases, attrs)</span>:</span></span><br><span class="line">        super(MyType, self).__init__(name, bases, attrs)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># classregistry.register(self, self.interfaces)</span></span><br><span class="line">        <span class="keyword">print</span> <span class="string">"Would register class %s now."</span> % self</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__add__</span><span class="params">(self, other)</span>:</span></span><br><span class="line">        <span class="class"><span class="keyword">class</span> <span class="title">AutoClass</span><span class="params">(self, other)</span>:</span></span><br><span class="line">            <span class="keyword">pass</span></span><br><span class="line">        <span class="keyword">return</span> AutoClass</span><br><span class="line">        <span class="comment"># Alternatively, to autogenerate the classname as well as the class:</span></span><br><span class="line">        <span class="comment"># return type(self.__name__ + other.__name__, (self, other), &#123;&#125;)</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">unregister</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="comment"># classregistry.unregister(self)</span></span><br><span class="line">        <span class="keyword">print</span> <span class="string">"Would unregister class %s now."</span> % self</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyObject</span>:</span></span><br><span class="line">    __metaclass__ = MyType</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NoneSample</span><span class="params">(MyObject)</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Will print "NoneType None"</span></span><br><span class="line"><span class="keyword">print</span> type(NoneSample), repr(NoneSample)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Example</span><span class="params">(MyObject)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, value)</span>:</span></span><br><span class="line">        self.value = value</span><br><span class="line"><span class="meta">    @make_hook</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">add</span><span class="params">(self, other)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.__class__(self.value + other.value)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Will unregister the class</span></span><br><span class="line">Example.unregister()</span><br><span class="line"></span><br><span class="line">inst = Example(<span class="number">10</span>)</span><br><span class="line"><span class="comment"># Will fail with an AttributeError</span></span><br><span class="line"><span class="comment">#inst.unregister()</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> inst + inst</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Sibling</span><span class="params">(MyObject)</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">ExampleSibling = Example + Sibling</span><br><span class="line"><span class="comment"># ExampleSibling is now a subclass of both Example and Sibling (with no</span></span><br><span class="line"><span class="comment"># content of its own) although it will believe it's called 'AutoClass'</span></span><br><span class="line"><span class="keyword">print</span> ExampleSibling</span><br><span class="line"><span class="keyword">print</span> ExampleSibling.__mro__</span><br></pre></td></tr></table></figure>
<h2><span id="类作为对象">类作为对象</span></h2><p>在理解元类之前，你需要掌握Python中的类。而且Python从Smalltalk语言中借用了一个非常奇怪的概念。</p>
<p>在大多数语言中，类只是描述如何生成对象的代码段。在Python中也是如此：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">ObjectCreator</span><span class="params">(object)</span>:</span></span><br><span class="line"><span class="meta">... </span>      <span class="keyword">pass</span></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>my_object = ObjectCreator()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(my_object)</span><br><span class="line">&lt;__main__.ObjectCreator object at <span class="number">0x8974f2c</span>&gt;</span><br></pre></td></tr></table></figure>
<p>但是类不仅仅是Python。类也是对象。</p>
<p>只要你使用关键字class，Python就执行它并创建一个OBJECT。指令</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">ObjectCreator</span><span class="params">(object)</span>:</span></span><br><span class="line"><span class="meta">... </span>      <span class="keyword">pass</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>在内存中创建名为“ObjectCreator”的对象。</p>
<p>这个对象（类）本身能够创建对象（实例），这就是为什么它是一个类。</p>
<p>但是，这仍然是一个客体，因此：</p>
<p>你可以把它分配给一个变量<br>你可以复制它<br>你可以添加属性<br>您可以将其作为函数参数传递<br>例如：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(ObjectCreator) <span class="comment"># you can print a class because it's an object</span></span><br><span class="line">&lt;<span class="class"><span class="keyword">class</span> '<span class="title">__main__</span>.<span class="title">ObjectCreator</span>'&gt;</span></span><br><span class="line"><span class="class">&gt;&gt;&gt; <span class="title">def</span> <span class="title">echo</span><span class="params">(o)</span>:</span></span><br><span class="line"><span class="meta">... </span>      print(o)</span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>echo(ObjectCreator) <span class="comment"># you can pass a class as a parameter</span></span><br><span class="line">&lt;<span class="class"><span class="keyword">class</span> '<span class="title">__main__</span>.<span class="title">ObjectCreator</span>'&gt;</span></span><br><span class="line"><span class="class">&gt;&gt;&gt; <span class="title">print</span><span class="params">(hasattr<span class="params">(ObjectCreator, <span class="string">'new_attribute'</span>)</span>)</span></span></span><br><span class="line"><span class="class"><span class="title">False</span></span></span><br><span class="line">&gt;&gt;&gt; ObjectCreator.new_attribute = 'foo' # you can add attributes to a class</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(hasattr(ObjectCreator, <span class="string">'new_attribute'</span>))</span><br><span class="line"><span class="keyword">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(ObjectCreator.new_attribute)</span><br><span class="line">foo</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>ObjectCreatorMirror = ObjectCreator <span class="comment"># you can assign a class to a variable</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(ObjectCreatorMirror.new_attribute)</span><br><span class="line">foo</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(ObjectCreatorMirror())</span><br><span class="line">&lt;__main__.ObjectCreator object at <span class="number">0x8997b4c</span>&gt;</span><br></pre></td></tr></table></figure>
<h2><span id="动态创建类">动态创建类</span></h2><p>由于类是对象，因此可以像任何对象一样快速创建它们。</p>
<p>首先，您可以使用class以下方法在函数中创建一个类：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">choose_class</span><span class="params">(name)</span>:</span></span><br><span class="line"><span class="meta">... </span>    <span class="keyword">if</span> name == <span class="string">'foo'</span>:</span><br><span class="line"><span class="meta">... </span>        <span class="class"><span class="keyword">class</span> <span class="title">Foo</span><span class="params">(object)</span>:</span></span><br><span class="line"><span class="meta">... </span>            <span class="keyword">pass</span></span><br><span class="line"><span class="meta">... </span>        <span class="keyword">return</span> Foo <span class="comment"># return the class, not an instance</span></span><br><span class="line"><span class="meta">... </span>    <span class="keyword">else</span>:</span><br><span class="line"><span class="meta">... </span>        <span class="class"><span class="keyword">class</span> <span class="title">Bar</span><span class="params">(object)</span>:</span></span><br><span class="line"><span class="meta">... </span>            <span class="keyword">pass</span></span><br><span class="line"><span class="meta">... </span>        <span class="keyword">return</span> Bar</span><br><span class="line"><span class="meta">... </span>    </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>MyClass = choose_class(<span class="string">'foo'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(MyClass) <span class="comment"># the function returns a class, not an instance</span></span><br><span class="line">&lt;<span class="class"><span class="keyword">class</span> '<span class="title">__main__</span>.<span class="title">Foo</span>'&gt;</span></span><br><span class="line"><span class="class">&gt;&gt;&gt; <span class="title">print</span><span class="params">(MyClass<span class="params">()</span>)</span> # <span class="title">you</span> <span class="title">can</span> <span class="title">create</span> <span class="title">an</span> <span class="title">object</span> <span class="title">from</span> <span class="title">this</span> <span class="title">class</span></span></span><br><span class="line"><span class="class">&lt;<span class="title">__main__</span>.<span class="title">Foo</span> <span class="title">object</span> <span class="title">at</span> 0<span class="title">x89c6d4c</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>但是它不是那么有活力，因为你还得自己写全班。</p>
<p>由于类是对象，它们必须由某种东西产生。</p>
<p>当你使用class关键字时，Python会自动创建这个对象。但是与Python中的大多数事情一样，它给了你一个手动的方法。</p>
<p>记得功能type？良好的旧功能，让你知道什么类型的对象是：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(type(<span class="number">1</span>))</span><br><span class="line">&lt;type <span class="string">'int'</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(type(<span class="string">"1"</span>))</span><br><span class="line">&lt;type <span class="string">'str'</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(type(ObjectCreator))</span><br><span class="line">&lt;type <span class="string">'type'</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(type(ObjectCreator()))</span><br><span class="line">&lt;<span class="class"><span class="keyword">class</span> '<span class="title">__main__</span>.<span class="title">ObjectCreator</span>'&gt;</span></span><br></pre></td></tr></table></figure>
<p>那么，type有一个完全不同的能力，它也可以在飞行中创建类。type可以把一个类的描述作为参数，并返回一个类。</p>
<p>（我知道，根据你传递给它的参数，相同的函数可能有两种完全不同的用法，这很愚蠢，这是由于Python中的向后兼容性问题）</p>
<p>type 这样工作：</p>
<p>type(name of the class,<br>     tuple of the parent class (for inheritance, can be empty),<br>     dictionary containing attributes names and values)<br>例如：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">MyShinyClass</span><span class="params">(object)</span>:</span></span><br><span class="line"><span class="meta">... </span>      <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>
<p>可以这样手动创建：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>MyShinyClass = type(<span class="string">'MyShinyClass'</span>, (), &#123;&#125;) <span class="comment"># returns a class object</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(MyShinyClass)</span><br><span class="line">&lt;<span class="class"><span class="keyword">class</span> '<span class="title">__main__</span>.<span class="title">MyShinyClass</span>'&gt;</span></span><br><span class="line"><span class="class">&gt;&gt;&gt; <span class="title">print</span><span class="params">(MyShinyClass<span class="params">()</span>)</span> # <span class="title">create</span> <span class="title">an</span> <span class="title">instance</span> <span class="title">with</span> <span class="title">the</span> <span class="title">class</span></span></span><br><span class="line"><span class="class">&lt;<span class="title">__main__</span>.<span class="title">MyShinyClass</span> <span class="title">object</span> <span class="title">at</span> 0<span class="title">x8997cec</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>你会注意到我们使用“MyShinyClass”作为类的名字，并作为变量来保存类的引用。他们可以是不同的，但没有理由使事情复杂化。</p>
<p>type接受一个字典来定义类的属性。所以：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">Foo</span><span class="params">(object)</span>:</span></span><br><span class="line"><span class="meta">... </span>      bar = <span class="keyword">True</span></span><br></pre></td></tr></table></figure>
<p>可以翻译成：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>Foo = type(<span class="string">'Foo'</span>, (), &#123;<span class="string">'bar'</span>:<span class="keyword">True</span>&#125;)</span><br></pre></td></tr></table></figure>
<p>并作为一个普通的类使用：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(Foo)</span><br><span class="line">&lt;<span class="class"><span class="keyword">class</span> '<span class="title">__main__</span>.<span class="title">Foo</span>'&gt;</span></span><br><span class="line"><span class="class">&gt;&gt;&gt; <span class="title">print</span><span class="params">(Foo.bar)</span></span></span><br><span class="line"><span class="class"><span class="title">True</span></span></span><br><span class="line">&gt;&gt;&gt; f = Foo()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(f)</span><br><span class="line">&lt;__main__.Foo object at <span class="number">0x8a9b84c</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(f.bar)</span><br><span class="line"><span class="keyword">True</span></span><br></pre></td></tr></table></figure>
<p>当然，你可以继承它，所以：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>  <span class="class"><span class="keyword">class</span> <span class="title">FooChild</span><span class="params">(Foo)</span>:</span></span><br><span class="line"><span class="meta">... </span>        <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>
<p>将会：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>FooChild = type(<span class="string">'FooChild'</span>, (Foo,), &#123;&#125;)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(FooChild)</span><br><span class="line">&lt;<span class="class"><span class="keyword">class</span> '<span class="title">__main__</span>.<span class="title">FooChild</span>'&gt;</span></span><br><span class="line"><span class="class">&gt;&gt;&gt; <span class="title">print</span><span class="params">(FooChild.bar)</span> # <span class="title">bar</span> <span class="title">is</span> <span class="title">inherited</span> <span class="title">from</span> <span class="title">Foo</span></span></span><br><span class="line"><span class="class"><span class="title">True</span></span></span><br></pre></td></tr></table></figure>
<p>最终你会想要添加方法到你的类。只需定义一个具有适当签名的函数，并将其分配为一个属性即可。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">echo_bar</span><span class="params">(self)</span>:</span></span><br><span class="line"><span class="meta">... </span>      print(self.bar)</span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>FooChild = type(<span class="string">'FooChild'</span>, (Foo,), &#123;<span class="string">'echo_bar'</span>: echo_bar&#125;)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>hasattr(Foo, <span class="string">'echo_bar'</span>)</span><br><span class="line"><span class="keyword">False</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>hasattr(FooChild, <span class="string">'echo_bar'</span>)</span><br><span class="line"><span class="keyword">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>my_foo = FooChild()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>my_foo.echo_bar()</span><br><span class="line"><span class="keyword">True</span></span><br></pre></td></tr></table></figure>
<p>在动态创建类之后，您可以添加更多的方法，就像向正常创建的类对象中添加方法一样。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">echo_bar_more</span><span class="params">(self)</span>:</span></span><br><span class="line"><span class="meta">... </span>      print(<span class="string">'yet another method'</span>)</span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>FooChild.echo_bar_more = echo_bar_more</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>hasattr(FooChild, <span class="string">'echo_bar_more'</span>)</span><br><span class="line"><span class="keyword">True</span></span><br></pre></td></tr></table></figure>
<p>您将看到我们要去的地方：在Python中，类是对象，您可以动态地创建一个类。</p>
<p>这就是Python在使用关键字class时所做的事情，而且它是通过使用元类来实现的。</p>
<p>什么是元类（最后）<br>元类是创建类的“东西”。</p>
<p>你定义类来创建对象，对吧？</p>
<p>但是我们知道Python类是对象。</p>
<p>那么，元类是创建这些对象。他们是类，你可以这样描绘他们：</p>
<p>MyClass = MetaClass()<br>MyObject = MyClass()<br>你已经看到，type让你做这样的事情：</p>
<p>MyClass = type(‘MyClass’, (), {})<br>这是因为这个函数type实际上是一个元类。type是Python用来在幕后创建所有类的元类。</p>
<p>现在你想知道为什么它是用小写字母写的，而不是Type？</p>
<p>那么，我想这是一个与str创建字符串对象int的类以及创建整型对象的类保持一致的问题。type只是创建类对象的类。</p>
<p>你通过检查<strong>class</strong>属性来看到。</p>
<p>一切，我的意思是一切，都是Python中的一个对象。包括整数，字符串，函数和类。所有这些都是对象。所有这些都是从一个类创建的：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>age = <span class="number">35</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>age.__class__</span><br><span class="line">&lt;type <span class="string">'int'</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>name = <span class="string">'bob'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>name.__class__</span><br><span class="line">&lt;type <span class="string">'str'</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">foo</span><span class="params">()</span>:</span> <span class="keyword">pass</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>foo.__class__</span><br><span class="line">&lt;type <span class="string">'function'</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">Bar</span><span class="params">(object)</span>:</span> <span class="keyword">pass</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b = Bar()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b.__class__</span><br><span class="line">&lt;<span class="class"><span class="keyword">class</span> '<span class="title">__main__</span>.<span class="title">Bar</span>'&gt;</span></span><br></pre></td></tr></table></figure>
<p>现在，这是<strong>class</strong>什么<strong>class</strong>？</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>age.__class__.__class__</span><br><span class="line">&lt;type <span class="string">'type'</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>name.__class__.__class__</span><br><span class="line">&lt;type <span class="string">'type'</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>foo.__class__.__class__</span><br><span class="line">&lt;type <span class="string">'type'</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b.__class__.__class__</span><br><span class="line">&lt;type <span class="string">'type'</span>&gt;</span><br></pre></td></tr></table></figure>
<p>所以，元类就是创建类对象的东西。</p>
<p>如果你愿意，你可以称之为“类工厂”。</p>
<p>type 是Python使用的内置元类，但是当然，您可以创建自己的元类。</p>
<p>该<strong>metaclass</strong>属性<br><strong>metaclass</strong>当你写一个类时，你可以添加一个属性：</p>
<p>class Foo(object):<br>  <strong>metaclass</strong> = something…<br>  […]<br>如果这样做，Python将使用元类来创建类Foo。</p>
<p>小心，这很棘手。</p>
<p>你class Foo(object)先写，但是类对象Foo不是在内存中创建的。</p>
<p>Python将<strong>metaclass</strong>在类定义中寻找。如果找到它，它将使用它来创建对象类Foo。如果没有，它将  type用来创建类。</p>
<p>多读几遍。</p>
<p>当你这样做时：</p>
<p>class Foo(Bar):<br>  pass<br>Python执行以下操作：</p>
<p>有一个<strong>metaclass</strong>属性Foo？</p>
<p>如果是的话，在内存中创建一个类对象（我说的是类对象，留在我这里），名称Foo使用是什么<strong>metaclass</strong>。</p>
<p>如果Python找不到<strong>metaclass</strong>，它将<strong>metaclass</strong>在MODULE级别寻找一个，并尝试做同样的事情（但只适用于不继承任何东西的类，基本上是旧式的类）。</p>
<p>如果找不到任何东西<strong>metaclass</strong>，它将使用Bar自己的元类（可能是默认值type）来创建类对象。</p>
<p>在这里要小心，该<strong>metaclass</strong>属性不会被继承，父类（Bar.<strong>class</strong>）的元类将是。如果Bar使用的<strong>metaclass</strong>是创建的属性Bar与type()（不是type.<strong>new</strong>()），子类不会继承该行为。</p>
<p>现在最大的问题是，你能放<strong>metaclass</strong>什么？</p>
<p>答案是：可以创建一个类的东西。</p>
<p>什么可以创建一个类？type，或任何子类或使用它。</p>
<p>自定义元类<br>元类的主要目的是在创建时自动更改类。</p>
<p>您通常对API进行此操作，您需要创建与当前上下文相匹配的类。</p>
<p>想象一个愚蠢的例子，你决定你的模块中的所有类都应该用大写字母来写属性。有几种方法可以做到这一点，但一种方法是<strong>metaclass</strong>在模块级别设置。</p>
<p>这样，这个模块的所有类都将使用这个元类来创建，我们只需要告诉元类将所有的属性都改为大写。</p>
<p>幸运的是，<code>__metaclass__</code>实际上可以是任何可调用的，它不需要是一个正式的类（我知道，名称中的’class’不需要成为一个类，但是这是有用的）。</p>
<p>所以我们将从一个简单的例子开始，使用一个函数。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># the metaclass will automatically get passed the same argument</span></span><br><span class="line"><span class="comment"># that you usually pass to `type`</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">upper_attr</span><span class="params">(future_class_name, future_class_parents, future_class_attr)</span>:</span></span><br><span class="line">  <span class="string">"""</span></span><br><span class="line"><span class="string">    Return a class object, with the list of its attribute turned</span></span><br><span class="line"><span class="string">    into uppercase.</span></span><br><span class="line"><span class="string">  """</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># pick up any attribute that doesn't start with '__' and uppercase it</span></span><br><span class="line">  uppercase_attr = &#123;&#125;</span><br><span class="line">  <span class="keyword">for</span> name, val <span class="keyword">in</span> future_class_attr.items():</span><br><span class="line">      <span class="keyword">if</span> <span class="keyword">not</span> name.startswith(<span class="string">'__'</span>):</span><br><span class="line">          uppercase_attr[name.upper()] = val</span><br><span class="line">      <span class="keyword">else</span>:</span><br><span class="line">          uppercase_attr[name] = val</span><br><span class="line"></span><br><span class="line">  <span class="comment"># let `type` do the class creation</span></span><br><span class="line">  <span class="keyword">return</span> type(future_class_name, future_class_parents, uppercase_attr)</span><br><span class="line"></span><br><span class="line">__metaclass__ = upper_attr <span class="comment"># this will affect all classes in the module</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span><span class="params">()</span>:</span> <span class="comment"># global __metaclass__ won't work with "object" though</span></span><br><span class="line">  <span class="comment"># but we can define __metaclass__ here instead to affect only this class</span></span><br><span class="line">  <span class="comment"># and this will work with "object" children</span></span><br><span class="line">  bar = <span class="string">'bip'</span></span><br><span class="line"></span><br><span class="line">print(hasattr(Foo, <span class="string">'bar'</span>))</span><br><span class="line"><span class="comment"># Out: False</span></span><br><span class="line">print(hasattr(Foo, <span class="string">'BAR'</span>))</span><br><span class="line"><span class="comment"># Out: True</span></span><br><span class="line"></span><br><span class="line">f = Foo()</span><br><span class="line">print(f.BAR)</span><br><span class="line"><span class="comment"># Out: 'bip'</span></span><br><span class="line">现在，让我们做同样的事情，但使用一个真正的类为一个元类：</span><br><span class="line"></span><br><span class="line"><span class="comment"># remember that `type` is actually a class like `str` and `int`</span></span><br><span class="line"><span class="comment"># so you can inherit from it</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UpperAttrMetaclass</span><span class="params">(type)</span>:</span></span><br><span class="line">    <span class="comment"># __new__ is the method called before __init__</span></span><br><span class="line">    <span class="comment"># it's the method that creates the object and returns it</span></span><br><span class="line">    <span class="comment"># while __init__ just initializes the object passed as parameter</span></span><br><span class="line">    <span class="comment"># you rarely use __new__, except when you want to control how the object</span></span><br><span class="line">    <span class="comment"># is created.</span></span><br><span class="line">    <span class="comment"># here the created object is the class, and we want to customize it</span></span><br><span class="line">    <span class="comment"># so we override __new__</span></span><br><span class="line">    <span class="comment"># you can do some stuff in __init__ too if you wish</span></span><br><span class="line">    <span class="comment"># some advanced use involves overriding __call__ as well, but we won't</span></span><br><span class="line">    <span class="comment"># see this</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__new__</span><span class="params">(upperattr_metaclass, future_class_name,</span></span></span><br><span class="line"><span class="function"><span class="params">                future_class_parents, future_class_attr)</span>:</span></span><br><span class="line"></span><br><span class="line">        uppercase_attr = &#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> name, val <span class="keyword">in</span> future_class_attr.items():</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> name.startswith(<span class="string">'__'</span>):</span><br><span class="line">                uppercase_attr[name.upper()] = val</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                uppercase_attr[name] = val</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> type(future_class_name, future_class_parents, uppercase_attr)</span><br></pre></td></tr></table></figure>
<p>但是这不是真的OOP。我们type直接调用，我们不会覆盖或调用父母<strong>new</strong>。我们开始做吧：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UpperAttrMetaclass</span><span class="params">(type)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__new__</span><span class="params">(upperattr_metaclass, future_class_name,</span></span></span><br><span class="line"><span class="function"><span class="params">                future_class_parents, future_class_attr)</span>:</span></span><br><span class="line"></span><br><span class="line">        uppercase_attr = &#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> name, val <span class="keyword">in</span> future_class_attr.items():</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> name.startswith(<span class="string">'__'</span>):</span><br><span class="line">                uppercase_attr[name.upper()] = val</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                uppercase_attr[name] = val</span><br><span class="line"></span><br><span class="line">        <span class="comment"># reuse the type.__new__ method</span></span><br><span class="line">        <span class="comment"># this is basic OOP, nothing magic in there</span></span><br><span class="line">        <span class="keyword">return</span> type.__new__(upperattr_metaclass, future_class_name,</span><br><span class="line">                            future_class_parents, uppercase_attr)</span><br></pre></td></tr></table></figure>
<p>你可能已经注意到了额外的争论upperattr_metaclass。没有什么特别之处：<code>__new__</code>总是接收它定义的类作为第一个参数。就像你有self普通方法接收实例作为第一个参数，或类方法的定义类一样。</p>
<p>当然，为了清楚起见，我在这里使用的名字是很长的，但是self所有的论点都有传统的名字。所以一个真正的生产元类将如下所示：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UpperAttrMetaclass</span><span class="params">(type)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__new__</span><span class="params">(cls, clsname, bases, dct)</span>:</span></span><br><span class="line"></span><br><span class="line">        uppercase_attr = &#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> name, val <span class="keyword">in</span> dct.items():</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> name.startswith(<span class="string">'__'</span>):</span><br><span class="line">                uppercase_attr[name.upper()] = val</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                uppercase_attr[name] = val</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> type.__new__(cls, clsname, bases, uppercase_attr)</span><br></pre></td></tr></table></figure>
<p>我们可以通过使用它来更简洁super，这将减轻继承（因为是的，你可以有元继承，继承自类继承的元类）：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UpperAttrMetaclass</span><span class="params">(type)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__new__</span><span class="params">(cls, clsname, bases, dct)</span>:</span></span><br><span class="line"></span><br><span class="line">        uppercase_attr = &#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> name, val <span class="keyword">in</span> dct.items():</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> name.startswith(<span class="string">'__'</span>):</span><br><span class="line">                uppercase_attr[name.upper()] = val</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                uppercase_attr[name] = val</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> super(UpperAttrMetaclass, cls).__new__(cls, clsname, bases, uppercase_attr)</span><br></pre></td></tr></table></figure>
<p>而已。关于元类没有什么更多。</p>
<p>使用元类代码的复杂性背后的原因不是因为元类，这是因为你通常使用元类来依靠内省来做扭曲的东西，操纵继承，变量<strong>dict</strong>等等。</p>
<p>事实上，元类对于做黑魔法特别有用，因此也是复杂的东西。但是它们本身就很简单：</p>
<p>拦截一个类的创建<br>修改类<br>返回修改的类<br>为什么你会使用元类而不是函数？<br>既然<strong>metaclass</strong>可以接受任何可调用，为什么你会使用一个类，因为它显然更复杂？</p>
<p>这样做有几个原因：</p>
<p>意图很清楚。当你阅读时UpperAttrMetaclass(type)，你会知道接下来会发生什么<br>你可以使用OOP。元类可以从元类继承，重写父类的方法。元类甚至可以使用元类。<br>如果你指定了一个元类，而不是一个元类函数，那么类的子类将是它的元类的实例。<br>你可以更好地构建你的代码。你从来没有像上面的例子那样使用元类。这通常是复杂的。有能力创建几个方法并将它们分组在一个类中，这对于使代码更易于阅读非常有用。<br>你可以钩子<code>__new__</code>，<code>__init__</code>和<code>__call__</code>。这将允许你做不同的东西。即使通常你可以做到这一点<strong>new</strong>，有些人更舒适的使用<strong>init</strong>。<br>这些被称为元类，该死的！这意味着什么！<br>你为什么要使用元类？<br>现在是个大问题。为什么你会使用一些模糊的错误倾向功能？</p>
<p>那么，通常你不会：</p>
<p>元类是更深的魔法，99％的用户不应该担心。如果你想知道你是否需要他们，你不需要（那些真正需要他们的人肯定知道他们需要他们，不需要解释为什么）。</p>
<p>Python大师蒂姆·彼得斯</p>
<p>元类的主要用例是创建一个API。一个典型的例子是Django的ORM。</p>
<p>它允许你定义这样的东西：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span><span class="params">(models.Model)</span>:</span></span><br><span class="line">  name = models.CharField(max_length=<span class="number">30</span>)</span><br><span class="line">  age = models.IntegerField()</span><br></pre></td></tr></table></figure>
<p>但是，如果你这样做：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">guy = Person(name=<span class="string">'bob'</span>, age=<span class="string">'35'</span>)</span><br><span class="line">print(guy.age)</span><br></pre></td></tr></table></figure>
<p>它不会返回一个IntegerField对象。它会返回一个int，甚至可以直接从数据库中获取。</p>
<p>这是可能的，因为models.Model定义<strong>metaclass</strong>和它使用了一些魔法，将Person您刚刚定义的简单语句变成一个复杂的钩子到数据库字段。</p>
<p>Django通过暴露一个简单的API并使用元类来创建一些复杂的外观，从这个API重新创建代码，在幕后做真正的工作。</p>
<p>最后一个字<br>首先，您知道类是可以创建实例的对象。</p>
<p>实际上，类本身就是实例。元类</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">Foo</span><span class="params">(object)</span>:</span> <span class="keyword">pass</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>id(Foo)</span><br><span class="line"><span class="number">142630324</span></span><br></pre></td></tr></table></figure>
<p>一切都是Python中的对象，它们都是类的实例或元类的实例。</p>
<p>除了type。</p>
<p>type实际上是它自己的元类。这不是在纯Python中可以重现的东西，而是通过在实现级别上作弊。</p>
<p>其次，元类是复杂的。你可能不想用它们来进行非常简单的课堂改动。你可以通过使用两种不同的技术来改变类：</p>
<p>猴子补丁<br>类装饰器<br>99％的时间你需要改变类，你最好使用这些。</p>
<p>但98％的时间，你根本不需要改变类。</p>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/python/">python</a>
</div>


</div>




<div class="comments-count">
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2018/01/12/python-yield/" title="python yield 关键字" itemprop="url">python yield 关键字</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="zhizi" target="_blank" itemprop="author">zhizi</a>
		
  <p class="article-time">
    <time datetime="2018-01-12T08:02:23.000Z" itemprop="datePublished"> Published 2018-01-12</time>
    
  </p>
</header>
    <div class="article-content">
        
        <p>要理解什么yield，你必须了解什么是 generator。</p>
<h2><span id="iterables">Iterables</span></h2><p>当你创建一个列表，你可以逐个读取它的项目。逐个读取它的项目称为迭代：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>mylist = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> i <span class="keyword">in</span> mylist:</span><br><span class="line"><span class="meta">... </span>   print(i)</span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">3</span></span><br></pre></td></tr></table></figure>
<p>mylist是一个迭代。当你使用列表推导，你创建一个列表，和一个可迭代的：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>mylist = [x*x <span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">3</span>)]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> i <span class="keyword">in</span> mylist:</span><br><span class="line"><span class="meta">... </span>   print(i)</span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">4</span></span><br></pre></td></tr></table></figure>
<p>你可以使用<code>for... in...</code>的所有东西都是可迭代的; lists，strings，file …</p>
<p>这些迭代器很方便，因为您可以随心所欲地读取它们，但是将所有值存储在内存中，而且当有很多值时，并不总是您想要的值。</p>
<h2><span id="generator">generator</span></h2><p>生成器(generator)是迭代器，一种迭代器，只能迭代一次。generator不会将所有的值存储在内存中，它们会立即生成值：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>mygenerator = (x*x <span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">3</span>))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> i <span class="keyword">in</span> mygenerator:</span><br><span class="line"><span class="meta">... </span>   print(i)</span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">4</span></span><br></pre></td></tr></table></figure>
<p>除了你用来<code>()</code>代替<code>[]</code>之外，它是一样的。但是，由于generator只能使用一次，所以不能再执行<code>for i in mygenerator</code>多次：计算0，然后忘记计算1，逐个计算4。</p>
<h2><span id="yield">yield</span></h2><p>yield是一个像return的关键字，函数将返回一个生成器。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">createGenerator</span><span class="params">()</span>:</span></span><br><span class="line"><span class="meta">... </span>   mylist = range(<span class="number">3</span>)</span><br><span class="line"><span class="meta">... </span>   <span class="keyword">for</span> i <span class="keyword">in</span> mylist:</span><br><span class="line"><span class="meta">... </span>       <span class="keyword">yield</span> i*i</span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>mygenerator = createGenerator() <span class="comment"># create a generator</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(mygenerator) <span class="comment"># mygenerator is an object!</span></span><br><span class="line">&lt;generator object createGenerator at <span class="number">0xb7555c34</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> i <span class="keyword">in</span> mygenerator:</span><br><span class="line"><span class="meta">... </span>    print(i)</span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">4</span></span><br></pre></td></tr></table></figure>
<p>这是一个无用的例子，但是当你知道你的函数将会返回一大堆你只需要读取一次的值的时候，它是很方便的。</p>
<p>要掌握yield，你必须明白当你调用函数时，你写在函数体中的代码不会运行。该函数只返回生成器对象，这有点棘手:-)</p>
<p>然后，您的代码将在每次使用for时运行生成器。</p>
<p>困难的部分：</p>
<p>第一次for调用由你的函数创建的generator对象时，它会从你的函数开始直到碰到它yield，然后返回第一个循环的值。然后，每个其他的调用将运行你已经写在函数中的循环一次，并返回下一个值，直到没有值返回。</p>
<p>一旦函数运行，生成器被认为是空的，但不再被yield触发。这可能是因为循环已经结束，或者因为你不再满足”if/else”了。</p>
<p>生成器的高级用法：</p>
<h2><span id="控制生成器">控制生成器</span></h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">Bank</span><span class="params">()</span>:</span> <span class="comment"># let's create a bank, building ATMs</span></span><br><span class="line"><span class="meta">... </span>   crisis = <span class="keyword">False</span></span><br><span class="line"><span class="meta">... </span>   <span class="function"><span class="keyword">def</span> <span class="title">create_atm</span><span class="params">(self)</span>:</span></span><br><span class="line"><span class="meta">... </span>       <span class="keyword">while</span> <span class="keyword">not</span> self.crisis:</span><br><span class="line"><span class="meta">... </span>           <span class="keyword">yield</span> <span class="string">"$100"</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>hsbc = Bank() <span class="comment"># when everything's ok the ATM gives you as much as you want</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>corner_street_atm = hsbc.create_atm()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(corner_street_atm.next())</span><br><span class="line">$<span class="number">100</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(corner_street_atm.next())</span><br><span class="line">$<span class="number">100</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print([corner_street_atm.next() <span class="keyword">for</span> cash <span class="keyword">in</span> range(<span class="number">5</span>)])</span><br><span class="line">[<span class="string">'$100'</span>, <span class="string">'$100'</span>, <span class="string">'$100'</span>, <span class="string">'$100'</span>, <span class="string">'$100'</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>hsbc.crisis = <span class="keyword">True</span> <span class="comment"># crisis is coming, no more money!</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(corner_street_atm.next())</span><br><span class="line">&lt;type <span class="string">'exceptions.StopIteration'</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>wall_street_atm = hsbc.create_atm() <span class="comment"># it's even true for new ATMs</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(wall_street_atm.next())</span><br><span class="line">&lt;type <span class="string">'exceptions.StopIteration'</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>hsbc.crisis = <span class="keyword">False</span> <span class="comment"># trouble is, even post-crisis the ATM remains empty</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(corner_street_atm.next())</span><br><span class="line">&lt;type <span class="string">'exceptions.StopIteration'</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>brand_new_atm = hsbc.create_atm() <span class="comment"># build a new one to get back in business</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> cash <span class="keyword">in</span> brand_new_atm:</span><br><span class="line"><span class="meta">... </span>   <span class="keyword">print</span> cash</span><br><span class="line">$<span class="number">100</span></span><br><span class="line">$<span class="number">100</span></span><br><span class="line">$<span class="number">100</span></span><br><span class="line">$<span class="number">100</span></span><br><span class="line">$<span class="number">100</span></span><br><span class="line">$<span class="number">100</span></span><br><span class="line">$<span class="number">100</span></span><br><span class="line">$<span class="number">100</span></span><br><span class="line">$<span class="number">100</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>注意：对于Python3使用<code>print(corner_street_atm.__next__())</code>或<code>print(next(corner_street_atm))</code></p>
<p>它可以用于控制对资源的访问等各种功能。</p>
<h2><span id="itertools">Itertools</span></h2><p>itertools模块包含特殊的函数来操作iterables。是否希望复制一个生成器？链接两个生成器？Map / Zip而不创建另一个列表？</p>
<p>然后，只需<code>import itertools</code>。</p>
<p>一个例子，让我们看看四匹马的可能的到达顺序：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>horses = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>races = itertools.permutations(horses)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(races)</span><br><span class="line">&lt;itertools.permutations object at <span class="number">0xb754f1dc</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(list(itertools.permutations(horses)))</span><br><span class="line">[(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>),</span><br><span class="line"> (<span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">3</span>),</span><br><span class="line"> (<span class="number">1</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">4</span>),</span><br><span class="line"> (<span class="number">1</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">2</span>),</span><br><span class="line"> (<span class="number">1</span>, <span class="number">4</span>, <span class="number">2</span>, <span class="number">3</span>),</span><br><span class="line"> (<span class="number">1</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>),</span><br><span class="line"> (<span class="number">2</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">4</span>),</span><br><span class="line"> (<span class="number">2</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">3</span>),</span><br><span class="line"> (<span class="number">2</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">4</span>),</span><br><span class="line"> (<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">1</span>),</span><br><span class="line"> (<span class="number">2</span>, <span class="number">4</span>, <span class="number">1</span>, <span class="number">3</span>),</span><br><span class="line"> (<span class="number">2</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">1</span>),</span><br><span class="line"> (<span class="number">3</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>),</span><br><span class="line"> (<span class="number">3</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">2</span>),</span><br><span class="line"> (<span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">4</span>),</span><br><span class="line"> (<span class="number">3</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">1</span>),</span><br><span class="line"> (<span class="number">3</span>, <span class="number">4</span>, <span class="number">1</span>, <span class="number">2</span>),</span><br><span class="line"> (<span class="number">3</span>, <span class="number">4</span>, <span class="number">2</span>, <span class="number">1</span>),</span><br><span class="line"> (<span class="number">4</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>),</span><br><span class="line"> (<span class="number">4</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">2</span>),</span><br><span class="line"> (<span class="number">4</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">3</span>),</span><br><span class="line"> (<span class="number">4</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">1</span>),</span><br><span class="line"> (<span class="number">4</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">2</span>),</span><br><span class="line"> (<span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>)]</span><br></pre></td></tr></table></figure>
<h2><span id="了解迭代的内在机制">了解迭代的内在机制</span></h2><p>迭代是一个隐式迭代（实现<code>__iter__()</code>方法）和迭代（实现<code>__next__()</code>方法）的过程。Iterables是可以从中获取迭代器的任何对象。迭代器是可以迭代迭代的对象。</p>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/python/">python</a>
</div>


  <div class="article-tags">
  
  <span></span> <a href="/tags/python/">python</a>
  </div>

</div>




<div class="comments-count">
	
</div>

</footer>


    </article>







</div>
      <div class="openaside"><a class="navbutton" href="#" title="Show Sidebar"></a></div>

<div id="asidepart">
<div class="closeaside"><a class="closebutton" href="#" title="Hide Sidebar"></a></div>
<aside class="clearfix">

  


  
<div class="categorieslist">
	<p class="asidetitle">Categories</p>
		<ul>
		
		  
			<li><a href="/categories/python/" title="python">python<sup>2</sup></a></li>
		  
		
		  
			<li><a href="/categories/spark/" title="spark">spark<sup>2</sup></a></li>
		  
		
		</ul>
</div>


  
<div class="tagslist">
	<p class="asidetitle">Tags</p>
		<ul class="clearfix">
		
			
				<li><a href="/tags/python/" title="python">python<sup>1</sup></a></li>
			
		
		</ul>
</div>


  <div class="linkslist">
  <p class="asidetitle">Links</p>
    <ul>
        
          <li>
            
            	<a href="https://tracholar.github.io" target="_blank" title="个人博客">个人博客</a>
            
          </li>
        
    </ul>
</div>

  <div class="rsspart">
	<a href="/atom.xml" target="_blank" title="rss">RSS</a>
</div>

</aside>
</div>
    </div>
    <footer><div id="footer" >
	
	
	<section class="info">
		<p> To be or not to be, that is a question. <br/>
			This is my blog,believe it or not.</p>
	</section>
	 
	<div class="social-font" class="clearfix">
		
		
		
		
		
		
		
		
		
		
	</div>
			
		

		<p class="copyright">
		Powered by <a href="http://hexo.io" target="_blank" title="hexo">hexo</a> and Theme by <a href="https://github.com/wuchong/jacman" target="_blank" title="Jacman">Jacman</a> © 2018 
		
		<a href="/about" target="_blank" title="zhizi">zhizi</a>
		
		
		</p>
</div>
</footer>
    <script src="/js/jquery-2.0.3.min.js"></script>
<script src="/js/jquery.imagesloaded.min.js"></script>
<script src="/js/gallery.js"></script>
<script src="/js/jquery.qrcode-0.12.0.min.js"></script>

<script type="text/javascript">
$(document).ready(function(){ 
  $('.navbar').click(function(){
    $('header nav').toggleClass('shownav');
  });
  var myWidth = 0;
  function getSize(){
    if( typeof( window.innerWidth ) == 'number' ) {
      myWidth = window.innerWidth;
    } else if( document.documentElement && document.documentElement.clientWidth) {
      myWidth = document.documentElement.clientWidth;
    };
  };
  var m = $('#main'),
      a = $('#asidepart'),
      c = $('.closeaside'),
      o = $('.openaside');
  c.click(function(){
    a.addClass('fadeOut').css('display', 'none');
    o.css('display', 'block').addClass('fadeIn');
    m.addClass('moveMain');
  });
  o.click(function(){
    o.css('display', 'none').removeClass('beforeFadeIn');
    a.css('display', 'block').removeClass('fadeOut').addClass('fadeIn');      
    m.removeClass('moveMain');
  });
  $(window).scroll(function(){
    o.css("top",Math.max(80,260-$(this).scrollTop()));
  });
  
  $(window).resize(function(){
    getSize(); 
    if (myWidth >= 1024) {
      $('header nav').removeClass('shownav');
    }else{
      m.removeClass('moveMain');
      a.css('display', 'block').removeClass('fadeOut');
      o.css('display', 'none');
        
    }
  });
});
</script>












<link rel="stylesheet" href="/fancybox/jquery.fancybox.css" media="screen" type="text/css">
<script src="/fancybox/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
$(document).ready(function(){ 
  $('.article-content').each(function(i){
    $(this).find('img').each(function(){
      if ($(this).parent().hasClass('fancybox')) return;
      var alt = this.alt;
      if (alt) $(this).after('<span class="caption">' + alt + '</span>');
      $(this).wrap('<a href="' + this.src + '" title="' + alt + '" class="fancybox"></a>');
    });
    $(this).find('.fancybox').each(function(){
      $(this).attr('rel', 'article' + i);
    });
  });
  if($.fancybox){
    $('.fancybox').fancybox();
  }
}); 
</script>



<!-- Analytics Begin -->





<!-- Analytics End -->

<!-- Totop Begin -->

	<div id="totop">
	<a title="Back to Top"><img src="/img/scrollup.png"/></a>
	</div>
	<script src="/js/totop.js"></script>

<!-- Totop End -->

<!-- MathJax Begin -->
<!-- mathjax config similar to math.stackexchange -->


<!-- MathJax End -->

<!-- Tiny_search Begin -->

<!-- Tiny_search End -->

  </body>
 </html>
