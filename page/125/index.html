
 <!DOCTYPE HTML>
<html >
<head>
  <meta charset="UTF-8">
  
    <title>智子</title>
    <meta name="viewport" content="width=device-width, initial-scale=1,user-scalable=no">
    
    <meta name="author" content="zhizi">
    

    
    <meta name="description" content="IT技术、编程、web开发以及新兴的技术翻译与总结">
<meta property="og:type" content="website">
<meta property="og:title" content="智子">
<meta property="og:url" content="https://www.tracholar.top/page/125/index.html">
<meta property="og:site_name" content="智子">
<meta property="og:description" content="IT技术、编程、web开发以及新兴的技术翻译与总结">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="智子">
<meta name="twitter:description" content="IT技术、编程、web开发以及新兴的技术翻译与总结">

    
    <link rel="alternative" href="/atom.xml" title="智子" type="application/atom+xml">
    
    
    <link rel="icon" href="/img/favicon.ico">
    
    
    <link rel="apple-touch-icon" href="/img/jacman.jpg">
    <link rel="apple-touch-icon-precomposed" href="/img/jacman.jpg">
    
    <link rel="stylesheet" href="/css/style.css">

    <!-- ad start -->
    <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<script>
  (adsbygoogle = window.adsbygoogle || []).push({
    google_ad_client: "ca-pub-6300557868920774",
    enable_page_level_ads: true
  });
</script>

    <!-- ad end -->

    <!--  stat -->
    <script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?4036f580b1119e720db871571faa68cc";
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(hm, s);
})();
</script>

    <!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-78529611-1"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-78529611-1');
</script>

    <!-- end stat -->
</head>

  <body>
    <header>
      
<div>
		
			<div id="textlogo">
				<h1 class="site-name"><a href="/" title="智子">智子</a></h1>
				<h2 class="blog-motto">智子之家</h2>
			</div>
			<div class="navbar"><a class="navbutton navmobile" href="#" title="菜单">
			</a></div>
			<nav class="animated">
				<ul>
					<ul>
					 
						<li><a href="/">Home</a></li>
					
						<li><a href="/archives">Archives</a></li>
					
						<li><a href="/about">About</a></li>
					
					<li>
 					
					<form class="search" action="//google.com/search" method="get" accept-charset="utf-8">
						<label>Search</label>
						<input type="search" id="search" name="q" autocomplete="off" maxlength="20" placeholder="搜索" />
						<input type="hidden" name="q" value="site:www.tracholar.top">
					</form>
					
					</li>
				</ul>
			</nav>			
</div>
    </header>
    <div id="container">
      <div id="main">


   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2018/01/01/estimators/" title="估计" itemprop="url">估计</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="zhizi" target="_blank" itemprop="author">zhizi</a>
		
  <p class="article-time">
    <time datetime="2018-01-01T02:00:00.000Z" itemprop="datePublished"> 发表于 2018-01-01</time>
    
  </p>
</header>
    <div class="article-content">
        
        <h1><span id="估计">估计</span></h1><p>本文介绍了Estimators - 高级TensorFlow API大大简化了机器学习编程。估算器封装 采取以下行动：</p>
<p>训练 评测 预测 出口服务</p>
<p>您可以使用我们提供的预先制作的估算器或者编写您的 自己的定制估算器。所有估算器 - 无论是预制还是定制 - 都是<br>基于<code>tf.estimator.Estimator</code>等级的课程。</p>
<p>注意：TensorFlow还包括一个已弃用的<code>Estimator</code>类 <code>tf.contrib.learn.Estimator</code>，你不应该使用。</p>
<h2><span id="估算的优点">估算的优点</span></h2><p>估算人员提供以下好处：</p>
<p>您可以在本地主机上运行基于估算器的模型     分布式多服务器环境而不改变你的模型。     此外，您可以在CPU，GPU和GPU上运行基于估算器的模型，<br>或TPU而无需重新编码模型。 估算器简化了模型开发人员之间的共享实现。 您可以使用高级直观的代码开发最先进的模型，<br>简而言之，用Estimators创建模型通常要容易得多     比使用低级别的TensorFlow API。 估算器本身是建立在tf.layers上的，<br>简化了定制。 估计者为你建立图表。换句话说，你不需要     建立图表。 估算人员提供一个安全的分布式培训循环，控制如何和     何时： 建立图表<br>初始化变量 开始排队 处理异常 创建检查点文件并从失败中恢复 保存TensorBoard的摘要</p>
<p>用Estimators编写应用程序时，必须分开数据输入 从模型的管道。这种分离简化了实验 不同的数据集。</p>
<h2><span id="预先估算的">预先估算的</span></h2><p>预制估算器使您能够在更高的概念层面上工作 比基本的TensorFlow APIs。你不必再担心创建 由Estimators处理所有的计算图或会话<br>“水暖”给你。也就是说，预先制定的估算人员可以创建和管理 <code>Graph</code>和<code>Session</code>物件。此外， 预先制作的估算器可以让你通过不同的模型架构进行实验<br>只做最小的代码更改。 <code>DNNClassifier</code>， 例如，是预先制作的Estimator类，其训练分类模型 通过密集的前馈神经网络。</p>
<h3><span id="预先制定的估算人员计划的结构">预先制定的估算人员计划的结构</span></h3><p>一个依靠预先制定的估算器的TensorFlow程序通常包括 以下四个步骤：</p>
<p>编写一个或多个数据集导入功能。例如，你可能会     创建一个功能导入训练集和另一个功能     导入测试集。每个数据集导入功能必须返回两个     对象：<br>一个字典，其中的键是功能名称和     值是包含相应的Tensors（或SparseTensors）     特征数据 包含一个或多个标签的张量<br>例如，以下代码说明了基本框架 一个输入功能： def input_fn（dataset）：    …＃操作数据集，提取功能名称和标签<br>返回feature_dict，标签 （有关完整的详细信息，请参阅导入数据。） 定义特征列。每个<code>tf.feature_column</code><br>标识功能名称，类型和任何输入预处理。     例如，以下片段创建三个功能     保存整数或浮点数据的列。前两个     特征列只是标识特征的名称和类型。该<br>第三个特性列还指定了程序将调用的lambda     调整原始数据： ＃定义三个数字特征列。 人口=<br>tf.feature_column.numeric_column（’人口’） crime_rate =<br>tf.feature_column.numeric_column（’crime_rate’） median_education =<br>tf.feature_column.numeric_column（’median_education’，<br>normalizer_fn =’lambda x：x - global_education_mean’） 实例化相关的预制估算器。例如，在这里<br>预先制作的估算器<code>LinearClassifier</code>的样品实例： ＃实例化一个估计器，传递特征列。 estimator =<br>tf.estimator.Estimator.LinearClassifier（     feature_columns =<br>[population，crime_rate，median_education]，     ） 调用培训，评估或推理方法。<br>例如，所有估算器都提供<code>train</code>方法，用于训练模型。 ＃my_training_set是在步骤1中创建的函数<br>estimator.train（input_fn = my_training_set，steps = 2000）</p>
<h3><span id="预先估算的好处">预先估算的好处</span></h3><p>预制估算器编码最佳实践，提供以下好处：</p>
<p>确定计算的不同部分的最佳实践     图应该运行，在一台机器上或者一台机器上实施策略     簇。 事件（摘要）写作的最佳实践和普遍有用的     摘要。</p>
<p>如果您不使用预先制定的估算器，则必须执行上述操作 特点你自己。</p>
<h2><span id="自定义估算器">自定义估算器</span></h2><p>每个估算器的核心 - 无论是预制还是定制 - 都是它的核心 模型函数，这是一种为训练建立图形的方法， 评估和预测。当您使用预先制作的估算器时，<br>其他人已经实现了模型功能。依靠时 在自定义的估算器上，您必须自己编写模型函数。一个 伴侣文件 解释如何编写模型函数。</p>
<h2><span id="推荐工作流程">推荐工作流程</span></h2><p>我们推荐以下工作流程：</p>
<p>假设存在合适的预制估算器，请使用它来构建您的估算器     第一个模型，并使用其结果来建立基线。 建立和测试你的整个管道，包括完整性和<br>用这个预先制作的估算器，您的数据的可靠性。 如果合适的替代预制估算器可用，则运行     实验来确定哪个预先制作的Estimator产生的<br>最好的结果。 可能通过构建您自己的自定义估算器来进一步改进您的模型。</p>
<h2><span id="从keras模型创建估计量">从Keras模型创建估计量</span></h2><p>您可以将现有的Keras模型转换为Estimators。这样做可以使您的Keras 模型来访问Estimator的优势，如分布式培训。呼叫<br>如在<code>tf.keras.estimator.model_to_estimator</code>中 以下示例：</p>
<pre><code># Instantiate a Keras inception v3 model.
keras_inception_v3 = tf.keras.applications.inception_v3.InceptionV3(weights=None)
# Compile model with the optimizer, loss, and metrics you&apos;d like to train with.
keras_inception_v3.compile(optimizer=tf.keras.optimizers.SGD(lr=0.0001, momentum=0.9),
                          loss=&apos;categorical_crossentropy&apos;,
                          metric=&apos;accuracy&apos;)
# Create an Estimator from the compiled Keras model.
est_inception_v3 = tf.keras.estimator.model_to_estimator(keras_model=keras_inception_v3)
# Treat the derived Estimator as you would any other Estimator. For example,
# the following derived Estimator calls the train method:
est_inception_v3.train(input_fn=my_training_set, steps=2000)
</code></pre><p>有关更多详细信息，请参阅文档 <code>tf.keras.estimator.model_to_estimator</code>。</p>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">


  <div class="article-tags">
  
  <span></span> <a href="/tags/机器学习/">机器学习</a>
  </div>

</div>




<div class="comments-count">
	
</div>

</footer>


    </article>





  
      <ins class="adsbygoogle"
     style="display:block;  overflow:hidden;"
     data-ad-format="fluid"
     data-ad-layout-key="-ej+6f-q-c7+ou"
     data-ad-client="ca-pub-6300557868920774"
     data-ad-slot="5206371097"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>

  

   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2018/01/01/recommended-way-to-embed-pdf-in-html/" title="推荐将PDF嵌入到HTML中的方法？" itemprop="url">推荐将PDF嵌入到HTML中的方法？</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="zhizi" target="_blank" itemprop="author">zhizi</a>
		
  <p class="article-time">
    <time datetime="2018-01-01T02:00:00.000Z" itemprop="datePublished"> 发表于 2018-01-01</time>
    
  </p>
</header>
    <div class="article-content">
        
        <p>在HTML中嵌入PDF的推荐方法是什么？</p>
<p>的iFrame？ 目的？ 嵌入？</p>
<p>Adobe对此有何看法？</p>
<p>在我的情况下，PDF即时生成，所以在冲洗之前不能上传到第三方解决方案。</p>
        
        
        <p class="article-more-link">
          
            <a href="/2018/01/01/recommended-way-to-embed-pdf-in-html/#more">Read More</a>
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">


  <div class="article-tags">
  
  <span></span> <a href="/tags/html/">html</a>
  </div>

</div>




<div class="comments-count">
	
</div>

</footer>


    </article>





  

   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2018/01/01/mobile_intro/" title="TensorFlow Mobile简介" itemprop="url">TensorFlow Mobile简介</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="zhizi" target="_blank" itemprop="author">zhizi</a>
		
  <p class="article-time">
    <time datetime="2018-01-01T02:00:00.000Z" itemprop="datePublished"> 发表于 2018-01-01</time>
    
  </p>
</header>
    <div class="article-content">
        
        <h1><span id="tensorflow-mobile简介">TensorFlow Mobile简介</span></h1><p>TensorFlow的设计从根本上是一个很好的深度学习解决方案 适用于Android和iOS等移动平台。这个移动指南应该帮助你<br>了解机器学习如何在移动平台上工作，以及如何 将TensorFlow高效地整合到您的移动应用程序中。</p>
<h2><span id="关于本指南">关于本指南</span></h2><p>本指南针对的是拥有TensorFlow模型的开发人员 成功地在桌面环境中工作，谁想要将其整合进去 一个移动应用程序，并且不能使用TensorFlow<br>Lite。这里有 在这个过程中你将面临的主要挑战：</p>
<p>了解如何使用Tensorflow进行移动。 为您的平台构建TensorFlow。 将TensorFlow库集成到您的应用程序中。<br>准备您的模型文件进行移动部署。 优化延迟，RAM使用率，模型文件大小和二进制大小。</p>
<h2><span id="移动机器学习的常见用例">移动机器学习的常见用例</span></h2><p>为什么要在手机上运行TensorFlow？</p>
<p>传统上，深度学习与数据中心和巨人联系在一起 高性能GPU机器集群。但是，它可能是非常昂贵的 耗费时间来发送设备通过网络访问的所有数据<br>连接。在移动设备上运行使得交互性非常好 应用程序的方式是不可能的，当你不得不等待一个网络 往返。</p>
<p>以下是设备深度学习的一些常见用例：</p>
<h3><span id="语音识别">语音识别</span></h3><p>有很多有趣的应用程序可以用一个 语音驱动的界面，其中许多需要在设备上处理。大多数 用户没有发出命令的时间，等等<br>远程服务器将是一个浪费带宽，因为它将主要是沉默或 背景噪音。为了解决这个问题，通常有一个小的神经 运行在设备上的网络监听特定的关键字。<br>一旦关键字被发现，其余的 会话可以传送到服务器进行进一步处理 需要更多的计算能力。</p>
<h3><span id="图像识别">图像识别</span></h3><p>移动应用程序能够理解照相机可能非常有用 图片。如果你的用户正在拍照，认识到他们的内容可以帮助你 相机应用程序应用适当的过滤器，或标记照片，以便他们很容易<br>玛丽萨。对于嵌入式应用程序也很重要，因为您可以使用图像 传感器来检测各种有趣的条件，无论是发现 濒临灭绝的野生动物 要么 报告你的火车运行有多迟。</p>
<p>TensorFlow附带了几个识别对象类型的例子 内部图像以及各种不同的预先训练的模型，他们可以 全部在移动设备上运行。你可以试试 我们的 诗人和诗人的张量<br>诗人2的Tensorflow：优化移动代码到 看看如何采取预训练模式，并运行一些非常快速和轻量级 训练教它识别特定的对象，然后优化它 在手机上运行。</p>
<h3><span id="对象本地化">对象本地化</span></h3><p>有时候知道图像中的物体是什么以及什么是很重要的 他们是。有很多增强现实的使用情况可能会有益于 移动应用程序，比如在向用户提供正确的组件时引导用户<br>帮助修复他们的无线网络或提供信息覆盖 景观特点。嵌入式应用程序通常需要计算对象 路过它们，无论是农作物领域的害虫，还是人，车，路 自行车通过路灯。</p>
<p>TensorFlow提供了一个预制模型来绘制围绕人的边界框 在图像中检测到，随着时间的推移跟踪代码。该 跟踪对于您要计数的应用程序尤其重要<br>随着时间的推移有多少物体，因为它给你一个好主意，当一个 新物体进入或离开现场。我们有一些示例代码 可用于Android上 Github上，<br>也是一个更一般的对象检测 模型 也可以使用。</p>
<h3><span id="手势识别">手势识别</span></h3><p>能够用手或其他控制应用程序可能是有用的 手势，无论是从图像识别或通过分析加速度计 传感器数据。创建这些模型超出了本指南的范围，但是<br>TensorFlow是部署它们的有效方法。</p>
<h3><span id="光学字符识别">光学字符识别</span></h3><p>谷歌翻译的实时相机视图是如何有效的一个很好的例子 交互式设备上的文本检测可以。</p>
<p>识别图像中的文字涉及多个步骤。你先有 确定文本所在的区域，这是一个变体 对象本地化问题，可以用类似的技术来解决。一旦您<br>有一个区域的文字，然后你需要把它解释为字母，然后使用一个 语言模型来帮助猜测他们代表的是什么词。最简单的方法 估计出现的字母是将文本行分割成单独的<br>字母，然后将一个简单的神经网络应用到每个的边界框。您 可以得到良好的结果，用于MNIST，你可以找到的模型<br>在TensorFlow的教程中，尽管您可能需要更高分辨率的输入。一个 更先进的选择是使用LSTM模型来处理整个系列 文本一次，与模型本身处理分割成不同的<br>字符。</p>
<h3><span id="翻译">翻译</span></h3><p>即使你，也能快速而准确地从一种语言翻译成另一种语言 没有网络连接，是一个重要的用例。深度网络是 这种任务非常有效，你可以找到很多的描述<br>文学中的不同模型。通常这些是序列到序列 经常使用的模型，您可以运行一个图形来完成整个工作 翻译，而无需运行单独的解析阶段。</p>
<h3><span id="文本分类">文本分类</span></h3><p>如果您想根据用户输入的内容向用户提示相关的提示 阅读，理解文本的含义是非常有用的。这是 文本分类是在哪里进行的。文本分类是一个总括性术语<br>涵盖了从情感分析到主题发现的所有内容。你很有可能 有自己的类别或标签，你想申请，所以最好的地方 开始就是一个例子 喜欢 跳思考， 然后训练你自己的例子。</p>
<h3><span id="语音合成">语音合成</span></h3><p>合成语音可以是给予用户反馈或帮助的好方法 可访问性，以及近期的进展如 WaveNet秀 深度学习可以提供非常自然的演讲。</p>
<h2><span id="移动机器学习和云">移动机器学习和云</span></h2><p>这些用例的例子给出了设备网络如何实现的概念 补充云服务。云计算有很大的计算能力 受控环境，但在设备上运行可以提供更高的交互性。<br>在云无法使用或云容量有限的情况下， 您可以提供脱机体验，或通过处理减少云工作负载 容易在设备上的情况。</p>
<p>在设备上进行计算也可以发出何时切换到工作状态的信号 在云上。语音中的热词检测就是一个很好的例子。以来 设备能够不断地收听关键字，然后触发一个<br>一旦被识别出来，很多流量都基于云端的语音识别。没有 在设备上的组件，整个应用程序将是不可行的，这一点 模式也存在于其他几个应用程序中。认识到一些<br>传感器输入是足够有趣的进一步处理使得很多 有趣的产品可能。</p>
<h2><span id="你应该有什么硬件和软件">你应该有什么硬件和软件？</span></h2><p>TensorFlow在Ubuntu Linux，Windows 10和OS X上运行 支持的操作系统和安装TensorFlow的说明，请参阅<br>安装Tensorflow。</p>
<p>请注意，我们为移动TensorFlow提供的一些示例代码需要您 从源头上编译TensorFlow，所以你不仅需要<code>pip install</code><br>通过所有示例代码工作。</p>
<p>要尝试移动示例，您需要为开发设置一个设备， 运用 Android Studio， 或Xcode，如果你正在开发的iOS。</p>
<h2><span id="在开始之前你应该做什么">在开始之前你应该做什么？</span></h2><p>在考虑如何在移动设备上获得解决方案之前，</p>
<p>确定你的问题是否可以通过移动机器学习解决 创建一个带标签的数据集来定义你的问题 为这个问题选择一个有效的模型</p>
<p>我们将在下面更详细地讨论这些。</p>
<h3><span id="移动机器学习能解决您的问题吗">移动机器学习能解决您的问题吗？</span></h3><p>一旦你了解了你想解决的问题，你需要制定一个计划 如何建立你的解决方案。最重要的第一步是确保 你的问题实际上是可以解决的，而最好的办法就是嘲笑它<br>在循环中使用人类。</p>
<p>例如，如果您想使用声控命令驾驶机器人玩具车，请尝试 从设备录制一些音频，然后回听，看看是否可以 理解所说的话。你经常会发现有问题<br>捕获过程中，如电机淹没语音或不能听到 在远方，你应该在投资这些问题之前解决这些问题 建模过程。</p>
<p>另一个例子是从你的应用程序提供的照片给人看看他们 可以按照您所寻找的方式对它们进行分类。如果他们做不到的话 （例如，试图从照片估计食物的卡路里可能是<br>因为所有的白汤都是一样的），那么你需要重新设计 你的经验，以应付这一点。一个好的经验法则是，如果一个人不能 处理任务然后培训一台电脑将会很困难。</p>
<h3><span id="创建一个带标签的数据集">创建一个带标签的数据集</span></h3><p>在解决了你的用例的基本问题之后，你需要 创建一个带标签的数据集来定义你想要解决的问题。这个 步骤是非常重要的，而不是选择使用哪种模型。你想要它<br>尽可能代表您的实际使用情况，因为这个模型 只会在你教你的任务上有效。这也是值得投资的 使数据标记尽可能高效和准确的工具。对于<br>例如，如果您能够从单击网页上的某个按钮切换 界面简单的键盘快捷键，你可以加快速度 生成过程很多。你也应该开始做最初的标签<br>你自己，所以你可以了解的困难和可能的错误，和 可能会更改您的标签或数据捕获过程以避免它们。一旦您 和你的团队能够不断标注的例子（这是你一次<br>大多数例子一般都认同同样的标签），那么你可以试试 捕捉你的知识手册，教外部评估员如何运行相同 处理。</p>
<h3><span id="选择一个有效的模型">选择一个有效的模型</span></h3><p>下一步是选择一个有效的模型来使用。你可能可以避免 如果其他人已经实施了模型，则从头开始训练模型 类似于你所需要的;我们有一个模型库在<br>你可以看Github上的TensorFlow 通过。倾向于找到最简单的模型，并尝试开始 只要你有少量的标签数据，因为你会得到最好的<br>结果，当你能够快速迭代。花费的时间越短 尝试训练一个模型，并在实际应用中运行它，总体上会更好 结果你会看到。一个算法获得很好的训练精度是很常见的<br>数字，但在实际的应用程序中失败，因为有一个 数据集与实际用法之间不匹配。原型端到端的使用尽快 尽可能创造一致的用户体验。</p>
<h2><span id="下一步">下一步</span></h2><p>我们建议您开始制作我们的一个演示 Android或iOS。</p>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">


  <div class="article-tags">
  
  <span></span> <a href="/tags/机器学习/">机器学习</a>
  </div>

</div>




<div class="comments-count">
	
</div>

</footer>


    </article>





  

   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2018/01/01/mechanics/" title="张量流动力学101" itemprop="url">张量流动力学101</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="zhizi" target="_blank" itemprop="author">zhizi</a>
		
  <p class="article-time">
    <time datetime="2018-01-01T02:00:00.000Z" itemprop="datePublished"> 发表于 2018-01-01</time>
    
  </p>
</header>
    <div class="article-content">
        
        <h1><span id="张量流动力学101">张量流动力学101</span></h1><p>代码：tensorflow / examples / tutorials / mnist /</p>
<p>本教程的目标是展示如何使用TensorFlow来训练和 评估一个简单的手写数字前馈神经网络 使用（经典）MNIST数据集进行分类。目标受众<br>本教程是有兴趣使用的有经验的机器学习用户 TensorFlow。</p>
<p>这些教程不适用于一般的机器学习教学。</p>
<p>请确保您已按照说明进行操作 安装TensorFlow。</p>
<h2><span id="教程文件">教程文件</span></h2><p>本教程引用了以下文件：</p>
<table>
<thead>
<tr>
<th>File</th>
<th>Purpose  </th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
</tr>
</tbody>
</table>
<p><a href="https://www.github.com/tensorflow/tensorflow/blob/r1.4/tensorflow/examples/tutorials/mnist/mnist.py" target="_blank" rel="noopener"><code>mnist.py</code></a><br>| The code to build a fully-connected MNIST model.<br><a href="https://www.github.com/tensorflow/tensorflow/blob/r1.4/tensorflow/examples/tutorials/mnist/fully_connected_feed.py" target="_blank" rel="noopener"><code>fully_connected_feed.py</code></a><br>| The main code to train the built MNIST model against the downloaded dataset<br>using a feed dictionary.  </p>
<p>只需直接运行<code>fully_connected_feed.py</code>文件即可开始培训：</p>
<pre><code>python fully_connected_feed.py
</code></pre><h2><span id="准备数据">准备数据</span></h2><p>MNIST是机器学习中的经典问题。问题是看 手写数字的灰度28x28像素图像，并确定哪个数字 图像表示从零到九的所有数字。</p>
<p><img src="https://www.tensorflow.org/images/mnist_digits.png" alt="MNIST Digits"></p>
<p>欲了解更多信息，请参阅Yann LeCun的MNIST页面 或克里斯·奥拉的MNIST的可视化。</p>
<h3><span id="下载">下载</span></h3><p>在<code>run_training()</code>方法的顶部，<code>input_data.read_data_sets()</code> 功能将确保正确的数据已被下载到您的本地<br>培训文件夹，然后解压缩该数据返回<code>DataSet</code>字典 实例。</p>
<pre><code>data_sets = input_data.read_data_sets(FLAGS.train_dir, FLAGS.fake_data)
</code></pre><p>注意：<code>fake_data</code>标志用于单元测试目的，可能是 安全地被读者忽略。</p>
<table>
<thead>
<tr>
<th>Dataset</th>
<th>Purpose  </th>
</tr>
</thead>
<tbody>
<tr>
<td><code>data_sets.train</code></td>
<td>55000 images and labels, for primary training.  </td>
</tr>
<tr>
<td><code>data_sets.validation</code></td>
<td>5000 images and labels, for iterative validation of</td>
</tr>
</tbody>
</table>
<p>training accuracy.<br><code>data_sets.test</code> | 10000 images and labels, for final testing of trained<br>accuracy.  </p>
<h3><span id="输入和占位符">输入和占位符</span></h3><p><code>placeholder_inputs()</code>功能创建两个<code>tf.placeholder</code> ops定义输入的形状，包括<code>batch_size</code><br>图表的其余部分，并将实际的训练实例馈送到其中。</p>
<pre><code>images_placeholder = tf.placeholder(tf.float32, shape=(batch_size,
                                                       mnist.IMAGE_PIXELS))
labels_placeholder = tf.placeholder(tf.int32, shape=(batch_size))
</code></pre><p>再往下，在训练循环中，完整的图像和标签数据集是 切成适合<code>batch_size</code>的每一步，与这些占位符相匹配<br>然后使用<code>sess.run()</code>进入<code>feed_dict</code>功能 参数。</p>
<h2><span id="构建图表">构建图表</span></h2><p>在为数据创建占位符之后，图形将从 <code>mnist.py</code>文件按照三阶段模式：<code>inference()</code>，<code>loss()</code>和 <code>training()</code>。</p>
<p><code>inference()</code> - 根据运行需要构建图形 网络转发做出预测。 <code>loss()</code> - 向推理图添加生成所需的操作 失利。<br><code>training()</code> - 向损失图表添加计算所需的操作 并应用渐变。</p>
<p><img src="https://www.tensorflow.org/images/mnist_subgraph.png" alt=""></p>
<h3><span id="推理">推理</span></h3><p><code>inference()</code>功能根据需要构建图表 返回将包含输出预测的张量。</p>
<p>它将图像占位符作为输入并建立在顶部 它是一对完全连接的层，ReLU激活，然后是十个 节点线性层指定输出logits。</p>
<p><code>tf.name_scope</code>独一无二的图层 作为在该范围内创建的项目的前缀。</p>
<pre><code>with tf.name_scope(&apos;hidden1&apos;):
</code></pre><p>在规定的范围内，每一个要使用的权重和偏差 产生<code>tf.Variable</code>层 实例，与他们所需的形状：</p>
<pre><code>weights = tf.Variable(
    tf.truncated_normal([IMAGE_PIXELS, hidden1_units],
                        stddev=1.0 / math.sqrt(float(IMAGE_PIXELS))),
    name=&apos;weights&apos;)
biases = tf.Variable(tf.zeros([hidden1_units]),
                     name=&apos;biases&apos;)
</code></pre><p>例如，当它们是在<code>hidden1</code>示波器下创建的时候，独一无二的 赋予权重变量的名称是“<code>hidden1/weights</code>”。</p>
<p>每个变量被赋予初始化操作作为其构造的一部分。</p>
<p>在这个最常见的情况下，权重用初始化 <code>tf.truncated_normal</code> 并给出了它们的二维张量的形状 第一个dim表示层中的单元的数量<br>权重连接，第二个dim代表数量 权重连接的图层中的单位。对于第一层，命名 <code>hidden1</code>，外形尺寸为<code>[IMAGE_PIXELS,
hidden1_units]</code> 权重将图像输入连接到hidden1图层。该 <code>tf.truncated_normal</code>初始化器给定一个随机分布<br>均值和标准差。</p>
<p>然后偏差用<code>tf.zeros</code>初始化 确保它们以零值开始，它们的形状就是数字 他们连接的图层中的单位。</p>
<p>该图的三个主要操作 - 两个<code>tf.nn.relu</code> ops包装<code>tf.matmul</code> 为隐藏层和一个额外的<code>tf.matmul</code>为logits - 然后<br>依次创建每个<code>tf.Variable</code>实例 输入占位符或前一层的输出张量。</p>
<pre><code>hidden1 = tf.nn.relu(tf.matmul(images, weights) + biases)



hidden2 = tf.nn.relu(tf.matmul(hidden1, weights) + biases)



logits = tf.matmul(hidden2, weights) + biases
</code></pre><p>最后，返回包含输出的<code>logits</code>张量。</p>
<h3><span id="失利">失利</span></h3><p><code>loss()</code>功能通过添加所需的损耗进一步构建图表 欢声笑语。</p>
<p>首先，将<code>labels_placeholder</code>的值转换为64位整数。然后，添加一个<code>tf.nn.sparse_softmax_cross_entropy_with_logits</code><br>op，从<code>labels_placeholder</code>自动生成单热标签，并将<code>inference()</code>功能的输出对象与这些单热标签进行比较。</p>
<pre><code>labels = tf.to_int64(labels)
cross_entropy = tf.nn.sparse_softmax_cross_entropy_with_logits(
    labels=labels, logits=logits, name=&apos;xentropy&apos;)
</code></pre><p>然后使用<code>tf.reduce_mean</code> 平均整个批量维度的交叉熵值（第一个） 维度）作为总损失。</p>
<pre><code>loss = tf.reduce_mean(cross_entropy, name=&apos;xentropy_mean&apos;)
</code></pre><p>然后将包含损失值的张量返回。</p>
<blockquote>
<p>注：交叉熵是信息理论允许我们的一个想法 描述相信神经网络的预测有多糟糕， 给出什么是真实的。欲了解更多信息，请阅读博客文章Visual<br>信息理论（<a href="http://colah.github.io/posts/2015-09-Visual-Information/）" target="_blank" rel="noopener">http://colah.github.io/posts/2015-09-Visual-Information/）</a></p>
</blockquote>
<h3><span id="训练">训练</span></h3><p><code>training()</code>功能增加了通过减少损失所需的操作 梯度下降。</p>
<p>首先，它从<code>loss()</code>功能中获取损耗张量并将其传递给a <code>tf.summary.scalar</code>， 与a一起使用时生成汇总值到事件文件中的操作<br><code>tf.summary.FileWriter</code>（见下文）。在这种情况下，它会发出快照值 每次写出摘要都会有损失。</p>
<pre><code>tf.summary.scalar(&apos;loss&apos;, loss)
</code></pre><p>接下来，我们实例化一个<code>tf.train.GradientDescentOptimizer</code> 负责按要求的学习率应用渐变。</p>
<pre><code>optimizer = tf.train.GradientDescentOptimizer(learning_rate)
</code></pre><p>然后我们生成一个变量来包含一个全局计数器 培训步骤和<code>tf.train.Optimizer.minimize</code> op用于更新系统中的可训练权重并增加<br>全球一步。按照惯例，该操作称为<code>train_op</code>，是必须的 由TensorFlow会议运行，以诱导一个完整的培训步骤 （见下文）。</p>
<pre><code>global_step = tf.Variable(0, name=&apos;global_step&apos;, trainable=False)
train_op = optimizer.minimize(loss, global_step=global_step)
</code></pre><h2><span id="训练模型">训练模型</span></h2><p>一旦图形被构建，就可以迭代地训练和评估一个循环 由<code>fully_connected_feed.py</code>中的用户代码控制。</p>
<h3><span id="图表">图表</span></h3><p>在<code>run_training()</code>功能的顶部是一个python <code>with</code>命令 表示所有构建的操作都将与默认值相关联 全球<code>tf.Graph</code> 实例。</p>
<pre><code>with tf.Graph().as_default():
</code></pre><p><code>tf.Graph</code>是一组可以一起执行的操作集合。 大多数TensorFlow使用将只需要依靠单个默认图。</p>
<p>更复杂的用途与多个图是可能的，但超出了范围 这个简单的教程。</p>
<h3><span id="会议">会议</span></h3><p>一旦所有的建设准备工作已经完成，所有必要的 生成了一个<code>tf.Session</code> 是为运行图形而创建的。</p>
<pre><code>sess = tf.Session()
</code></pre><p>或者，可以将<code>Session</code>生成为<code>with</code>模块进行作用域：</p>
<pre><code>with tf.Session() as sess:
</code></pre><p>会话的空参数表示此代码将附加到 （或创建，如果尚未创建）默认的本地会话。</p>
<p>创建会话后，立即所有的<code>tf.Variable</code> 实例通过调用<code>tf.Session.run</code>进行初始化 在他们的初始化操作。</p>
<pre><code>init = tf.global_variables_initializer()
sess.run(init)
</code></pre><p><code>tf.Session.run</code> 方法将运行图的完整子集 对应于作为参数传递的op（s）。在这第一个电话，<code>init</code> op是<code>tf.group</code><br>只包含变量的初始值设定项。没有其余的 图表在这里运行;发生在下面的训练循环中。</p>
<h3><span id="火车循环">火车循环</span></h3><p>用会话初始化变量后，可以开始培训。</p>
<p>用户代码控制每步的训练，以及最简单的循环 可以做有益的训练是：</p>
<pre><code>for step in xrange(FLAGS.max_steps):
    sess.run(train_op)
</code></pre><p>但是，本教程稍微复杂一点，因为它也必须切片 为每个步骤提供输入数据以匹配先前生成的占位符。</p>
<h4><span id="喂图表">喂图表</span></h4><p>对于每一个步骤，代码将生成一个饲料字典，将包含 由占位符键控的步骤的一组示例 ops他们代表。</p>
<p>在<code>fill_feed_dict()</code>功能中，查询给定的<code>DataSet</code>的下一个 <code>batch_size</code>套图像和标签，以及与占位符匹配的张量<br>填充包含下一个图像和标签。</p>
<pre><code>images_feed, labels_feed = data_set.next_batch(FLAGS.batch_size,
                                               FLAGS.fake_data)
</code></pre><p>然后用占位符作为键生成一个python字典对象 代表进给张量作为值。</p>
<pre><code>feed_dict = {
    images_placeholder: images_feed,
    labels_placeholder: labels_feed,
}
</code></pre><p>这被传递到<code>sess.run()</code>功能的<code>feed_dict</code>参数中以提供 这一步训练的输入例子。</p>
<h4><span id="检查状态">检查状态</span></h4><p>该代码指定了两个要在其运行调用中获取的值：<code>[train_op, loss]</code>。</p>
<pre><code>for step in xrange(FLAGS.max_steps):
    feed_dict = fill_feed_dict(data_sets.train,
                               images_placeholder,
                               labels_placeholder)
    _, loss_value = sess.run([train_op, loss],
                             feed_dict=feed_dict)
</code></pre><p>因为有两个取值，所以<code>sess.run()</code>返回一个元组 项目。在取值列表中的每个<code>Tensor</code>对应于一个numpy<br>返回的元组中的数组，在此期间充满张量的值 培训的一步。由于<code>train_op</code>是无输出值的<code>Operation</code>，<br>返回的元组中的对应元素是<code>None</code>，因此， 丢弃。但是，<code>loss</code>张量的值如果是模型，则可能成为NaN 在训练期间发散，所以我们捕获这个值用于记录。</p>
<p>假设训练运行良好，没有NaNs，训练循环也是如此 每100步打印一个简单的状态文本，让用户知道状态 训练。</p>
<pre><code>if step % 100 == 0:
    print(&apos;Step %d: loss = %.2f (%.3f sec)&apos; % (step, loss_value, duration))
</code></pre><h4><span id="可视化状态">可视化状态</span></h4><p>为了发出TensorBoard使用的事件文件， 所有的摘要（在这种情况下，只有一个）被收集到一个张量中 在图建设阶段。</p>
<pre><code>summary = tf.summary.merge_all()
</code></pre><p>然后在会话创建后，一个<code>tf.summary.FileWriter</code> 可以被实例化来写入事件文件，其中 包含图形本身和摘要的值。</p>
<pre><code>summary_writer = tf.summary.FileWriter(FLAGS.train_dir, sess.graph)
</code></pre><p>最后，事件文件将每次更新新的汇总值 对<code>summary</code>进行评估，并将其输出传递给作者的<code>add_summary()</code> 功能。</p>
<pre><code>summary_str = sess.run(summary, feed_dict=feed_dict)
summary_writer.add_summary(summary_str, step)
</code></pre><p>当事件文件被写入时，TensorBoard可能会针对训练运行 文件夹以显示摘要中的值。</p>
<p><img src="https://www.tensorflow.org/images/mnist_tensorboard.png" alt="MNIST TensorBoard"></p>
<p>注意：有关如何构建和运行Tensorboard的更多信息，请参阅附带的教程Tensorboard：可视化学习。</p>
<h4><span id="保存一个检查点">保存一个检查点</span></h4><p>为了发出可能用于以后恢复模型的检查点文件 为了进一步的培训或评估，我们实例化一个 <code>tf.train.Saver</code>。</p>
<pre><code>saver = tf.train.Saver()
</code></pre><p>在训练循环中，<code>tf.train.Saver.save</code> 方法将定期被调用来写一个检查点文件到培训 目录中包含所有可训练变量的当前值。</p>
<pre><code>saver.save(sess, FLAGS.train_dir, global_step=step)
</code></pre><p>在将来的某个时候，培训可能会通过使用 <code>tf.train.Saver.restore</code> 方法重新加载模型参数。</p>
<pre><code>saver.restore(sess, FLAGS.train_dir)
</code></pre><h2><span id="评估模型">评估模型</span></h2><p>每千步，代码将尝试评估这两个模型 训练和测试数据集。 <code>do_eval()</code>功能称为三次 培训，验证和测试数据集。</p>
<pre><code>print(&apos;Training Data Eval:&apos;)
do_eval(sess,
        eval_correct,
        images_placeholder,
        labels_placeholder,
        data_sets.train)
print(&apos;Validation Data Eval:&apos;)
do_eval(sess,
        eval_correct,
        images_placeholder,
        labels_placeholder,
        data_sets.validation)
print(&apos;Test Data Eval:&apos;)
do_eval(sess,
        eval_correct,
        images_placeholder,
        labels_placeholder,
        data_sets.test)
</code></pre><blockquote>
<p>请注意，更复杂的用法通常会隔离<code>data_sets.test</code> 只有在大量超参数调整后才能检查。对于<br>为了一个简单的小MNIST问题，然而，我们评估所有的 数据。</p>
</blockquote>
<h3><span id="构建评估图">构建评估图</span></h3><p>在进入训练循环之前，应该已经建立了Eval操作 通过调用<code>evaluation()</code>的<code>mnist.py</code>功能相同<br>作为<code>loss()</code>功能的对象/标记参数。</p>
<pre><code>eval_correct = mnist.evaluation(logits, labels_placeholder)
</code></pre><p><code>evaluation()</code>功能只是生成一个<code>tf.nn.in_top_k</code> 如果真的标签可以自动评分每个模型的输出<br>可以在K最有可能的预测中找到。在这种情况下，我们设置值 的K为1，只考虑一个预测是否正确，如果是真实的标签。</p>
<pre><code>eval_correct = tf.nn.in_top_k(logits, labels, 1)
</code></pre><h3><span id="评估输出">评估输出</span></h3><p>然后可以创建一个回路来填充<code>feed_dict</code>并调用<code>sess.run()</code> 针对<code>eval_correct</code>运算来评估给定数据集上的模型。</p>
<pre><code>for step in xrange(steps_per_epoch):
    feed_dict = fill_feed_dict(data_set,
                               images_placeholder,
                               labels_placeholder)
    true_count += sess.run(eval_correct, feed_dict=feed_dict)
</code></pre><p><code>true_count</code>变量简单地累积了所有的预测 <code>in_top_k</code> op已经确定是正确的。从那里，精度可能是 从简单除以示例的总数计算。</p>
<pre><code>precision = true_count / num_examples
print(&apos;  Num examples: %d  Num correct: %d  Precision @ 1: %0.04f&apos; %
      (num_examples, true_count, precision))
</code></pre>
        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">


  <div class="article-tags">
  
  <span></span> <a href="/tags/机器学习/">机器学习</a>
  </div>

</div>




<div class="comments-count">
	
</div>

</footer>


    </article>





  

   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2018/01/01/wide_and_deep/" title="TensorFlow广泛深度学习教程" itemprop="url">TensorFlow广泛深度学习教程</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="zhizi" target="_blank" itemprop="author">zhizi</a>
		
  <p class="article-time">
    <time datetime="2018-01-01T02:00:00.000Z" itemprop="datePublished"> 发表于 2018-01-01</time>
    
  </p>
</header>
    <div class="article-content">
        
        <h1><span id="tensorflow广泛深度学习教程">TensorFlow广泛深度学习教程</span></h1><p>在之前的TensorFlow线性模型教程中，我们训练了一个逻辑 回归模型来预测个体每年的概率 超过5万美元的收入使用 人口普查收入数据集。<br>TensorFlow也非常适合训练深度神经网络，而且你也许是 思考你应该选择哪一个 - 好吧，为什么不呢？会有可能吗？ 在一个模型中结合两者的优点？</p>
<p>在本教程中，我们将介绍如何共同使用tf.estimator API 训练宽线性模型和深度前馈神经网络。这种方法 结合记忆和泛化的优势。这是有用的<br>通用的大规模回归和稀疏输入的分类问题 特征（例如，具有大量可能特征的分类特征 值）。如果您有兴趣了解更多关于如何广泛和深度学习 作品，请查看我们的研究论文。</p>
<p><img src="https://www.tensorflow.org/images/wide_n_deep.svg" alt="Wide &amp; Deep Spectrum of
Models"></p>
<p>上图显示了一个广泛的模型（logistic回归与 稀疏特征和变换），深层模型（前馈神经网络） 有一个嵌入层和几个隐藏层）和一个Wide＆Deep模型<br>（两者的联合训练）。在较高的层面上，配置a只需要3个步骤 使用tf.estimator API的宽，深或Wide＆Deep模型：</p>
<p>选择广泛部分的功能：选择稀疏基础列和     想要使用的交叉列。 选择深部的特征：选择连续的列，     为每个分类列嵌入维度，以及隐藏层大小。<br>把他们放在一个宽和深的模型     （<code>DNNLinearCombinedClassifier</code>）。</p>
<p>而就是这样！我们来看一个简单的例子。</p>
<h2><span id="建立">建立</span></h2><p>要尝试本教程的代码：</p>
<p>如果你还没有安装TensorFlow， 下载教程代码。 执行我们提供给您的数据下载脚本： $ python data_download.py<br>使用以下命令执行教程代码以训练宽度和 本教程中描述的深层模型： $ python wide_deep.py</p>
<p>继续阅读以了解此代码如何构建其模型。</p>
<h2><span id="定义基本特征列">定义基本特征列</span></h2><p>首先，我们来定义基本分类和连续的特征列 我们将使用。这些基础列将是广泛使用的构建块 部分和模型的深层部分。</p>
<pre><code>import tensorflow as tf

# Continuous columns
age = tf.feature_column.numeric_column(&apos;age&apos;)
education_num = tf.feature_column.numeric_column(&apos;education_num&apos;)
capital_gain = tf.feature_column.numeric_column(&apos;capital_gain&apos;)
capital_loss = tf.feature_column.numeric_column(&apos;capital_loss&apos;)
hours_per_week = tf.feature_column.numeric_column(&apos;hours_per_week&apos;)

education = tf.feature_column.categorical_column_with_vocabulary_list(
    &apos;education&apos;, [
        &apos;Bachelors&apos;, &apos;HS-grad&apos;, &apos;11th&apos;, &apos;Masters&apos;, &apos;9th&apos;, &apos;Some-college&apos;,
        &apos;Assoc-acdm&apos;, &apos;Assoc-voc&apos;, &apos;7th-8th&apos;, &apos;Doctorate&apos;, &apos;Prof-school&apos;,
        &apos;5th-6th&apos;, &apos;10th&apos;, &apos;1st-4th&apos;, &apos;Preschool&apos;, &apos;12th&apos;])

marital_status = tf.feature_column.categorical_column_with_vocabulary_list(
    &apos;marital_status&apos;, [
        &apos;Married-civ-spouse&apos;, &apos;Divorced&apos;, &apos;Married-spouse-absent&apos;,
        &apos;Never-married&apos;, &apos;Separated&apos;, &apos;Married-AF-spouse&apos;, &apos;Widowed&apos;])

relationship = tf.feature_column.categorical_column_with_vocabulary_list(
    &apos;relationship&apos;, [
        &apos;Husband&apos;, &apos;Not-in-family&apos;, &apos;Wife&apos;, &apos;Own-child&apos;, &apos;Unmarried&apos;,
        &apos;Other-relative&apos;])

workclass = tf.feature_column.categorical_column_with_vocabulary_list(
    &apos;workclass&apos;, [
        &apos;Self-emp-not-inc&apos;, &apos;Private&apos;, &apos;State-gov&apos;, &apos;Federal-gov&apos;,
        &apos;Local-gov&apos;, &apos;?&apos;, &apos;Self-emp-inc&apos;, &apos;Without-pay&apos;, &apos;Never-worked&apos;])

# To show an example of hashing:
occupation = tf.feature_column.categorical_column_with_hash_bucket(
    &apos;occupation&apos;, hash_bucket_size=1000)

# Transformations.
age_buckets = tf.feature_column.bucketized_column(
    age, boundaries=[18, 25, 30, 35, 40, 45, 50, 55, 60, 65])
</code></pre><h2><span id="宽模型具有交叉特征列的线性模型">宽模型：具有交叉特征列的线性模型</span></h2><p>宽模型是具有多种稀疏交叉特征的线性模型 列：</p>
<pre><code>base_columns = [
    education, marital_status, relationship, workclass, occupation,
    age_buckets,
]

crossed_columns = [
    tf.feature_column.crossed_column(
        [&apos;education&apos;, &apos;occupation&apos;], hash_bucket_size=1000),
    tf.feature_column.crossed_column(
        [age_buckets, &apos;education&apos;, &apos;occupation&apos;], hash_bucket_size=1000),
]
</code></pre><p>您也可以看到TensorFlow线性模型教程的更多细节。</p>
<p>具有交叉特征列的宽模型可以记忆稀疏交互 之间的功能有效。这就是说，交叉特征的一个局限性 列是他们不推广到没有特征的组合<br>出现在训练数据中。让我们添加一个嵌入式的深层模型来解决 那。</p>
<h2><span id="深层模型带嵌入的神经网络">深层模型：带嵌入的神经网络</span></h2><p>如前所述，深层模型是一个前馈神经网络 数字。每个稀疏的高维分类特征都是第一个 转换成低维和密集的实值矢量，通常被称为 作为嵌入向量。这些低维稠密嵌入向量是<br>与连续的特征串联，然后馈送到隐藏层 神经网络的正向传递。嵌入值被初始化 随机地，并与所有其他模型参数一起训练以最小化<br>训练损失。如果您有兴趣了解有关嵌入的更多信息，请查看 单词或单词向量表示的TensorFlow教程 在维基百科上嵌入的词。</p>
<p>另一种方法来表示分类列喂养神经网络是 通过单热或多热表示。这通常适合于 只有几个可能值的分类列。作为一个热门的例子 <code>&quot;Husband&quot;</code>可以表示为关系栏<br>[1,0,0,0,0,0]和<code>&quot;Not-in-family&quot;</code>为[0,1,0,0,0,0]等。这是一个 固定表示，而嵌入更灵活，并计算在 训练时间。</p>
<p>我们将使用配置分类列的嵌入 <code>embedding_column</code>，并将它们与连续色谱柱连接。 我们还使用<code>indicator_column</code>创建一些多热表示<br>分类列。</p>
<pre><code>deep_columns = [
    age,
    education_num,
    capital_gain,
    capital_loss,
    hours_per_week,
    tf.feature_column.indicator_column(workclass),
    tf.feature_column.indicator_column(education),
    tf.feature_column.indicator_column(marital_status),
    tf.feature_column.indicator_column(relationship),
    # To show an example of embedding
    tf.feature_column.embedding_column(occupation, dimension=8),
]
</code></pre><p>嵌入的<code>dimension</code>越高，自由度越高 模型将不得不学习这些特征的表示。为了简单，我们 在此处将所有要素列的维度设置为8。经验上，更多<br>明智的决定维度的数量是从一个值开始的 \（\ log_2（n）\）或\（k \ sqrt [4] n \）的顺序，其中\（n \）是<br>特征列中的独特功能和\（k \）是一个小常量（通常是 小于10）。</p>
<p>通过密集的嵌入，深层模型可以更好地推广和预测 在训练数据中以前看不到的特征对。不过呢 很难学习有效的低维表征 当两个特征列之间的基础交互矩阵是<br>稀疏和高级。在这种情况下，大多数特征对之间的相互作用 除少数外应为零，但密集的嵌入将导致非零 所有特征对的预测，因此可以过度概括。在另一<br>手，具有交叉特征的线性模型可以记住这些“例外规则” 使用更少的模型参数。</p>
<p>现在，让我们看看如何联合训练广泛和深刻的模型，并允许他们 相辅相成的优点和缺点。</p>
<h2><span id="将宽和深的模型组合成一个">将宽和深的模型组合成一个</span></h2><p>宽模型和深模型通过总结其最终输出进行组合 将对数作为预测，然后将预测结果提供给逻辑损失 功能。所有的图形定义和变量分配已经完成<br>在引擎盖下处理，所以你只需要创建一个 <code>DNNLinearCombinedClassifier</code>：</p>
<pre><code>model = tf.estimator.DNNLinearCombinedClassifier(
    model_dir=&apos;/tmp/census_model&apos;,
    linear_feature_columns=base_columns + crossed_columns,
    dnn_feature_columns=deep_columns,
    dnn_hidden_units=[100, 50])
</code></pre><h2><span id="培训和评估模型">培训和评估模型</span></h2><p>在我们训练模型之前，让我们先看看人口普查数据集 TensorFlow线性模型教程。参见<code>data_download.py</code>以及 <code>input_fn</code>之内<br><code>wide_deep.py</code>。</p>
<p>读完数据后，您可以训练和评估模型：</p>
<pre><code># Train and evaluate the model every `FLAGS.epochs_per_eval` epochs.
for n in range(FLAGS.train_epochs // FLAGS.epochs_per_eval):
  model.train(input_fn=lambda: input_fn(
      FLAGS.train_data, FLAGS.epochs_per_eval, True, FLAGS.batch_size))

  results = model.evaluate(input_fn=lambda: input_fn(
      FLAGS.test_data, 1, False, FLAGS.batch_size))

  # Display evaluation metrics
  print(&apos;Results at epoch&apos;, (n + 1) * FLAGS.epochs_per_eval)
  print(&apos;-&apos; * 30)

  for key in sorted(results):
    print(&apos;%s: %s&apos; % (key, results[key]))
</code></pre><p>最终的输出精度应该在85.5％左右。如果你想 看到一个工作端到端的例子，你可以下载我们的 示例代码。</p>
<p>请注意，本教程只是一个小数据集的简单例子 熟悉API。如果你有广泛和深度的学习将更加强大 尝试使用具有大量稀疏特征列的大型数据集<br>可能的特征值的数量。再次，请随时看看我们的 研究论文如何更多的想法 在现实世界的大型机器学习问题中应用广泛和深度学习。</p>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">


  <div class="article-tags">
  
  <span></span> <a href="/tags/机器学习/">机器学习</a>
  </div>

</div>




<div class="comments-count">
	
</div>

</footer>


    </article>





  

   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2018/01/01/estimator/" title="tf.estimator快速入门" itemprop="url">tf.estimator快速入门</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="zhizi" target="_blank" itemprop="author">zhizi</a>
		
  <p class="article-time">
    <time datetime="2018-01-01T02:00:00.000Z" itemprop="datePublished"> 发表于 2018-01-01</time>
    
  </p>
</header>
    <div class="article-content">
        
        <h1><span id="tfestimator快速入门">tf.estimator快速入门</span></h1><p>TensorFlow的高级机器学习API（tf.estimator）使其变得容易 配置，训练和评估各种机器学习模型。在这<br>教程，你将使用tf.estimator构造一个 神经网络 分类器并在其上进行训练 虹膜数据集 根据萼片/花瓣几何学预测花种。你会写代码 执行以下五个步骤：</p>
<p>将包含虹膜训练/测试数据的CSV加载到TensorFlow <code>Dataset</code>中 构建一个神经网络分类器 使用训练数据训练模型 评估模型的准确性 分类新样品</p>
<p>注意：请记住在您的机器上安装TensorFlow 在开始本教程之前。</p>
<h2><span id="完整的神经网络源代码">完整的神经网络源代码</span></h2><p>以下是神经网络分类器的完整代码：</p>
<pre><code>from __future__ import absolute_import
from __future__ import division
from __future__ import print_function

import os
from six.moves.urllib.request import urlopen

import numpy as np
import tensorflow as tf

# Data sets
IRIS_TRAINING = &quot;iris_training.csv&quot;
IRIS_TRAINING_URL = &quot;http://download.tensorflow.org/data/iris_training.csv&quot;

IRIS_TEST = &quot;iris_test.csv&quot;
IRIS_TEST_URL = &quot;http://download.tensorflow.org/data/iris_test.csv&quot;

def main():
  # If the training and test sets aren&apos;t stored locally, download them.
  if not os.path.exists(IRIS_TRAINING):
    raw = urlopen(IRIS_TRAINING_URL).read()
    with open(IRIS_TRAINING, &quot;wb&quot;) as f:
      f.write(raw)

  if not os.path.exists(IRIS_TEST):
    raw = urlopen(IRIS_TEST_URL).read()
    with open(IRIS_TEST, &quot;wb&quot;) as f:
      f.write(raw)

  # Load datasets.
  training_set = tf.contrib.learn.datasets.base.load_csv_with_header(
      filename=IRIS_TRAINING,
      target_dtype=np.int,
      features_dtype=np.float32)
  test_set = tf.contrib.learn.datasets.base.load_csv_with_header(
      filename=IRIS_TEST,
      target_dtype=np.int,
      features_dtype=np.float32)

  # Specify that all features have real-value data
  feature_columns = [tf.feature_column.numeric_column(&quot;x&quot;, shape=[4])]

  # Build 3 layer DNN with 10, 20, 10 units respectively.
  classifier = tf.estimator.DNNClassifier(feature_columns=feature_columns,
                                          hidden_units=[10, 20, 10],
                                          n_classes=3,
                                          model_dir=&quot;/tmp/iris_model&quot;)
  # Define the training inputs
  train_input_fn = tf.estimator.inputs.numpy_input_fn(
      x={&quot;x&quot;: np.array(training_set.data)},
      y=np.array(training_set.target),
      num_epochs=None,
      shuffle=True)

  # Train model.
  classifier.train(input_fn=train_input_fn, steps=2000)

  # Define the test inputs
  test_input_fn = tf.estimator.inputs.numpy_input_fn(
      x={&quot;x&quot;: np.array(test_set.data)},
      y=np.array(test_set.target),
      num_epochs=1,
      shuffle=False)

  # Evaluate accuracy.
  accuracy_score = classifier.evaluate(input_fn=test_input_fn)[&quot;accuracy&quot;]

  print(&quot;\nTest Accuracy: {0:f}\n&quot;.format(accuracy_score))

  # Classify two new flower samples.
  new_samples = np.array(
      [[6.4, 3.2, 4.5, 1.5],
       [5.8, 3.1, 5.0, 1.7]], dtype=np.float32)
  predict_input_fn = tf.estimator.inputs.numpy_input_fn(
      x={&quot;x&quot;: new_samples},
      num_epochs=1,
      shuffle=False)

  predictions = list(classifier.predict(input_fn=predict_input_fn))
  predicted_classes = [p[&quot;classes&quot;] for p in predictions]

  print(
      &quot;New Samples, Class Predictions:    {}\n&quot;
      .format(predicted_classes))

if __name__ == &quot;__main__&quot;:
    main()
</code></pre><p>以下部分详细介绍了代码。</p>
<h2><span id="将iris-csv数据加载到tensorflow">将Iris CSV数据加载到TensorFlow</span></h2><p>虹膜数据集包含 150行数据，包括来自三个相关虹膜种类的每一个的50个样本： Iris setosa，Iris virginica，以及杂色鸢尾花。</p>
<p><img src="https://www.tensorflow.org/images/iris_three_species.jpg" alt="Petal geometry compared for three iris species: Iris setosa, Iris virginica,
and Iris
versicolor">从左到右，<br>Iris setosa（by Radomil，CC BY-SA 3.0）， 鸢尾花（by Dlanglois，CC BY-SA 3.0），<br>和虹膜virginica （由CC BY-SA的Frank Mayfield提供 2.0）。</p>
<p>每行包含每个花样的以下数据： 萼片长度，萼片宽度， 花瓣长度，花瓣宽度和花 种类。花种以整数表示，0表示虹膜<br>（setosa），1代表鸢尾花，2代表鸢尾花（irris virginica）。</p>
<table>
<thead>
<tr>
<th>Sepal Length</th>
<th>Sepal Width</th>
<th>Petal Length</th>
<th>Petal Width</th>
<th>Species  </th>
</tr>
</thead>
<tbody>
<tr>
<td>5.1</td>
<td>3.5</td>
<td>1.4</td>
<td>0.2</td>
<td>0  </td>
</tr>
<tr>
<td>4.9</td>
<td>3.0</td>
<td>1.4</td>
<td>0.2</td>
<td>0  </td>
</tr>
<tr>
<td>4.7</td>
<td>3.2</td>
<td>1.3</td>
<td>0.2</td>
<td>0  </td>
</tr>
<tr>
<td>…</td>
<td>…</td>
<td>…</td>
<td>…</td>
<td>…  </td>
</tr>
<tr>
<td>7.0</td>
<td>3.2</td>
<td>4.7</td>
<td>1.4</td>
<td>1  </td>
</tr>
<tr>
<td>6.4</td>
<td>3.2</td>
<td>4.5</td>
<td>1.5</td>
<td>1  </td>
</tr>
<tr>
<td>6.9</td>
<td>3.1</td>
<td>4.9</td>
<td>1.5</td>
<td>1  </td>
</tr>
<tr>
<td>…</td>
<td>…</td>
<td>…</td>
<td>…</td>
<td>…  </td>
</tr>
<tr>
<td>6.5</td>
<td>3.0</td>
<td>5.2</td>
<td>2.0</td>
<td>2  </td>
</tr>
<tr>
<td>6.2</td>
<td>3.4</td>
<td>5.4</td>
<td>2.3</td>
<td>2  </td>
</tr>
<tr>
<td>5.9</td>
<td>3.0</td>
<td>5.1</td>
<td>1.8</td>
<td>2  </td>
</tr>
</tbody>
</table>
<p>在本教程中，虹膜数据已经被随机分成两个独立的部分 CSV的：</p>
<p>120个样本的训练集     （iris_training.csv） 30个样本的测试集     （iris_test.csv）。</p>
<p>要开始，首先导入所有必要的模块，并定义在哪里 下载并存储数据集：</p>
<pre><code>from __future__ import absolute_import
from __future__ import division
from __future__ import print_function

import os
from six.moves.urllib.request import urlopen

import tensorflow as tf
import numpy as np

IRIS_TRAINING = &quot;iris_training.csv&quot;
IRIS_TRAINING_URL = &quot;http://download.tensorflow.org/data/iris_training.csv&quot;

IRIS_TEST = &quot;iris_test.csv&quot;
IRIS_TEST_URL = &quot;http://download.tensorflow.org/data/iris_test.csv&quot;
</code></pre><p>然后，如果训练和测试集尚未存储在本地，请下载 他们。</p>
<pre><code>if not os.path.exists(IRIS_TRAINING):
  raw = urlopen(IRIS_TRAINING_URL).read()
  with open(IRIS_TRAINING,&apos;wb&apos;) as f:
    f.write(raw)

if not os.path.exists(IRIS_TEST):
  raw = urlopen(IRIS_TEST_URL).read()
  with open(IRIS_TEST,&apos;wb&apos;) as f:
    f.write(raw)
</code></pre><p>接下来，用<code>Dataset</code>s将训练和测试集加载到<code>load_csv_with_header()</code>s中 <code>learn.datasets.base</code><br>方法在<code>load_csv_with_header()</code>中。 <code>filename</code>方法需要三个 需要的参数：</p>
<p><code>target_dtype</code>，将文件路径转换为CSV文件 <code>numpy</code>，它采取了     <code>features_dtype</code>数据类型<br>的数据集的目标值。 <code>numpy</code>，它采取了     <code>numpy</code>数据类型     数据集的特征值。</p>
<p>在这里，目标（你正在训练模型来预测的价值）是花朵 物种，这是一个从0-2的整数，所以适当的<code>np.int</code>数据类型 是<code>Dataset</code>：</p>
<pre><code># Load datasets.
training_set = tf.contrib.learn.datasets.base.load_csv_with_header(
    filename=IRIS_TRAINING,
    target_dtype=np.int,
    features_dtype=np.float32)
test_set = tf.contrib.learn.datasets.base.load_csv_with_header(
    filename=IRIS_TEST,
    target_dtype=np.int,
    features_dtype=np.float32)
</code></pre><p>在tf.contrib.learn的<code>data</code>s是 命名元组; 您可以通过<code>target</code>和<code>training_set.data</code>访问功能数据和目标值<br>领域。在这里，<code>training_set.target</code>和<code>test_set.data</code>包含此功能<br>数据和训练集的目标值分别和<code>test_set.target</code> 和<code>training_set.data</code>包含测试装置的特征数据和目标值。</p>
<p>后来，在 “将DNNClassifier安装到虹膜培训数据” 您将使用<code>training_set.target</code>和<br><code>test_set.data</code>训练你的模型，并在 “评估模型精度”，您将使用<code>test_set.target</code>和<br><code>Estimator</code>。但首先，您将在下一节中构建您的模型。</p>
<h2><span id="构建深度神经网络分类器">构建深度神经网络分类器</span></h2><p>tf.estimator提供了各种预定义的模型，称为<code>tf.estimator.DNNClassifier</code>s<br>您可以使用“开箱即用”的方式来运行培训和评估操作 数据。 在这里，你将配置一个深度神经网络分类器模型来适应虹膜<br>数据。使用tf.estimator，你可以实例化你的 <code>tf.feature_column.numeric_column</code>只需几行代码：</p>
<pre><code># Specify that all features have real-value data
feature_columns = [tf.feature_column.numeric_column(&quot;x&quot;, shape=[4])]

# Build 3 layer DNN with 10, 20, 10 units respectively.
classifier = tf.estimator.DNNClassifier(feature_columns=feature_columns,
                                        hidden_units=[10, 20, 10],
                                        n_classes=3,
                                        model_dir=&quot;/tmp/iris_model&quot;)
</code></pre><p>上面的代码首先定义了指定数据的模型的特征列 键入数据集中的要素。所有的功能数据是连续的，所以 <code>shape</code>是适用的功能<br>构建特征列。数据集中有四个特征（sepal 宽度，萼片高度，花瓣宽度和花瓣高度），因此<code>[4]</code> 必须设置为<code>DNNClassifier</code>才能保存所有数据。</p>
<p>然后，代码使用以下参数创建一个<code>feature_columns=feature_columns</code>模型：</p>
<p><code>hidden_units=[10, 20, 10]</code>。上面定义的一组特征列。 <code>n_classes=3</code>。三     隐藏的图层，<br>含有10,20和10个神经元。 <code>model_dir=/tmp/iris_model</code>。三个目标类，代表三个鸢尾属。 <code>tf.estimator</code>。<br>TensorFlow将保存的目录     检查点数据和TensorBoard摘要在模型训练期间。</p>
<h2><span id="描述训练输入流水线">描述训练输入流水线</span></h2><p><code>tf.estimator.inputs.numpy_input_fn</code> API使用输入功能，创建TensorFlow 为模型生成数据的操作。<br>我们可以使用<code>classifier</code>生成输入流水线：</p>
<pre><code># Define the training inputs
train_input_fn = tf.estimator.inputs.numpy_input_fn(
    x={&quot;x&quot;: np.array(training_set.data)},
    y=np.array(training_set.target),
    num_epochs=None,
    shuffle=True)
</code></pre><h2><span id="将dnnclassifier安装到虹膜培训数据">将DNNClassifier安装到虹膜培训数据</span></h2><p>现在您已经配置好了DNN <code>train</code>型号，您可以将其安装到 虹膜训练数据使用<code>train_input_fn</code>方法。<br>通过<code>input_fn</code>作为<code>classifier</code>，以及要训练的步数 （这里2000）：</p>
<pre><code># Train model.
classifier.train(input_fn=train_input_fn, steps=2000)
</code></pre><p><code>SessionRunHook</code>中保存了模型的状态，这意味着您可以 如果你喜欢，反复训练。比如上面的就相当于了 以下：</p>
<pre><code>classifier.train(input_fn=train_input_fn, steps=1000)
classifier.train(input_fn=train_input_fn, steps=1000)
</code></pre><p>但是，如果您想在训练时跟踪模型，则可能会有这种情况 想改用TensorFlow <code>DNNClassifier</code> 执行日志记录操作。</p>
<h2><span id="评估模型的准确性">评估模型的准确性</span></h2><p>您已经在虹膜训练数据上训练了您的<code>evaluate</code>模型;轮到你了 可以用Iris检查Iris测试数据的准确性<br><code>train</code>方法。像<code>evaluate</code>一样， <code>evaluate</code>具有构建输入流水线的输入功能。 <code>dict</code><br>返回<code>test_set.data</code>s的评估结果。下面的代码通过了 虹膜测试数据-XCJ743-HDK-<br>53L和<code>test_set.target</code>-到<code>evaluate</code> 并从结果中打印<code>accuracy</code>：</p>
<pre><code># Define the test inputs
test_input_fn = tf.estimator.inputs.numpy_input_fn(
    x={&quot;x&quot;: np.array(test_set.data)},
    y=np.array(test_set.target),
    num_epochs=1,
    shuffle=False)

# Evaluate accuracy.
accuracy_score = classifier.evaluate(input_fn=test_input_fn)[&quot;accuracy&quot;]

print(&quot;\nTest Accuracy: {0:f}\n&quot;.format(accuracy_score))
</code></pre><p>注意：这里<code>num_epochs=1</code>的<code>numpy_input_fn</code>参数非常重要。 <code>test_input_fn</code>将迭代一次数据，然后升高<br><code>OutOfRangeError</code>。这个错误指示分类器停止评估，所以它 将对输入进行一次评估。</p>
<p>当你运行完整的脚本时，它会打印出一些接近的内容：</p>
<pre><code>Test Accuracy: 0.966667
</code></pre><p>您的准确性结果可能会有所不同，但应该高于90％。不坏 一个相对较小的数据集！</p>
<h2><span id="分类新样品">分类新样品</span></h2><p>使用估算器的<code>predict()</code>方法对新样品进行分类。比如说 你有这两个新的花样：</p>
<table>
<thead>
<tr>
<th>Sepal Length</th>
<th>Sepal Width</th>
<th>Petal Length</th>
<th>Petal Width  </th>
</tr>
</thead>
<tbody>
<tr>
<td>6.4</td>
<td>3.2</td>
<td>4.5</td>
<td>1.5  </td>
</tr>
<tr>
<td>5.8</td>
<td>3.1</td>
<td>5.0</td>
<td>1.7  </td>
</tr>
</tbody>
</table>
<p>您可以使用<code>predict()</code>方法预测它们的种类。 <code>predict</code>返回一个 可以很容易地将其转换成列表。下面的代码 检索并打印类别预测：</p>
<pre><code># Classify two new flower samples.
new_samples = np.array(
    [[6.4, 3.2, 4.5, 1.5],
     [5.8, 3.1, 5.0, 1.7]], dtype=np.float32)
predict_input_fn = tf.estimator.inputs.numpy_input_fn(
    x={&quot;x&quot;: new_samples},
    num_epochs=1,
    shuffle=False)

predictions = list(classifier.predict(input_fn=predict_input_fn))
predicted_classes = [p[&quot;classes&quot;] for p in predictions]

print(
    &quot;New Samples, Class Predictions:    {}\n&quot;
    .format(predicted_classes))
</code></pre><p>你的结果应该如下所示：</p>
<pre><code>New Samples, Class Predictions:    [1 2]
</code></pre><p>因此，该模型预测，第一个样本是鸢尾花，并且 第二个样品是虹膜virginica。</p>
<h2><span id="其他资源">其他资源</span></h2><p>要了解更多关于使用tf.estimator创建线性模型的信息，请参阅     具有张量流的大规模线性模型。 要使用tf.estimator<br>API构建您自己的Estimator，请查看     在tf.estimator中创建估计器 为了在浏览器中实现神经网络建模和可视化，<br>看看深度游乐场。 有关神经网络的更高级教程，请参阅     卷积神经网络与递归神经网络     网络。</p>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">


  <div class="article-tags">
  
  <span></span> <a href="/tags/机器学习/">机器学习</a>
  </div>

</div>




<div class="comments-count">
	
</div>

</footer>


    </article>





  

   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2017/12/31/echo-that-outputs-to-stderr/" title="回应输出到stderr" itemprop="url">回应输出到stderr</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="zhizi" target="_blank" itemprop="author">zhizi</a>
		
  <p class="article-time">
    <time datetime="2017-12-31T02:00:00.000Z" itemprop="datePublished"> 发表于 2017-12-31</time>
    
  </p>
</header>
    <div class="article-content">
        
        <p>是否有一个标准的Bash工具，行为像回声，但输出到标准错误而不是标准输出？</p>
<p>我知道我可以做<code>echo foo 1&gt;&amp;2</code>，但它有点丑，我怀疑，容易出错（例如，当事情改变时，更容易被编辑错误）。</p>
        
        
        <p class="article-more-link">
          
            <a href="/2017/12/31/echo-that-outputs-to-stderr/#more">Read More</a>
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">


  <div class="article-tags">
  
  <span></span> <a href="/tags/bash/">bash</a>
  </div>

</div>




<div class="comments-count">
	
</div>

</footer>


    </article>





  

   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2017/12/31/is-quitting-an-application-frowned-upon/" title="正在放弃申请吗？" itemprop="url">正在放弃申请吗？</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="zhizi" target="_blank" itemprop="author">zhizi</a>
		
  <p class="article-time">
    <time datetime="2017-12-31T02:00:00.000Z" itemprop="datePublished"> 发表于 2017-12-31</time>
    
  </p>
</header>
    <div class="article-content">
        
        <p>在我学习Android的尝试中，我刚刚阅读了以下内容：</p>
<blockquote>
<p>Question: <em>Does the user have a choice to kill the application unless we put<br>a menu option in to kill it? If no such option exists, how does the user<br>terminate the application?</em></p>
</blockquote>
<p>&gt;</p>
<blockquote>
<p>Answer: (Romain Guy): <em>The user doesn’t, the system handles this<br>automatically. That’s what the activity lifecycle (especially<br>onPause/onStop/onDestroy) is for. No matter what you do, do not put a “quit”<br>or “exit” application button. It is useless with Android’s application model.<br>This is also contrary to how core applications work.</em></p>
</blockquote>
<p>嘿嘿，我在Android世界的每一步都遇到了一些问题=（</p>
<p>显然，你不能退出Android的应用程序（但Android系统可以很好地彻底摧毁你的应用程序，只要感觉像）。那是怎么回事？我开始认为编写一个“普通应用程序”的应用程序是不可能的</p>
<ul>
<li>用户可以在他/她决定这样做时退出应用程序。这不是应该依靠操作系统来做的事情。</li>
</ul>
<p>我试图创建的应用程序不是Android Market的应用程序。这不是一般公众“广泛使用”的应用程序，它是一个将在狭窄的业务领域使用的商业应用程序。</p>
<p>实际上，我真的很期待为Android平台开发，因为它解决了Windows<br>Mobile和.NET中存在的许多问题。不过，上个星期对我来说有点关闭了……我希望我不必放弃Android，但现在看起来不太好（=</p>
<p>有没有办法让我真的退出应用程序？</p>
        
        
        <p class="article-more-link">
          
            <a href="/2017/12/31/is-quitting-an-application-frowned-upon/#more">Read More</a>
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">


</div>




<div class="comments-count">
	
</div>

</footer>


    </article>





  

   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2017/12/31/vertically-align-text-in-a-div/" title="在div中垂直对齐文本" itemprop="url">在div中垂直对齐文本</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="zhizi" target="_blank" itemprop="author">zhizi</a>
		
  <p class="article-time">
    <time datetime="2017-12-31T02:00:00.000Z" itemprop="datePublished"> 发表于 2017-12-31</time>
    
  </p>
</header>
    <div class="article-content">
        
        <p>我正在尝试找到最有效的方式来对齐文本与div。我已经尝试了一些东西，似乎没有工作。</p>
<pre><code>.testimonialText
    {
        position: absolute;
        left: 15px;
        top: 15px;
        width: 150px;
        height: 309px;
        vertical-align: middle;
        text-align: center;
        font-family: Georgia, &quot;Times New Roman&quot;, Times, serif;
        font-style: italic;
        padding: 1em 0 1em 0;
    }


&lt;div class=&quot;testimonialText&quot;&gt; 
Lorem ipsum dolor sit amet, consectetur adipisicing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.
&lt;/div&gt;
</code></pre>
        
        
        <p class="article-more-link">
          
            <a href="/2017/12/31/vertically-align-text-in-a-div/#more">Read More</a>
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">


  <div class="article-tags">
  
  <span></span> <a href="/tags/html/">html</a><a href="/tags/css/">css</a>
  </div>

</div>




<div class="comments-count">
	
</div>

</footer>


    </article>





  

   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2017/12/31/what-is-thread-safe-or-non-thread-safe-in-php/" title="在PHP中，线程安全或非线程安全是什么？" itemprop="url">在PHP中，线程安全或非线程安全是什么？</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="zhizi" target="_blank" itemprop="author">zhizi</a>
		
  <p class="article-time">
    <time datetime="2017-12-31T02:00:00.000Z" itemprop="datePublished"> 发表于 2017-12-31</time>
    
  </p>
</header>
    <div class="article-content">
        
        <p>我看到了PHP的不同的二进制文件，如非线程或线程安全？这是什么意思？这些软件包有什么区别？</p>
        
        
        <p class="article-more-link">
          
            <a href="/2017/12/31/what-is-thread-safe-or-non-thread-safe-in-php/#more">Read More</a>
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">


  <div class="article-tags">
  
  <span></span> <a href="/tags/php/">php</a>
  </div>

</div>




<div class="comments-count">
	
</div>

</footer>


    </article>





  


  <nav id="page-nav" class="clearfix">
    <a class="extend prev" rel="prev" href="/page/124/"><span></span>Prev</a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/123/">123</a><a class="page-number" href="/page/124/">124</a><span class="page-number current">125</span><a class="page-number" href="/page/126/">126</a><a class="page-number" href="/page/127/">127</a><span class="space">&hellip;</span><a class="page-number" href="/page/157/">157</a><a class="extend next" rel="next" href="/page/126/">Next<span></span></a>
  </nav>

</div>

      <div class="openaside"><a class="navbutton" href="#" title="显示侧边栏"></a></div>

<div id="asidepart">
<div class="closeaside"><a class="closebutton" href="#" title="隐藏侧边栏"></a></div>
<aside class="clearfix">
<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<!-- side-bar-ad -->
<ins class="adsbygoogle"
     style="display:block; overflow:hidden;"
     data-ad-client="ca-pub-6300557868920774"
     data-ad-slot="2232545787"
     data-ad-format="auto"></ins>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>


  


  
<div class="tagslist">
	<p class="asidetitle">标签</p>
		<ul class="clearfix">
		
			
				<li><a href="/tags/javascript/" title="javascript">javascript<sup>207</sup></a></li>
			
		
			
				<li><a href="/tags/java/" title="java">java<sup>205</sup></a></li>
			
		
			
				<li><a href="/tags/html/" title="html">html<sup>203</sup></a></li>
			
		
			
				<li><a href="/tags/python/" title="python">python<sup>199</sup></a></li>
			
		
			
				<li><a href="/tags/bash/" title="bash">bash<sup>198</sup></a></li>
			
		
			
				<li><a href="/tags/php/" title="php">php<sup>197</sup></a></li>
			
		
			
				<li><a href="/tags/css/" title="css">css<sup>88</sup></a></li>
			
		
			
				<li><a href="/tags/shell/" title="shell">shell<sup>78</sup></a></li>
			
		
			
				<li><a href="/tags/jquery/" title="jquery">jquery<sup>61</sup></a></li>
			
		
			
				<li><a href="/tags/linux/" title="linux">linux<sup>57</sup></a></li>
			
		
			
				<li><a href="/tags/机器学习/" title="机器学习">机器学习<sup>41</sup></a></li>
			
		
			
				<li><a href="/tags/unix/" title="unix">unix<sup>30</sup></a></li>
			
		
			
				<li><a href="/tags/mysql/" title="mysql">mysql<sup>17</sup></a></li>
			
		
			
				<li><a href="/tags/html5/" title="html5">html5<sup>16</sup></a></li>
			
		
			
				<li><a href="/tags/xml/" title="xml">xml<sup>13</sup></a></li>
			
		
			
				<li><a href="/tags/http/" title="http">http<sup>10</sup></a></li>
			
		
			
				<li><a href="/tags/区块链/" title="区块链">区块链<sup>1</sup></a></li>
			
		
		</ul>
</div>


  <div class="linkslist">
  <p class="asidetitle">友情链接</p>
    <ul>
        
          <li>
            
            	<a href="https://tracholar.github.io" target="_blank" title="个人博客">个人博客</a>
            
          </li>
        
    </ul>
</div>

  <div class="rsspart">
	<a href="/atom.xml" target="_blank" title="rss">RSS 订阅</a>
</div>

</aside>
</div>

    </div>
    <footer><div id="footer" >
	
	
	<section class="info">
		<p> To be or not to be, that is a question. <br/>
			This is my blog,believe it or not.</p>
	</section>
	 
	<div class="social-font" class="clearfix">
		
		
		
		
		
		
		
		
		
		
	</div>
			
		

		<p class="copyright">
		版权所有 © 2018 本站文章未经同意，禁止转载！作者：
		
		<a href="/about" target="_blank" title="zhizi">zhizi</a>
		


		</p>
</div>
</footer>
    <script src="/js/jquery-2.0.3.min.js"></script>
<script src="/js/jquery.imagesloaded.min.js"></script>
<script src="/js/gallery.js"></script>
<script src="/js/jquery.qrcode-0.12.0.min.js"></script>

<script type="text/javascript">
$(document).ready(function(){ 
  $('.navbar').click(function(){
    $('header nav').toggleClass('shownav');
  });
  var myWidth = 0;
  function getSize(){
    if( typeof( window.innerWidth ) == 'number' ) {
      myWidth = window.innerWidth;
    } else if( document.documentElement && document.documentElement.clientWidth) {
      myWidth = document.documentElement.clientWidth;
    };
  };
  var m = $('#main'),
      a = $('#asidepart'),
      c = $('.closeaside'),
      o = $('.openaside');
  c.click(function(){
    a.addClass('fadeOut').css('display', 'none');
    o.css('display', 'block').addClass('fadeIn');
    m.addClass('moveMain');
  });
  o.click(function(){
    o.css('display', 'none').removeClass('beforeFadeIn');
    a.css('display', 'block').removeClass('fadeOut').addClass('fadeIn');      
    m.removeClass('moveMain');
  });
  $(window).scroll(function(){
    o.css("top",Math.max(80,260-$(this).scrollTop()));
  });
  
  $(window).resize(function(){
    getSize(); 
    if (myWidth >= 1024) {
      $('header nav').removeClass('shownav');
    }else{
      m.removeClass('moveMain');
      a.css('display', 'block').removeClass('fadeOut');
      o.css('display', 'none');
        
    }
  });
});
</script>












<link rel="stylesheet" href="/fancybox/jquery.fancybox.css" media="screen" type="text/css">
<script src="/fancybox/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
$(document).ready(function(){ 
  $('.article-content').each(function(i){
    $(this).find('img').each(function(){
      if ($(this).parent().hasClass('fancybox')) return;
      var alt = this.alt;
      if (alt) $(this).after('<span class="caption">' + alt + '</span>');
      $(this).wrap('<a href="' + this.src + '" title="' + alt + '" class="fancybox"></a>');
    });
    $(this).find('.fancybox').each(function(){
      $(this).attr('rel', 'article' + i);
    });
  });
  if($.fancybox){
    $('.fancybox').fancybox();
  }
}); 
</script>



<!-- Analytics Begin -->





<!-- Analytics End -->

<!-- Totop Begin -->

	<div id="totop">
	<a title="返回顶部"><img src="/img/scrollup.png"/></a>
	</div>
	<script src="/js/totop.js"></script>

<!-- Totop End -->

<!-- MathJax Begin -->
<!-- mathjax config similar to math.stackexchange -->

<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [ ['$','$'], ["\\(","\\)"] ],
      processEscapes: true
    }
  });
</script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
      tex2jax: {
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
      }
    });
</script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for(i=0; i < all.length; i += 1) {
            all[i].SourceElement().parentNode.className += ' has-jax';
        }
    });
</script>

<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>


<!-- MathJax End -->

<!-- Tiny_search Begin -->

<!-- Tiny_search End -->

  </body>
 </html>
